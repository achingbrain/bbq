
app = {
	page: {
		
	}
};

behaviour = {
	ajax: {
		
	},
	date: {
		
	},
	gui: {
		button: {
			
		},
		error: {
			
		},
		panel: {
			
		},
		table: {
			
		},
		token: {
			
		},
		tree: {
			
		},
		updateables: {
			
		}

	},
	lang: {
		
	},
	language: {
		
	},
	page: {
		
	},
	util: {
		
	},
	web: {
		
	}
};

behaviour.constants = {
	
};

deadline = {
	contacts: {
		importers: {
			
		}

	},
	entities: {
		
	},
	gui: {
		admin: {
			
		},
		assets: {
			
		},
		button: {
			
		},
		chat: {
			
		},
		contacts: {
			
		},
		events: {
			
		},
		home: {
			
		},
		interviewer: {
			
		},
		interviews: {
			
		},
		layout: {
			
		},
		messages: {
			
		},
		notificationArea: {
			
		},
		packagedownloader: {
			
		},
		packages: {
			
		},
		panel: {
			detail: {
				
			},
			display: {
				
			},
			help: {
				
			},
			overview: {
				
			}

		},
		preferences: {
			
		},
		reports: {
			predicates: {
				
			}

		},
		selectors: {
			
		},
		staff: {
			
		},
		stories: {
			
		},
		token: {
			
		},
		uploads: {
			
		}

	},
	messages: {
		
	},
	page: {
		
	},
	staff: {
		
	},
	web: {
		
	}
};

deadline.constants = {
	DEADLINE_BROADCASTERSTATUS_CONNECTED: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_1_WORK: 22,
	DEADLINE_PREDICATE_MODIFIEDDATE: 7,
	DEADLINE_ASSET_MSWORD: 19,
	DEADLINE_PREFERENCES_PERFORMANCE: "a021d8ba-aeca-102c-b314-57b27740da86",
	DEADLINE_ADDRESS_CITY: 3,
	DEADLINE_ASSET_MSPOWERPOINT: 15,
	DEADLINE_TITLE_MRS: 2,
	DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTAFF: "c99c283a-aeca-102c-b314-57b27740da86",
	DEADLINE_TITLE_DR: 5,
	DEADLINE_PREDICATE_STARTDATE: 2,
	DEADLINE_ASSET_TIFF: 18,
	DEADLINE_MESSAGE_CODE_STORYADDEDTOEVENT: 17,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_POSTCODE_HOME: 32,
	DEADLINE_REPORT_FILTER_STORIES: 0,
	DEADLINE_CONTACTS_IMPORTMETHOD_MSEXCHANGE: 3,
	DEADLINE_TITLE_NULL: 0,
	DEADLINE_ADDRESS_STREET: 1,
	DEADLINE_ADDRESS_COUNTRY: 5,
	DEADLINE_CONTACTS_IMPORTFIELD_PAGER_HOME: 20,
	DEADLINE_CONTACTS_WORK: 0,
	DEADLINE_CONTACTS_IMPORTFIELD_MOBILE_WORK: 13,
	DEADLINE_CONTACTS_IMPORTFIELD_DEPARTMENT: 5,
	DEADLINE_MESSAGE_CODE_STORYCREATED: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_COUNTRY_WORK: 27,
	DEADLINE_DATEFORMAT_DDMMYYYY: 0,
	DEADLINE_ASSET_ARCHIVE: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_EMAIL_OTHER: 9,
	DEADLINE_PREDICATE_PHOTOEDITOR: 3,
	DEADLINE_PREFERENCES_UPDATESUCCESSFUL: 0,
	DEADLINE_PREFERENCES_CHAT_ALWAYSSHOWCHATTERS: "ef55a034-aecb-102c-b314-57b27740da86",
	DEADLINE_MESSAGE_RECIPIENT_STAFF: 2,
	DEADLINE_ASSETS_ASSIGNMENT: 0,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_4_OTHER: 37,
	DEADLINE_REPORT_PRESETREPORT5: "08c81ad8-3f52-64c9-5b73-0000637acd73",
	DEADLINE_REPORT_PRESETREPORT4: "2245cede-2e37-9228-1a68-00001be1ed8a",
	DEADLINE_PREFERENCES_DATEFORMAT: "8e71b2c0-aeca-102c-b314-57b27740da86",
	DEADLINE_CONTACTS_IMPORTFIELD_PHONE_HOME: 11,
	DEADLINE_REPORT_PRESETREPORT3: "3adf9619-17c9-1de8-d365-00007908d480",
	DEADLINE_REPORT_PRESETREPORT2: "656bfd5f-4f62-49a8-a2db-000019335bec",
	DEADLINE_REPORT_PRESETREPORT1: "4c08543c-14d3-97a8-3a14-0000434dba2d",
	DEADLINE_REPORT_PRESETREPORT0: "277dbaaa-9bd9-5fc8-9382-000058c8c02f",
	DEADLINE_PERMISSIONS_VIEWALLSTORIES: 2,
	DEADLINE_MESSAGE_CODE_ASSETUPLOADEDTOASSIGNMENT: 13,
	DEADLINE_CONTACTS_IMPORTFIELD_FAX_HOME: 17,
	DEADLINE_ADMIN_INSTANCETYPE_SINGLEUSER: 0,
	DEADLINE_PREDICATE_FROMDATE: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_1_HOME: 28,
	DEADLINE_ASSET_AWAITINGUPLOAD: 0,
	DEADLINE_ENTITYARCHIVED_YES: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_LASTNAME: 3,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_2_OTHER: 35,
	DEADLINE_ADDRESS_POSTCODE: 4,
	DEADLINE_ASSET_DATABASE: 9,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_3_OTHER: 36,
	DEADLINE_ASSET_PSD: 16,
	DEADLINE_ASSIGNMENTSTATUS_DUE: 1,
	DEADLINE_PREDICATE_BETWEEN: 3,
	DEADLINE_MESSAGE_VIDEO: 2,
	DEADLINE_MESSAGES_DELETED_FOLDER: "a10a796c-b89f-48fd-b51c-f4718c007e3a",
	DEADLINE_ASSET_MSACCESS: 21,
	DEADLINE_CONTACTS_IMPORTMETHOD_COMMADELIMITED: 1,
	DEADLINE_STORYSTATUS_SCHEDULED: 0,
	DEADLINE_CONTACTS_IMPORTFIELD_EMAIL_WORK: 7,
	DEADLINE_MESSAGE_SYSTEM: 0,
	DEADLINE_PREFERENCES_DUPLICATEUSERNAME: 1,
	DEADLINE_CONTACTS_HOME: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_MOBILE_HOME: 14,
	DEADLINE_PREDICATE_UPLOADSTATUS: 6,
	DEADLINE_PREDICATE_DUEIN: 3,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_2_WORK: 23,
	DEADLINE_PREFERENCES_SENDEMAILONSTAFFMESSAGES: "c434249c-aeca-102c-b314-57b27740da86",
	DEADLINE_MESSAGE_CODE_EVENTUPDATED: 15,
	DEADLINE_MESSAGES_FILTER_TITLE: "b10a796c-b89f-48fd-b51c-f4718c007e3a",
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_1_OTHER: 34,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_COUNTRY_HOME: 33,
	DEADLINE_MESSAGES_SENT_FOLDER: "5cad7c81-4de1-4ea9-b460-6169a701d9f8",
	DEADLINE_FEEDSTATUS_AUTHENTICATIONFALIURE: 3,
	DEADLINE_PERMISSIONS_ADDSTORIES: 0,
	DEADLINE_MESSAGE_CODE_ASSETADDEDTOASSIGNMENT: 11,
	DEADLINE_TITLE_MS: 3,
	DEADLINE_DATEFORMAT_DATETIME: 3,
	DEADLINE_CONTACTS_IMPORTMETHOD_VCARD: 0,
	DEADLINE_REPORT_PRESETREPORT_CANCELLED: 4,
	DEADLINE_TITLE_MR: 1,
	DEADLINE_UPLOADSTATUS_UPLOADED: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_JOBTITLE: 6,
	DEADLINE_NUMBER_FAX: 2,
	DEADLINE_ASSETSTATUS_SCHEDULED: 0,
	DEADLINE_DATEFORMAT_RFC2822: 4,
	DEADLINE_PACKAGESTATUS_OPEN: 0,
	DEADLINE_NUMBER_PAGER: 3,
	DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWASSIGNMENTS: "d51e4738-aeca-102c-b314-57b27740da86",
	DEADLINE_PERFORMANCE_FAST: 1,
	DEADLINE_MESSAGE_CODE_ASSIGNMENTCREATED: 2,
	DEADLINE_PREDICATE_STATUS: 5,
	DEADLINE_MESSAGE_RECIPIENT_ASSIGNMENT: 1,
	DEADLINE_CONTACTS_EXPORTMETHOD_COMMADELIMITED: 1,
	DEADLINE_ASSIGNMENTSTATUS_SCHEDULED: 0,
	DEADLINE_TITLE_MISS: 4,
	DEADLINE_ASSET_GENERIC: 1,
	DEADLINE_ASSET_RAW_IMAGE: 17,
	DEADLINE_CONTACTS_IMPORTFIELD_FIRSTNAME: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_PAGER_OTHER: 21,
	DEADLINE_FEEDSTATUS_INVALID: 2,
	DEADLINE_ASSET_JPEG: 12,
	DEADLINE_CONTACTS_IMPORTMETHOD_TABDELIMITED: 2,
	DEADLINE_ASSET_MSEXCEL: 10,
	DEADLINE_MESSAGE_CODE_EVENTDELETED: 16,
	DEADLINE_PREDICATE_WEATHERPRESENTER: 7,
	DEADLINE_CONTACTS_IMPORTFIELD_EMAIL_HOME: 8,
	DEADLINE_ADDRESS_TOWN: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_MOBILE_OTHER: 15,
	DEADLINE_ASSET_PDF: 13,
	DEADLINE_MESSAGES_PERSONAL_FOLDER: "f20b6893-9453-4c91-b792-d3b9f6bc2200",
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_2_HOME: 29,
	DEADLINE_ASSET_IMAGE: 4,
	DEADLINE_FEEDSTATUS_OK: 0,
	DEADLINE_PREDICATE_PHOTOGRAPHER: 1,
	DEADLINE_PREFERENCES_SHOWSYSTEMMESSAGESONHOMEPAGE: "aceae140-aeca-102c-b314-57b27740da86",
	DEADLINE_DATEFORMAT_DOTTED: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_NOTES: 40,
	DEADLINE_NUMBER_MOBILE: 1,
	DEADLINE_MESSAGE_CODE_STAFFREMOVEDFROMASSIGNMENT: 8,
	DEADLINE_ADMIN_INSTANCETYPE_SELFHOSTED: 3,
	DEADLINE_MESSAGE_CODE_STAFFADDEDTOASSIGNMENT: 7,
	DEADLINE_CONTACTS_IMPORTFIELD_IGNORE: 0,
	DEADLINE_MESSAGE_CODE_STORYUPDATED: 3,
	DEADLINE_PREDICATE_ANCHOR: 6,
	DEADLINE_MESSAGES_ASSIGNMENT_FOLDER: "7c7d4566-2916-4746-9409-7cee5ed1fc8f",
	DEADLINE_PAGINATOROPTIONS_SORTDESC: 0,
	DEADLINE_ASSET_VIDEO: 6,
	DEADLINE_PREFERENCES_THEME: "a5c679ec-aeca-102c-b314-57b27740da86",
	DEADLINE_PREFERENCES_FEEDINVALID: 3,
	DEADLINE_ASSET_SPREADSHEET: 8,
	DEADLINE_THEMES0: "050572a7-4b27-a948-93e7-000048bef09b",
	DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTORIES: "fec2fda2-aeca-102c-b314-57b27740da86",
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_3_WORK: 24,
	DEADLINE_PREDICATE_ONDATE: 0,
	DEADLINE_NUMBER_TELEPHONE: 0,
	DEADLINE_PREDICATE_EDITOR: 2,
	DEADLINE_BROADCASTERSTATUS_NOTCONNECTED: -1,
	DEADLINE_CONTACTS_CONFLICTSTATUS_KEEP: 0,
	DEADLINE_MESSAGE_CODE_STAFFADDEDTOSTORY: 5,
	DEADLINE_ASSET_PRESENTATION: 7,
	DEADLINE_ASSETSTATUS_CANCELLED: 3,
	DEADLINE_ENTITYARCHIVED_NO: 0,
	DEADLINE_MESSAGE_TEXT: 1,
	DEADLINE_STORIES_BACKGROUNDASSIGNMENT: 1,
	DEADLINE_PREDICATE_PERSON: 4,
	DEADLINE_STORYSTATUS_CANCELLED: 3,
	DEADLINE_ASSETSTATUS_COMPLETED: 4,
	DEADLINE_PREDICATE_TODAY: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_COUNTRY_OTHER: 39,
	DEADLINE_PERFORMANCE_REASONABLE: 0,
	DEADLINE_ASSET_TEXT: 5,
	DEADLINE_PREDICATE_DEADLINEDATE: 0,
	DEADLINE_STORYSTATUS_COMPLETED: 4,
	DEADLINE_ASSIGNMENTSTATUS_LATE: 2,
	DEADLINE_THEMES_DEFAULT: 0,
	DEADLINE_PACKAGESTATUS_PICKEDUP: 2,
	DEADLINE_ASSET_GIF: 11,
	DEADLINE_REPORT_PRESETREPORT_DUNEINONEHOUR: 0,
	DEADLINE_STORYSTATUS_DUE: 1,
	DEADLINE_PREDICATE_BEFOREDATE: 1,
	DEADLINE_ASSET_PNG: 14,
	DEADLINE_REPORT_PRESETREPORT_OVERDUE: 3,
	DEADLINE_MESSAGE_CODE_ASSIGNMENTUPDATED: 4,
	DEADLINE_CONTACTS_IMPORTFIELD_PHONE_OTHER: 12,
	DEADLINE_REPORT_PRESETREPORT_DUETODAY: 1,
	DEADLINE_PREDICATE_ARCHIVED: 8,
	DEADLINE_PREDICATE_RESEARCHER: 5,
	DEADLINE_ASSIGNMENTSTATUS_CANCELLED: 3,
	DEADLINE_PREFERENCES_NOAUDIO: "b442f63a-aeca-102c-b314-57b27740da86",
	DEADLINE_PERMISSIONS_ADDEVENTS: 1,
	DEADLINE_PACKAGESTATUS_DELAYED: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_3_HOME: 30,
	DEADLINE_CONTACTS_IMPORTFIELD_FAX_OTHER: 18,
	DEADLINE_PAGINATOROPTIONS_SORTASC: 1,
	DEADLINE_PREFERENCES_SENDEMAILONSYSTEMMESSAGES: "bebd1906-aeca-102c-b314-57b27740da86",
	DEADLINE_PREDICATE_CAMERAOPERATOR: 4,
	DEADLINE_ASSIGNMENTSTATUS_COMPLETED: 4,
	DEADLINE_ASSET_AUDIO: 3,
	DEADLINE_CONTACTS_EXPORTMETHOD_VCARD: 0,
	DEADLINE_CONTACTS_EXPORTMETHOD_TABDELIMITED: 2,
	DEADLINE_PREDICATE_CREATIONDATE: 1,
	DEADLINE_CONTACTS_IMPORTMETHOD_LOTUSNOTES: 4,
	DEADLINE_ASSETSTATUS_LATE: 2,
	DEADLINE_ASSETSTATUS_DUE: 1,
	DEADLINE_CONTACTS_OTHER: 2,
	DEADLINE_ASSET_DEADLINEINTERVIEW: 22,
	DEADLINE_ADMIN_INSTANCETYPE_LARGEGROUP: 2,
	DEADLINE_REPORT_FILTER_ASSETS: 2,
	DEADLINE_CONTACTS_CONFLICTSTATUS_OVERWRITE: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_4_WORK: 25,
	DEADLINE_UPLOADSTATUS_AWAITING: 0,
	DEADLINE_INTERVIEWER_INTERVIEWER: 0,
	DEADLINE_INTERVIEWER_PLAYBACK: 2,
	DEADLINE_PREDICATE_ROLE: 0,
	DEADLINE_MESSAGE_CODE_ASSETREMOVEDFROMASSIGNMENT: 12,
	DEADLINE_PREDICATE_DAYS: 1,
	DEADLINE_DATEFORMAT_MMDDYYYY: 1,
	DEADLINE_INTERVIEWER_INTERVIEWEE: 1,
	DEADLINE_REPORT_PRESETREPORT_DUENEXTWEEK: 2,
	DEADLINE_MESSAGE_CODE_STAFFREMOVEDFROMSTORY: 6,
	DEADLINE_PERFORMANCE_SLOW: 2,
	DEADLINE_MESSAGE_CODE_EVENTCREATED: 14,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_POSTCODE_WORK: 26,
	DEADLINE_BROADCASTERSTATUS_CONNECTING: 0,
	DEADLINE_CONTACTS_IMPORTFIELD_COMPANYNAME: 4,
	DEADLINE_REPORT_FILTER_ASSIGNMENTS: 1,
	DEADLINE_MESSAGE_CODE_STORYREMOVEDFROMEVENT: 18,
	DEADLINE_CONTACTS_IMPORTFIELD_PAGER_WORK: 19,
	DEADLINE_ASSET_ZIP: 20,
	DEADLINE_PREFERENCES_FEEDAUTHENTICATIONFALIURE: 4,
	DEADLINE_PREDICATE_JOURNALIST: 0,
	DEADLINE_MESSAGES_SYSTEM_FOLDER: "f5b78c66-c0d5-43c7-a665-ae40b2d05548",
	DEADLINE_FEEDSTATUS_SERVERNOTFOUND: 4,
	DEADLINE_CONTACTS_IMPORTFIELD_TITLE: 1,
	DEADLINE_PREDICATE_HOURS: 0,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_4_HOME: 31,
	DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE: "da13c998-aeca-102c-b314-57b27740da86",
	DEADLINE_ADDRESS_HOUSE: 0,
	DEADLINE_FEEDSTATUS_NOTFOUND: 1,
	DEADLINE_CONTACTS_IMPORTFIELD_ADDRESS_POSTCODE_OTHER: 38,
	DEADLINE_PREFERENCES_LANGUAGE: "98a2b94c-aeca-102c-b314-57b27740da86",
	DEADLINE_CONTACTS_IMPORTFIELD_PHONE_WORK: 10,
	DEADLINE_MESSAGE_RECIPIENT_STORY: 0,
	DEADLINE_PREDICATE_NAME: 1,
	DEADLINE_MESSAGES_STORY_FOLDER: "53f90c30-df44-4424-baab-543088c85ab3",
	DEADLINE_REPORT_PRESETREPORT_ARCHIVED: 5,
	DEADLINE_STORYSTATUS_LATE: 2,
	DEADLINE_PREFERENCES_FEEDNOTFOUND: 2,
	DEADLINE_CONTACTS_IMPORTFIELD_FAX_WORK: 16,
	DEADLINE_ADMIN_INSTANCETYPE_SMALLGROUP: 1,
	DEADLINE_ASSETS_SHARED: 1,
	DEADLINE_MESSAGE_CODE_CONTACTREMOVEDFROMASSIGNMENT: 10,
	DEADLINE_MESSAGE_CODE_CONTACTADDEDTOASSIGNMENT: 9,
	DEADLINE_MESSAGES_INBOX_FOLDER: "0dec6e71-9cec-467e-9b80-fba4b9f2b5d9"
};

foundation = {
	};

foundation.constants = {
	FOUNDATION_LANGUAGES_EN_US: 1,
	FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC: 1,
	FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC: 0,
	FOUNDATION_LANGUAGES_EN_UK: 0,
	FOUNDATION_DEBUG_MODE: 1
};
/**
 * @type {Object} currentPage Represents a variable holder for the current page object
 */
var currentPage;

function init(className, args) {
	if(className) {
		var parts = className.split(".");
		var classToInstantiate = window;
		
		for(var i = 0, iCount=parts.length; i < iCount; i++) {
			if(classToInstantiate[parts[i]]) {
				classToInstantiate = classToInstantiate[parts[i]];
			} else {
				alert("Fatal error - could not load " + (i < (iCount - 1) ? "package" : "class") + " " + parts[i] + (i < (iCount - 1) ? " - undefined in namespace" : " from qualified name " + className));
				return;
			}
		}
		
		currentPage = new classToInstantiate(args);
	}
}

/**
 * Dummy function - the real one is parsed out.
 * 
 * Pass the object that you wish to include, like you would the Java import statement.  Note that you cannot import whole packages.
 */
function include(object) {
	
}

/**
 * @class behaviour.Behaviour
 */
Behaviour = {
	version: 3.0
}
/** Log utility object */
var Log = {
	_logIt: function(message, type, nodate) {
		if(typeof(nodate) == "undefined") {
			var date = new Date();
			message = Log.padNumber(date.getHours()) + ":" + Log.padNumber(date.getMinutes()) + ":" + Log.padNumber(date.getSeconds()) + " - " + message;
		}
		
		if(typeof(window['console']) != "undefined") {
			if(console[type]) { // firebug
				console[type](message);
			} else if(console.log) { // generic console (Firefox, Safari)
				console.log(message);
			}
		}/* else {
			try {
				if(typeof(Log["IEDebugWindow"]) == "undefined") {
					Log.IEDebugWindow = Log.openIEDebugWindow();
					window.blur();
				}
				
				var output = Log.IEDebugWindow.document.getElementById("outputlog");
				
				var messagePara = Log.IEDebugWindow.document.createElement("p");
				messagePara.className = type;
				messagePara.appendChild(Log.IEDebugWindow.document.createTextNode(message));
				
				output.appendChild(messagePara);

			} catch(e) {
				
			}
		}*/
	},
	
	openIEDebugWindow: function() {
		var windowRef = window.top.debugWindow = window.open("", "Debug", "left=0,top=0,width=500,height=400,scrollbars=yes,status=yes,resizable=yes");
		windowRef.opener = self;
		windowRef.document.open();
		windowRef.document.write('<html><head><title>debug window</title><style type="text/css">body {margin: 0;} p {margin: 0; padding: 5px; border-bottom: 1px solid #BEBEBE; font: x-small Arial, Verdana; white-space: nowrap} p.debug {} p.error { color: #F00; background-color: #FFFFE0; } p.info { color: #03F; } p.warn { background-color: #0FF }</style></head><body><div id="outputlog"></div></body></html>');
		
		return windowRef;
	},

	debug: function(message) {
		Log._logIt(message, "debug");
	},

	info: function(message) {
		Log._logIt(message, "info");
	},

	warn: function(message) {
		Log._logIt(message, "warn");
	},

	error: function(message) {
		Log._logIt(message, "error");
	},
	
	dumpObject: function(object) {
		if(Object.isString(object)) {
			Log.info(object);
		} else {
			Log._logIt(object, "dir", true);
		}
	},
	
	/**
	 * Removes lines referencing prototype.js and anonymous closures from stack traces to make the output
	 * a bit more readable.  This of course makes the assumption that prototype.js is perfect.
	 * 
	 * @param	{Exception}	e								An exception object
	 * @param	{boolean}		doNotReplace		Pass true if you don't want the extra lines to be removed
	 */
	dumpException: function(e, doNotReplace) {
		if(typeof(e) == "string") {
			Log.error(e);
			return;
		}
		
		for(var key in e) {
			try {
				if(!doNotReplace && e[key].replace) {
					e[key] = e[key].replace(/^[apply|call](.)*$/gm, "");
					e[key] = e[key].replace(/^(.)*prototype\.js(.)*$/gm, "");
				}
				
				Log.error(key + " = " + e[key]);
			} catch(e) {
				
			}
		}
	},
	
	padNumber: function(number) {
		if(number < 10) {
			number = "0" + number;
		}
	
		return number;
	}
}
/**
 * Provides some utility methods for Javascript vagaries
 * @class BehaviorUtil
 */
BehaviourUtil = {
	/**
	 * @return {Object} returns window size object
	 */
	getWindowSize: function() {
		var screenSize = {};
		
		if(Browser.InternetExplorer === true) {
			screenSize.width = document.documentElement.offsetWidth;
			screenSize.height = document.documentElement.offsetHeight;
		} else {
			screenSize.width = window.innerWidth;
			screenSize.height = window.innerHeight;
		}
		
		return screenSize;
	},
	/**
	 * @return {Object} returns viewport size object
	 */
	getViewportSize: function() {
		var viewPortSize = {};
 		
		 if (typeof window.innerWidth != 'undefined') {
			viewPortSize.width = window.innerWidth,
			viewPortSize.height = window.innerHeight
		} else if (typeof document.documentElement != 'undefined' && typeof document.documentElement.clientWidth != 'undefined' && document.documentElement.clientWidth != 0) {
			viewPortSize.width = document.documentElement.clientWidth;
			viewPortSize.height = document.documentElement.clientHeight;
		} else {
			viewPortSize.width = document.getElementsByTagName('body')[0].clientWidth;
			viewPortSize.height = document.getElementsByTagName('body')[0].clientHeight;
 		}
		
		return viewPortSize;
	},

/**
 * Counts the number of properties an object has
 * 
 * @return	{integer}
 */
	count: function(object) {
		var i = 0;
		
		for(var key in object) {
			i++;
		}
		
		return i;
	},

/**
 * Recursively dumps the name and value of each property contained within the passed object
 * 
 * @param {Object} object
 * @param {string} spaces
 */
	dumpObject: function(object, spaces) {
		if(!spaces) {
			spaces = "";
		}
		
		for(var key in object) {
			if(object[key] instanceof Object) {
				Log.info(spaces + key + " >");
				BehaviourUtil.dumpObject(object[key], spaces + " ");
			} else {
				Log.info(spaces + key + " = " + object[key]);
			}
		}
	},

/**
 * Turns an object into an array - eg. an associative array into a numeric array
 * 
 * @param	{Object}	object
 * @return	{Array}
 */
	objectToArray: function(object) {
		if(object instanceof Array) {
			return object;
		}
		
		var array = [];
		
		for(var key in object) {
			array[array.length] = object[key];
		}
		
		return array;
	},

/**
 * Returns a discrete copy of the passed object
 * 
 * @param	{Object}	object
 * @return	{Object}
 */
	cloneObject: function(object) {
		if(object) {
			var objectClone = new object.constructor();
			
			for(var property in object) {
				if(property != "controller" && property != "currentPage") {
					if(typeof object[property] == 'object') {
						objectClone[property] = BehaviourUtil.cloneObject(object[property]);
					} else {
						objectClone[property] = object[property];
					}
				}
			}
		
		return objectClone;
		}
	},

/**
 * Removes leading and trailing spaces from the passed string
 * 
 * @param	{String}	string
 * @return	{String}
 */
	trim: function(string) {
		return string.replace(/^\s*|\s*$/g,"");
	},

/**
 * Tries to remove focus from the element that triggered the passed event and then return that element.
 * 
 * N.B.  This method occasionally makes FireFox throw an uncatchable exception
 * 
 * @param	{Event}	event
 * @param	{Node}	element
 */
	clearFocus: function(event) {
		if(event) {
			var element = Event.element(event);
			
			if(element) {
				try {
					element.blur();
				} catch(e) {
					Log.warn("Blurred non-focused element " + e);
				}
				
			return element;
			}
		}
	},

/**
 * Serializes an array in a fashion suitable for unserialization within a PHP script
 * 
 * @param	{Array}	passedArray
 * @return	{String}
 */
	serializeForPHP: function(passedArray)	{
		var output = "";
		var index = 0;
		for (var key in passedArray)	{
			index++;
			output += "s:" + String(key).length + ":\"" + String(key) + "\";s:" + String(passedArray[key]).length + ":\"" + String(passedArray[key]) + "\";";
		}
		
		output = "a:" + index + ":{" + output + "}";
		return output;
	},
	/**
	 * @param {string} cookieName
	 */
	readCookie: function(cookieName) {
		cookieName += "=";
		var ca = document.cookie.split(';');
	    
	    for(var i=0;i < ca.length;i++)
	    	{
	        var c = ca[i];
	        // Move past leading whitespace
	        while (c.charAt(0)==' ') c = c.substring(1,c.length);
	        if (c.indexOf(cookieName) == 0) return c.substring(cookieName.length,c.length);
	    	}
	    
	    return null;
	}, 
	
	/**
	 * @return {string} Returns string representaton of a GUID
	 */
	generateGUID:  function() {
	    var g = "";
	    
	    for(var i = 0; i < 32; i++) {
	    	g += Math.floor(Math.random() * 0xF).toString(0xF) + (i == 8 || i == 12 || i == 16 || i == 20 ? "-" : "");
	    }
	    
	    return g;
	},
	/**
	 * @param {string} guid
	 * @return {boolean}
	 */
	isGUID: function(guid) {
		if(!guid) {
			return false;
		}
		
		if(!guid.toLowerCase) {
			return false;
		}
		
		guid = guid.toLowerCase();
		
		if(guid.length != 36) {
			return false;
		}
		
		for(var i = 0; i < 36; i++) {
			if(i == 8 || i == 13 || i == 18 || i == 23) {
				if(guid.charAt(i) != '-') {
					return false;
				}
			} else if(!guid.charAt(i).match(/[0-9|a-f]/i)) {
				return false;
			}
		}
		
		return true;
	},
	/**
	 * @param {string} text
	 * @param {string} attributes
	 * @return {Node}
	 */
	formatText: function(text, attributes) {
		var output = DOMUtil.createElement("p", attributes);
				
		var lines = text.strip().split(/\n/);
		
		var linkRegex = /(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig;
		
		// go through line by line
		for(var i = 0; i < lines.length; i++) {
			var words = lines[i].strip().split(" ");
			
			for(var n = 0; n < words.length; n++) {
				// search for URLy text
				if(words[n].match(linkRegex)) {
					output.appendChild(DOMUtil.createTextElement("a", words[n], {href: words[n], target: "_new"}));
				} else {
					output.appendChild(document.createTextNode(words[n]));
				}
				
				// more words to go, append a space
				if(n < words.length - 1) {
					output.appendChild(document.createTextNode(" "));
				}
			}
			
			// more lines to go, append a line break
			if(i < lines.length - 1) {
				output.appendChild(document.createElement("br"));
			}
		}
		
		return output;
	},
	
	shorten: function(text, maxLength) {
		var output = text.strip();
		
		if(output.length <= maxLength) {
			return output;
		}
		
		var segmentLength = Math.floor((maxLength + 3)/2);
		
		return output.substring(0, segmentLength).strip() + "..." + output.substring(output.length - segmentLength).strip();
	},
	
	getKey: function(entity, property) {
		if(typeof(property) != "undefined" && typeof(entity[property]) != "undefined") {
			if(entity[property] instanceof Function) {
				return entity[property]();
			}
			
			return entity[property];
		}
		
		if(typeof(entity["id"]) != "undefined") {
			return entity["id"];
		}
		
		// have we been given a GUID?
		if(BehaviourUtil.isGUID(entity)) {
			return entity;
		}
		
		// try other default
		if(entity.getId instanceof Function) {
			return entity.getId();
		}
	},
	
	capitalize: function(string) {
		if(string) {
			return string.substring(0, 1).toUpperCase() + string.substring(1);
		}
	},
	
	urlDecode: function(string) {
		var histogram = {};
		var replacer = function(search, replace, str) {
		var tmp_arr = [];
			tmp_arr = str.split(search);
			return tmp_arr.join(replace);
		};
    	
    	// The histogram is identical to the one in urlencode.
		histogram["'"]   = '%27';
		histogram['(']   = '%28';
		histogram[')']   = '%29';
		histogram['*']   = '%2A';
		histogram['~']   = '%7E';
		histogram['!']   = '%21';
		histogram['%20'] = '+';
		
		for (replace in histogram) {
			search = histogram[replace]; // Switch order when decoding
			string = replacer(search, replace, string) // Custom replace. No regexing   
		}
		
		// End with decodeURIComponent, which most resembles PHP's encoding functions
		string = decodeURIComponent(string);
 		return string;
	},
	
	getRoundedDate: function() {
		var date = new Date();
	
		if(date.getMinutes() < 15) {
			date.setMinutes(0, 0);
		} else if(date.getMinutes() < 30) {
			date.setMinutes(15, 0);
		} else if(date.getMinutes() < 45) {
			date.setMinutes(30, 0);
		} else {
			date.setMinutes(45, 0);
		}
		
		return date;
	},
	
	isValidEmail: function(email) {
		email = email.strip();
		
		return email != "" && email.match(/@/);
	},
	
	/**
	 * Will format 1024B into 1KB, 1024KB into 1MB, etc
	 * 
	 * @param {Integer} The number of bytes to format
	 * 
	 * @return {String}
	 */
	formatFileSize: function(bytes) {
		if(bytes < Math.pow(2,10)) {
			return bytes + 'B';
		}else if(bytes >= Math.pow(2,10) && bytes < Math.pow(2,20)) {
			return (Math.round(bytes/Math.pow(2,10))) + 'KB';
		}else if(bytes >= Math.pow(2,20) && bytes < Math.pow(2,30)) {
			return  (Math.round(bytes/Math.pow(2,20))) + 'MB';
		}else if(bytes >= Math.pow(2,30) && bytes < Math.pow(2,40)) {
			return  (Math.round(bytes/Math.pow(2,30))) + 'GB';
		}else if(bytes >= Math.pow(2,40)) {
			return  (Math.round(bytes/Math.pow(2,40))) + 'TB';
		}
	}
}
Cookie = {
	_keys: [
		"expires",
		"domain",
		"path",
		"secure"
	],
	
	set: function(key, value, expires, domain, path, secure) {
		if(!value) {
			// remove old cookie
			if(Cookie.get(key)) {
				Cookie.del(key);
			}
			
			return;
		}
		
		var args = {
			"expires": expires ? expires : new Date(new Date().getTime() + 2629743000),
			"domain": domain,
			"path": path,
			"secure": secure
		};
		
		var cookie = {
			value: value
		};
		
		Cookie._keys.each(function(arg) {
			Cookie._applyArg(cookie, arg, args[arg]);
		});
		
		document.cookie = Cookie._toString(key, cookie);
	},
	
	_applyArg: function(cookie, key, value) {
		if(value) {
			cookie[key] = value;
		}
	},
	
	get: function(cookieName) {
		var cookie = Cookie._getAll()[cookieName];
		
		if(cookie != null) {
			return cookie.value;
		}
		
		return null;
	},
	
	del: function(cookieName) {
		var cookies = Cookies._getAll();
		
		if(cookies[cookieName]) {
			cookies[cookieName].expires = new Date(new Date().getTime() - 1000000);
			document.cookie = Cookie._toString(key, cookie);
		}
	},
	
	_getAll: function() {
		var output = {};
		
		var parts = document.cookie.split("; ");
		var currentName;
		
		for(var i = 0; i < parts.length; i++) {
			var keyPart = parts[i];
			
			if(keyPart && keyPart.strip) {
				
				var keyValue = keyPart.strip().split("=");
				
				if(keyValue[0] == "expires") {
					output[currentName].expires = new Date(keyValue[1]);
				} else if(keyValue[0] == "path") {
					output[currentName].path = keyValue[1];
				} else if(keyValue[0] == "domain") {
					output[currentName].domain = keyValue[1];
				} else if(keyValue[0] == "secure") {
					output[currentName].secure = true;
				} else {
					currentName = keyValue[0];
					output[currentName] = {
						value: keyValue[1]
					};
				}
			}
		}
		
		return output;
	},
	
	_toString: function(cookieName, object) {
		var cookie = [
			cookieName + "=" + escape(object.value)
		];
		
		Cookie._keys.each(function(arg) {
			if(object[arg]) {
				if(arg == "expires") {
					cookie.push(arg + "=" + object[arg].toUTCString());
				} else if(arg == "secure") {
					cookie.push(arg);
				} else {
					cookie.push(arg + "=" + object[arg]);
				}
			}
		});
		
		return cookie.join("; ");
	}
}
/**
 * @class Browser
 * @constructor
 */
Browser = {
	InternetExplorer: false,
	Opera: false,
	Safari: false,
	Mozilla: false,
	Ajax: false,
	DOM: false,
	version: 0,
	
	/** find out which broswer we are running */
	detect: function() {
		
		if(window.opera) {
			Browser.Opera = true;
			
			if(window.XMLHttpRequest) {
				Browser.version = 8;
			} else if(document.getElementById) {
				Browser.version = 7;
			}
		} else if((document.childNodes) && (!document.all) && (!navigator.taintEnabled) && (!navigator.accentColorName)) {
			Browser.Safari = true;
			
			if(window.devicePixelRatio) {
				Browser.version = 3;
			} else {
				Browser.version = 2; // probably
			}
		} else if(document.getElementById && !document.all) {
			Browser.Mozilla = true;
			
			if(navigator.registerProtocolHandler) {
				Browser.version = 3;
			} else if(window.Iterator) {
				Browser.version = 2;
			} else if(Array.every) {
				Browser.version = 1.5;
			} else if(window.getComputedStyle) {
				Browser.version = 1;
			}
		} else if(document.getElementById && document.all) {
			Browser.InternetExplorer = true;
			
			if(document.querySelectorAll) {
				Browser.version = 8;
			} else if(window.XMLHttpRequest) {
				Browser.version = 7;
			} else if(document.compatMode && document.all) {
				Browser.version = 6;
			} else if(window.createPopup) {
				Browser.version = 5.5;
			} else if(window.attachEvent) {
				Browser.version = 5;
			} else if(document.all) {
				Browser.version = 4;
			}
		}
		
		// does it support AJAX
		if(window.XMLHttpRequest) {
			Browser.Ajax = true;
		} else if(window.ActiveXObject) {
			try {
				requestObject=new ActiveXObject("Msxml2.XMLHTTP");
				this.Ajax = true;
			} catch (e) {
				try {
					requestObject=new ActiveXObject("Microsoft.XMLHTTP");
					Browser.Ajax = true;
				} catch (oc) {}
			}
		}
		
		// how about the DOM
		if(document.getElementById && $$("body")[0].appendChild) {
			Browser.DOM = true;
		}
		
		DOMUtil.addClass(document.body, Browser.getBrowserName());
	},
	/** get the browser name */
	getBrowserName: function() {
		if(Browser.InternetExplorer) {
			return "Internet Explorer";
		} else if(Browser.Opera) {
			return "Opera";
		} else if(Browser.Safari) {
			return "Safari";
		} else if(Browser.Mozilla) {
			return "Mozilla";
		}
		
		return "No idea";
	}
}
/**
 * Utility class with static methods for manipluating the DOM  
 * @class DOMUtil
 */
DOMUtil = {
	/** Boots old browsers to the upgrade page  */
	checkDOM: function() {
		if(!Browser.DOM || !Browser.Ajax) {
			window.location = "/requirements/error/browser/";
		}
	},
	
	/**
	 * Removes all children of the passed node
	 * 
	 * @param	{Node}	node
	 * @return void
	 */
	emptyNode: function(node) {
		if(node) {
			if(node.appendTo) {
				node.empty();
			} else {
				while(node.hasChildNodes()) {
					var childNode = node.childNodes[node.childNodes.length-1];
					
					if(childNode.owner) {
						var foo = childNode.owner();
						
						if(foo.triggerEvent) {
							foo.triggerEvent("onBeforeRemoveFromDOM");
						}
					}
					
					node.removeChild(node.childNodes[node.childNodes.length-1]);
					
					if(foo && foo.triggerEvent) {
						foo.triggerEvent("onAfterRemoveFromDOM");
					}
				}
			}
			
			return node;
		}
	},
	
	/**
	 * Removes all children of the passed nodes
	 */
	emptyNodes: function() {
		$A(arguments).each(function(element, index) {
			if(element instanceof Array) {
				this.emptyNodes(element);
			} else {
				this.emptyNode(element);
			}
		}.bind(this));
	},
	
	/**
	 * Creates a node with a textNode as a child
	 * 
	 * @param	{string}		tagName
	 * @param	{string}		text
	 * @param	{Object}		attributes
	 * @return	{Node}
	 */
	createTextElement: function(tagName, text, attributes) {
		var element = this.createElement(tagName, attributes);
		
		if(text instanceof Array) {
			text.each(function(text){
				if(text) {
					this.append(text, element);
				}
			}.bind(this));
		} else {
			this.append(text ? text : "", element);
		}
		
		return element;
	},
	
	/**
	 * Shortcut for creating a DOM node
	 * 
	 * @param	{string}		tagName
	 * @param	{Object}		attributes
	 * @return	{Node}
	 */
	createElement: function(tagName, attributes) {
		var element = $(document.createElement(tagName));
		this.applyAttributesToElement(element, attributes);
		
		return element;
	},
	
	/**
	 * Creates a table row
	 * 
	 * @param	{integer}	numCells
	 * @param	{boolean}	header
	 * @return	{void}
	 */
	createTableRow: function(numCells, header) {
		var row = document.createElement("tr");
		
		for(var i = 0; i < numCells; i++) {
			row.appendChild(document.createElement((header ? "th" : "td")));
		}
		
		return row;
	},
	
	/**
	 * Creates a row of empty table header cells
	 * 
	 * @param	{integer}	numCells
	 * @return	{Node}
	 */
	createTableHeaderRow: function(numCells) {
		return this.createTableRow(numCells, true);
	},
	
	/**
	 * Creates a single line HTML text input
	 * 
	 * @param	{string}		nodeValue
	 * @param	{Object}		options
	 * @return  {Node}
	 */
	createTextInputNode: function(nodeValue, options) {
		var element = this.createElement("input", options);
		element.type = "text";
		element.value = (nodeValue == null ? "" : nodeValue);
				
		return element;
	},
	
	/**
	 * Creates a HTML password input
	 * 
	 * @param	{string}		nodeValue
	 * @param	{Object}		options
	 * @return {Node}
	 */
	createPasswordInputNode: function(nodeValue, options) {
		var element = this.createTextInputNode(nodeValue, options);
		element.type = "password";
		
		return element;
	},
	
	/**
	 * Creates a HTML submit button
	 * 
	 * @param	{string}		nodeValue
	 * @param	{Object}		options
	 * @return {Node}
	 */
	createSubmitInputNode: function(nodeValue, options) {
		var element = this.createTextInputNode(nodeValue, options);
		element.type = "submit";
		element.value = (nodeValue == null ? "" : nodeValue );
		
		return element;
	},
	
	/**
	 * Creates a HTML password input
	 * 
	 * @param	{Node}			element		Node to apply attributes to
	 * @param	{Object}			attributes	Associative array of attributes to apply to the passed node
	 * @return	{void}
	 */
	applyAttributesToElement: function(element, attributes) {
		if(attributes) {
			for(var key in attributes) {
				if(key == "style") {
					for(s_key in attributes[key]) {
						element.style[s_key] = attributes[key][s_key];
					}
				} else {
					element[key] = attributes[key];
				}
			}
		}
	},

	createNullForm: function(attributes) {
		var element = document.createElement("form");
		
		this.applyAttributesToElement(element, attributes);
		
		element.action = ".";
		element.method = "get";
		element.onsubmit = function() {return false};
		
		return element;
	},
	
	/**
	 * Adds a CSS class to the passed node
	 * 
	 * @param	{Node}	node
	 * @param	{string}	newClass
	 * @return	{void}
	 */
	addClass: function(node, newClass) {
		if(node && newClass) {
			if(newClass instanceof Array) {
				for(var i = 0, iCount=newClass.length; i < iCount; i++) {
					this.addClass(node, newClass[i]);
				}
			} else if(node.addClass) {
				node.addClass(newClass);
			} else if(!DOMUtil.hasClass(node, newClass)) {
				Element.addClassName(node, newClass);
			}
		}
	},
	
	/**
	 * Removes a CSS class to the passed node, optionally recursing through it's child nodes
	 * 
	 * @param	{Node}	node
	 * @param	{string}	oldClass
	 * @param	{boolean}	recursive
	 * @return	{void}
	 */
	removeClass: function(node, oldClass, recursive) {
		if(!node) {
			return;
		}
		
		if(oldClass instanceof Array) {
			for(var i = 0; i < oldClass.length; i++) {
				this.removeClass(node, oldClass[i], recursive);
			}
		} else if(recursive) {
			this.recursivelyRemoveClasses(node, oldClass);
		} else {
			Element.removeClassName(node, oldClass);
		}
	},
	
	removeClasses: function(nodes, oldClass) {
		for(var i = 0; i < nodes.length; i++) {
			this.removeClass(nodes[i], oldClass);
		}
	},
	
	recursivelyRemoveClasses: function(node, oldClass) {
		if(node && node.hasChildNodes()) {
			this.removeClass(node, oldClass);
			
			for(var i = 0; i < node.childNodes.length; i++) {
				if(node.childNodes[i].hasChildNodes()) {
					this.recursivelyRemoveClasses(node.childNodes[i], oldClass);
				}
			}
		}
	},
	
	/**
	 * Returns the iFrameDocument object from the passed iFrame in a browser neutral way
	 * 
	 * @param	{Node}	iframe
	 * @return	{Node}
	 */
	getIFrameDocument: function(iframe) {
		var oDoc = false;
		
		if(iframe.contentWindow) {
			Log.info("found iframe.contentWindow");
			oDoc = iframe.contentWindow;
		} else if(iframe.contentDocument) {
			Log.info("found iframe.contentDocument");
			oDoc = iframe.contentDocument;
		}
		
		if(oDoc.document) {
			Log.info("found oDoc.document");
			oDoc = oDoc.document;
		}
		
		return oDoc;
	},
	
	/**
	 * Sets a CSS style on the passed node to the passed value
	 * @param {Node} element
	 * @param {Object} styleToSet
	 * @param {Object} value
	 */
	setStyle: function(element, styleToSet, value) {
		try {
			if(element) {
				if(element.style) {
					element.style[styleToSet] = value;
				} else if(element.appendTo) {
					element.setStyle(styleToSet, value);
				}
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @param {Object} element
	 * @param {Object} styleToGet
	 */
	getStyle: function(element, styleToGet) {
		try {
			if(element && element.style) {
				return element.style[styleToGet];
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @param {Node}
	 * @param {string} className
	 * @return {boolean}
	 */
	hasClass: function(node, className) {
		var hasClass = false;
		
		if(node && node.className) {
			// broken
			//Element.hasClassName(node, className);
			
			var elementClassName = node.className;
			elementClassName = elementClassName.replace(/\s+/g, " ");
			
			elementClassName.split(" ").each(function(nodeClassName) {
				if(className == nodeClassName) {
					hasClass = true;
				}
			});
		}
		
		return hasClass;
	},
	
	/**
	 * @param {Object} headerArray
	 * @param {Object} attributes
	 * @return {Node}
	 */
	createTable: function(headerArray, attributes) {
		if(typeof(attributes) == "undefined") {
			attributes = {};
		}
		
		var table = DOMUtil.createElement("table", attributes);
		
		if(headerArray instanceof Array && headerArray.length > 0) {
			var thead  = DOMUtil.createElement("thead");
			thead.appendChild(DOMUtil._processRow(headerArray, "th"));
			table.appendChild(thead);
		}
		
		return table;
	},
	
	/**
	 * @param {Node} table
	 * @param {Object} rowData
	 */
	addRowToTable: function(table, rowData) {
		var tbody = table.getElementsByTagName("tbody")[0];
		
		if(!tbody) {
			tbody = document.createElement("tbody");
			table.appendChild(tbody);
		}
		
		tbody.appendChild(DOMUtil._processRow(rowData, "td"));
	},
	
	_processRow: function(rowData, cellType) {
		var row = document.createElement("tr");
		
		for(var i = 0; i < rowData.length; i++) {
			var headerCell = document.createElement(cellType);
			
			if(rowData[i]) {
				if(rowData[i].appendTo) {
					rowData[i].appendTo(headerCell);
				} else if(rowData[i].appendChild) {
					headerCell.appendChild(rowData[i]);
				} else {
					headerCell.appendChild(document.createTextNode(rowData[i]));
				}
			} else {
				headerCell.appendChild(document.createTextNode(" "));
			}
			
			row.appendChild(headerCell);
		}
		
		return row;
	},
	
	/**
	 * @param {Array} values
	 * @param {Array} attributes
	 * @return {Node}
	 */
	createDefinitionList: function(values, attributes) {
		var definitions = [];
		
		for(var key in values) {
			definitions.push(DOMUtil.createTextElement("dt", key, attributes[key]));
			definitions.push(DOMUtil.createTextElement("dd", values[key], attributes[key]))
		}
		
		return DOMUtil.createTextElement("dl", definitions);
	},
	
	_findSibling: function(node, type) {
		var sibling = null;
		
		while(true) {
			sibling = node[type + "Sibling"];
			
			if(!sibling) {
				return sibling;
			}
			
			if(sibling.nodeType != 3) {
				return $(sibling);
			}
			
			node = sibling;
		}
	},
	
	getOccupiedDimensions: function(node) {
		if(Object.isFunction(node.getRootNode)) {
			node = node.getRootNode();
		}
		
		node = $(node);
		
		var dims = {
			height: 0,
			width: 0
		};
		
		dims.height = node.getHeight();
		dims.width = node.getWidth();
		
		var nextSibling = DOMUtil._findSibling(node, "next");
		
		// find node siblings - if margins have been set we need to adjust the dimensions
		if(nextSibling) {
			
			// occupied size is affected by margins
			if(node.getStyle("marginBottom")) {
				var nodeMarginBotton = parseInt(node.getStyle("marginBottom"));
				var nextSiblingMarginTop = parseInt(nextSibling.getStyle("marginTop"));
				
				// only add if the next node's marginTop does not trump our marginBottom
				if(nodeMarginBotton > nextSiblingMarginTop) {
					dims.height += nodeMarginBotton;
				}
			}
			
			if(node.getStyle("marginRight")) {
				var nodeMarginRight = parseInt(node.getStyle("marginRight"));
				var nextSiblingMarginLeft = parseInt(nextSibling.getStyle("marginLeft"));
				
				// only add if the next node's marginTop does not trump our marginBottom
				if(nodeMarginRight > nextSiblingMarginLeft) {
					dims.width += nodeMarginRight;
				}
			}
		}
		
		var previousSibling = DOMUtil._findSibling(node, "previous");
		
		if(previousSibling) {
			
			// occupied size is affected by margins
			if(node.getStyle("marginTop")) {
				var nodeMarginTop = parseInt(node.getStyle("marginTop"));
				var previousSiblingMarginBottom = parseInt(previousSibling.getStyle("marginBottom"));
				
				// only add if the next node's marginTop does not trump our marginBottom
				if(nodeMarginTop > previousSiblingMarginBottom) {
					dims.height += nodeMarginTop;
				}
			}
			
			if(node.getStyle("marginLeft")) {
				var nodeMarginLeft = parseInt(node.getStyle("marginLeft"));
				var previousSiblingMarginBottom = parseInt(previousSibling.getStyle("marginRight"));
				
				// only add if the next node's marginTop does not trump our marginBottom
				if(nodeMarginLeft > previousSiblingMarginBottom) {
					dims.width += nodeMarginLeft;
				}
			}
		}
		
		return dims;
	},
	
	/*
	 * Returns the dimensions occupied by an element on screen, including padding
	
	getOccupiedDimensions: function(node) {
		var dims = {height: 0, width: 0};
		
		if(!(node.getStyle instanceof Function)) {
			return dims;
		}
		
		dims.height = parseInt(node.getStyle("height"));
		dims.height = DOMUtil._addStyleCalculation(dims.height, node, "borderTopWidth");
		dims.height = DOMUtil._addStyleCalculation(dims.height, node, "borderBottomWidth");
		dims.height = DOMUtil._addStyleCalculation(dims.height, node, "marginTop");
		dims.height = DOMUtil._minusStyleCalculation(dims.height, node, "marginBottom");
		dims.height = DOMUtil._addStyleCalculation(dims.height, node, "paddingTop");
		dims.height = DOMUtil._addStyleCalculation(dims.height, node, "paddingBottom");
		
		dims.width = parseInt(node.getStyle("width"));
		dims.width = DOMUtil._addStyleCalculation(dims.width, node, "borderLeftWidth");
		dims.width = DOMUtil._addStyleCalculation(dims.width, node, "borderRightWidth");
		dims.width = DOMUtil._minusStyleCalculation(dims.width, node, "marginLeft");
		dims.width = DOMUtil._minusStyleCalculation(dims.width, node, "marginRight");
		dims.width = DOMUtil._addStyleCalculation(dims.width, node, "paddingLeft");
		dims.width = DOMUtil._addStyleCalculation(dims.width, node, "paddingRight");
		
		return dims;
	},
	
	_addStyleCalculation: function(dim, node, style) {
		return DOMUtil._doStyleCalculation(dim, node, style, true);
	},

	_minusStyleCalculation: function(dim, node, style) {
		return DOMUtil._doStyleCalculation(dim, node, style, false);
	},
	
	_doStyleCalculation: function(dim, node, style, add) {
		var value = parseInt(node.getStyle(style));
		
		if(!isNaN(value)) {
			if(add) {
				dim += value;
			} else {
				dim -= value;
			}
		}
		
		return dim;
	}, */
	
	/**
	 * Returns true if the passed node is in the DOM
	 */
	isInDOM: function(node) {
		while(true) {
			if(!node.parentNode) {
				return false;
			} else if(node.parentNode.tagName == "BODY") {
				return true;
			}
			
			node = node.parentNode;
		}
	},
	
	append: function(what, toNode) {
		if(Object.isString(what) || Object.isNumber(what)) {
			// string or number
			toNode.appendChild(document.createTextNode(what));
		} else if(what.appendTo) {
			// GUIWidget
			what.appendTo(toNode);
		} else if(what.appendChild) {
			// Node
			toNode.appendChild(what);
		} else if(Object.isArray(what)) {
			// Array of items
			what.each(function(item) {
				DOMUtil.append(item, toNode);
			});
		}
	},
	
	elementWasClickedOn: function(event, element) {
		var position = Element.positionedOffset(element);
		var dims = Element.getDimensions(element);
		var mouseX = Event.pointerX(event);
		var mouseY = Event.pointerY(event);
		var inBoxHorizontal = mouseX > position.left && mouseX < position.left + dims.width;
		var inBoxVertical = mouseY > position.top && mouseY < position.top + dims.height;
		
		return inBoxHorizontal && inBoxVertical;
	}
}
/**
 * Simple object to keep track of entities that have not had their changes saved.
 * @class EditWatcher
 */
EditWatcher = {
	_editors: {},
	
	/**
	 * Call this method when the current entity being edited has had properties changed.
	 * 
	 * @param	{mixed}		editor			Some sort of entitiy - will have a property set named __editorGUID.  If a function is passed, it will be invoked in the changesOutstanding method - if it returns true it will be assumed that no changes have been made
	 * @param	{string}		message		The message that will be popped up if changes are not saved.  Optional.
	 */
	registerEditor: function(editor, func, message) {
		if(arguments.length != 3) {
			throw "Need more arguments for EditWatcher";
		}
		
		if(editor.__editorGUID) {
			EditWatcher.deRegisterEditor(editor.__editorGUID);
		}
		
		editor.__editorGUID = BehaviourUtil.generateGUID();
		
		EditWatcher._editors[editor.__editorGUID] = {
			func: func,
			message: message ? message: false
		};
	},
	
	/**
	 * Call this method once the changes to the current method have been either saved or cancelled.
	 */
	deRegisterEditor: function(editor) {
		if(editor.__editorGUID) {
			delete EditWatcher._editors[editor.__editorGUID];
			delete editor.__editorGUID;
		}
	},
	
	/**
	 * Checks if a given editor has outstanding changes.  Returns true if no changes are outstanding and it is ok to proceed.  If an editor is supplied and changes are outstanding, 
	 * will pop up a confirm dialog asking if the user wishes to abandon changes.  If no editor is supplied will check to see if any changes are outstanding, if there are it will pop up
	 * a generic message about unsaved changes.
	 * 
	 * If the user explicitly abandons changes, all editors are deregistered.
	 * 
	 * @param	{Object}		[editor]		Optional.
	 * @param	{String}		[overrideMessage]	Optional - if supplied will be presented to the user instead of the message passed to registerEditor
	 * 
	 * @return {boolean}	true if changes have yet to be saved, false otherwise
	 */
	changesOutstanding: function(editor, message) {
		var func;
		
		if(editor && editor.__editorGUID && EditWatcher._editors[editor.__editorGUID]) {
			func = EditWatcher._editors[editor.__editorGUID]["func"];
			
			if(!message && EditWatcher._editors[editor.__editorGUID]["message"]) {
				message = EditWatcher._editors[editor.__editorGUID]["message"];
			}
		} else {
			for(var key in EditWatcher._editors) {
				if(EditWatcher._editors[key]) {
					func = EditWatcher._editors[key]["func"];
					
					if(!message && EditWatcher._editors[key]["message"]) {
						message = EditWatcher._editors[key]["message"];
					}
					
					break;
				}
			}
		}
		
		if(!func) {
			//Log.warn("EditWatcher callback function not found");
			return;
		}
		
		// test to see if changes have occured
		if(!func()) {
			return false;
		}
		
		return !confirm(message ? message : Language.get("bbq.web.EditWatcher.unsavedchanges"));
	},
	
	/**
	 * Blanks the local store of editors with outstanding changes.  
	 * Does not remove __editorGUID field on editor objects although could do in the future by some cunning use of event notifications.
	 */
	deRegisterAllEditors: function() {
		EditWatcher._editors = {};
	},
	
	_warnUser: function(event) {
		for(var key in EditWatcher._editors) {
			if(EditWatcher._editors[key]) {
				return EditWatcher._editors[key] === true ? Language.get("bbq.web.EditWatcher.unsavedchanges") : EditWatcher._editors[key].message;
			}
		}
	}
}

window.onbeforeunload = EditWatcher._warnUser;
/**
 * @class behaviour.gui.Theme 
 */
Theme = {
	_styleSheets: {},
	_styleSheetNodes: [],
	_theme: "",
	
	addStyleSheet: function(sheet, media) {
		if(typeof(Theme._styleSheets[sheet]) == "undefined") {
			sheet = sheet.replace(/\./g, "/");
			
			if(!Theme._styleSheets[sheet]) {
				Theme._styleSheets[sheet] = sheet;
				Theme._styleSheetNodes.push(Theme._addSheetToHead(sheet, media));
			}
		}
	},
	
	setTheme: function(theme) {
		Theme._theme = theme;
		Theme._updateStyleSheets;
	},
	
	_updateStyleSheets: function() {
		var head = document.getElementsByTagName("head")[0];
		
		Theme._styleSheetNodes.each(function(node) {
			head.removeChild(node);
		});
		
		Theme._styleSheets.each(function(sheet) {
			Theme._addSheetToHead(sheet);
		});
	},
	
	_addSheetToHead: function(sheet, m) {
		if (m == "undefined") {
			m = "all";
		}
		Log.info("media: " + m);
		var node = DOMUtil.createElement("link", {
			media: m,
			type: "text/css",
			rel: "stylesheet",
			href: "/css/theme" + Theme._theme + "/" + sheet + "/style.css"
		});
		
		var head = document.getElementsByTagName("head")[0];
		head.insertBefore(node, head.getElementsByTagName("script")[0]);
		
		return node;
	}
};
/**
 * @class FocusWatcher
 */
FocusWatcher = {
	/**
	 * The behaviour.gui.GUIWidget object that thinks it currently has focus
	 * 
	 * @private
	 */
	_focusedElement: null,
	
	/**
	 * Watches the current page for keypress events and passes them on to the GUIWidget that currently has focus
	 */
	_keypress: function(event) {
		FocusWatcher._call("processKeypress", event);
	},
	
	/**
	 * Called when the window loses focus.
	 * 
	 * @private
	 */
	_pageBlurred: function(event) {
		FocusWatcher._call("loseFocus");
	},
	
	/**
	 * Called when the window gains focus.
	 * 
	 * @private
	 */
	_pageFocused: function(event) {
		FocusWatcher._call("acceptFocus");
	},
	
	/**
	 * Called manually to route observed keypress events to the passed callback function.  The passed argument should
	 * implement three methods:
	 * 
	 * loseFocus()
	 * acceptFocus()
	 * processKeypress(Event)
	 * 
	 * @param	{Object}		obj
	 */
	setKeypressCallbackObject: function(obj) {
		FocusWatcher._call("loseFocus");
		FocusWatcher._focusedElement = obj;
		FocusWatcher._call("acceptFocus");
	},
	
	/**
	 * Returns the currently focused element
	 */
	getKeypressCallbackObject: function(guiWidget) {
		return FocusWatcher._focusedElement;
	},
	
	_call: function(func, event) {
		if(FocusWatcher._focusedElement && FocusWatcher._focusedElement[func]) {
			if(typeof(event) != "undefined") {
				FocusWatcher._focusedElement[func](event);	
			} else {
				FocusWatcher._focusedElement[func]();
			}
		}
	}
}

// start observing the document for keypresses
Event.observe(document, "keypress", FocusWatcher._keypress.bindAsEventListener(this));
Event.observe(window, "blur", FocusWatcher._pageBlurred.bindAsEventListener(this));
Event.observe(window, "focus", FocusWatcher._pageFocused.bindAsEventListener(this));
/**
 * Provides a safe way to call Javascript functions that may not exist from within a Flash movie.
 * @class FlashBridge 
 */
FlashBridge = {
	_registeredFunctions: {},
	
	/**
	 * Pass in a function and pass the returned key somewhere.
	 * 
	 * <code>
	 * 
	 * // in JavaScript
	 * var myFunc = function(foo) {alert foo};
	 * var funcKey = FlashBridge.registerFunction(myFunc);
	 * 
	 * myFlashObject.callFlashFunction("callMe", funcKey);
	 * 
	 * // in ActionScript
	 * ExternalInterface.addCallback("callMe", this, callMe);
	 * function callMe(String key):Void {
	 * 		ExternalInterface.addCallback("FlashBridge.callRegisteredFunction", key, "Hello world");
	 * }
	 * 
	 * // Alerts "Hello world"
	 * 
	 * </code>
	 * 
	 * @param {Function} A bound function
	 * @return String
	 */
	registerFunction: function(func) {
		var guid = BehaviourUtil.generateGUID();
		
		FlashBridge._registeredFunctions[guid] = func;
		
		return guid;
	},
	
	/**
	 * See FlashBridge#registerFunction
	 * 
	 * @param {String} key The key
	 */
	callRegisteredFunction: function(key) {
		if(typeof(FlashBridge._registeredFunctions[key]) == "function") {
			// passed a list of arguments
			if(arguments.length > 1) {
				args = $A(arguments);
				args.shift();
				
				return FlashBridge._registeredFunctions[key].apply(this, args);
			}
			
			return FlashBridge._registeredFunctions[key].call(this);
		}
		
		Log.warn("FlashBridge: Key \"" + key + "\" passed to callRegisteredFunction did not resolve to a valid function");
	},
	
	/**
	 * @param {string} functionName
	 * @param {Arrays} functionArgs
	 */
	callFunction: function(functionName, functionArgs) {
		var functionToCall = this.getFunction(functionName, window);
		
		if(typeof(functionToCall) != "undefined") {
			if(functionToCall instanceof Function) {
				if(functionArgs) {
					return functionToCall.apply(this, functionArgs);
				}
				
				return functionToCall();//.apply(functionToCall, functionArgs);
			} else {
				Log.warn("Attempt by flash to call function that is not a function - " + functionName);
			}
		} else {
			Log.warn("Attempt by flash to call non-existent function - " + functionName);
		}
	},
	
	callFunctionOnEmbed: function(withName, functionName, functionArgs) {
		if(!behaviour.web.FlashEmbed.instances[withName]) {
			Log.warn("Attempt by flash to call function on instance that does not exist");
			return;
		}
		
		if(!(behaviour.web.FlashEmbed.instances[withName][functionName] instanceof Function)) {
			Log.warn("Attempt by flash to call function on instance that is not a function");
			return;
		}
		
		if(functionArgs) {
			return behaviour.web.FlashEmbed.instances[withName][functionName].apply(behaviour.web.FlashEmbed.instances[withName], functionArgs);
		}
		
		return behaviour.web.FlashEmbed.instances[withName][functionName].call(behaviour.web.FlashEmbed.instances[withName]);
	},
	
	/**
	 * @param {string} functionName
	 * @param {Object} searchObject
	 */
	getFunction: function(functionName, searchObject) {
		if(functionName.search(/\./) != -1) {
			functionName = functionName.split(".");
			
			for(var i = 0; i < functionName.length; i++) {
				searchObject = searchObject[functionName[i]];
			}
			
			return searchObject;
		} else {
			return searchObject[functionName];
		}
	},
	
	getVariable: function(varName) {
		var value = window;
		
		varName.split(".").each(function(part) {
			value = value[part];
		});
		
		return value;
	}
}
/**
 * @class Language
 */
Language = {
	options: {},
	_language: {},
	_languageLoaded: false,
	
	/**
	 * @param {mixed} options
	 * @example
	 * options {
	 * 		section: string
	 * 		postLoad: function
	 * }
	 */
	load: function(options) {
		Language.options = options ? options : {};
		
		new behaviour.ajax.JSONRequest({
			url: "/backend/getLanguage", 
			onSuccess: Language._gotLanguage.bind(Language), 
			args: (options && options.section ? {section: options.section} : null)});
	},
	
	/**
	 * @private
	 */
	_gotLanguage: function(serverResponse, language) {
		Language._language = language;
		Language._languageLoaded = true;
		
		if(Language.options.postLoad instanceof Function) {
			Language.options.postLoad.call(Language);
		}
	},
	
	/*get: function() {
		if(Language._language) {
			var position = Language._language;
			
			for(var i = 0; i < arguments.length; i++) {
				if(!position) {
					break;
				}
				
				if(typeof(position[arguments[i]]) == "string") {
					return position[arguments[i]];
				}
				
				position = position[arguments[i]];
			}
		}
	
		var languageKey = "";
		
		$A(arguments).each(function(key) {
			languageKey += "['" + key + "']";
		});
		
		Log.error("Could not find language key " + languageKey);
		
		return "unknown";
	},*/
	get: function(string) {
		if(Language._language && Language._language[string]) {
			return Language._language[string];
		}
		
		Log.error("Could not find language key " + string);
		
		return "unknown";
	},

	/**
	 * Returns an array
	 * 
	 * @param	{int}		expected
	 * @param	{String}	key
	 * @param	{String}	key
	 * @return	{Array}
	 */
	getArray: function() {
		 var output = new Array();
	
		if(Language._language) {
			var expected = arguments[0];
			var args = new Array();
			
			for(var i = 1; i < arguments.length; i++) {
				args[args.length] = arguments[i];
			}
			
			var key = args.last();
			
			for(var i = 0; i < expected; i++) {
				args[args.length - 1] = key + i;
				output[i] = Language.get.apply(Language, args);
			}
		}
		
		return output;
	},
	
	/**
	 * Allows for lanugage formatting so that variable value placement in strings is not dependant on the flow of the English language.
	 * 
	 * In the PHP language file, declare this sort of thing:
	 * 
	 * $langugage['generic']['mystring'] = 'This string has {marker} marker';
	 * 
	 * Then in the javascript, call:
	 * 
	 * Language.getFormatted(["generic", "mystring"], {marker: "a nice little"});
	 * 
	 * And the following will be output:
	 * 
	 * "This string has a nice little marker"
	 * 
	 * @param {Array} language
	 * @param {Object} keys
	 */
	getFormatted: function(language, keys) {
		var string = Language.get.apply(Language, language);
		
		try {
			for(var key in keys) {
				string = string.replace(new RegExp("\{" + key + "\}", "gi"), keys[key]);
			}
		} catch(e) {
			Log.dumpException(e);
		}
		
		return string;
	},
	
	isLoaded: function() {
		return Language._languageLoaded ? true : false;
	}
}
/**
 * DateFormatter represents the date format
  */
DateFormatter = {
	_dateFormatter: null,
	
	/**
	 * @param {mixed} dateFormatter
	 */
	setDateFormatter: function(dateFormatter) {
		this._dateFormatter = dateFormatter;
	},
	
	/**
	 *@param {mixed} options
	 *@example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		date: Date						// the date to display
	 * 		withStrings: boolean	// whether to display "Today", etc
	 * 		shortDate: boolean		// if true, hours and minutes will be omitted
	 * }
	 */
	getFormattedDate: function(options) {
		if(typeof(options) == "undefined") {
			options = {};
		}
		
		options.date = DateFormatter._normaliseDate(options.date);
		
		if(options["shortDate"]) {
			return this._dateFormatter.getShortDate(options);
		}
		
		return this._dateFormatter.getLongDate(options);
	},
	
	getOrder: function(options) {
	 	if(typeof(options) == "undefined") {
			options = {};
		}
	 	
	 	return this._dateFormatter.getOrder(options);
	},
	
	getDateSeparator: function() {
	 	return this._dateFormatter.getDateSeparator();
	},
	
	getTimeSeparator: function() {
	 	return this._dateFormatter.getTimeSeparator();
	},
	
	/**
	 * Pass in a Date object, a timestamp (ie. an integer) or nothing at all and get a Date object back.  If nothing is passed the current date is returned.
	 * 
	 * @param {mixed}
	 * @return {Date} 
	 */
	_normaliseDate: function(date) {
		if(!date) {
			return new Date();
		}
		
		return date instanceof Date ? date : new Date(date);
	}
}

/**
 * @class behaviour.page.Page
 */
behaviour.page.Page = new Class.create({
	loadingData: false,
	dataLoaded: false,
	firstDataCall: true,
	dataCallMethod: null,
	dataCallArgs: [],
	dataCallMethodCalled: false,
	waitForDataLoadInterval: null,
	modalLayer: null,
	modalLayerContents: null,
	_fatalError: null,
	
	/**
	 * Todo an example
	 * @param {mixed} args
	 * 
	 */
	initialize: function(args) {
		//Log.info("Page constructor");
		currentPage = this;
		Browser.detect();
		DOMUtil.checkDOM();
		
		Event.observe(window, "resize", this.resizePanels.bindAsEventListener(this));
		
		this.createLayoutManager();
	},
	
	/**
	 * Creates an object to handle adjusting the page layout when it's resized
	 * 
	 * Concrete subclasses should override this method
	 */
	createLayoutManager: function() {
		//Log.warn("Default createLayoutManager() called");
	},
	
	/**
	 * This method allows the bookmarking of pages.
	 * 
	 * When it is first invoked, it checks to see if the page's data set has been loaded.  If it has then it calls the passed function with the passed
	 * arguments.  If it has not loaded then it stores the function and arguments and sets a timeout to check the state of the data again.
	 * 
	 * N.B.  It's up to children of this class to set the dataLoaded member variable as they see fit.
	 * 
	 * @param	{Function}	methodToCall	The method to call when the data has loaded
	 * @param	{Array}	args	Arguments to pass to the methodToCall function
	 */
	checkDataLoaded: function(methodToCall, args) {
		if(!this.dataLoaded) { // initial data set has not loaded
			//Log.info("Data not loaded");
			
			if(this.firstDataCall) { // this is the first time this method has been called
				//Log.info("Storing method to call later");
				
				// store the calling method and it's arguments for later
				this.dataCallMethod = methodToCall;
				this.dataCallArgs = args;
				this.dataCallMethodCalled = false;
				
				/*  make sure we don't overwrite the data set above - this is due to an undocumented feature in 
				 *   FireFox where any set(timeout|interval) call back has an extra argument of how many msecs out
				 *   the call is.
				 */
				this.firstDataCall = false;
			}
			
			//Log.info("Setting timeout to wait for data to load");
			setTimeout(this.checkDataLoaded.bind(this), 500);
		} else if(methodToCall instanceof Function) {
			//Log.info("Data loaded, calling passed method");
			methodToCall.apply(this, args);
			
			this.firstDataCall = true;
		} else { // initial data set has loaded
			//Log.info("Data loaded, calling stored method");
			this.dataCallMethod.apply(this, this.dataCallArgs);
			this.firstDataCall = true;
		}
	},
	
	get: function(objectArray, key, expectedValue) {
		if(objectArray instanceof Array) {
			for(var i = objectArray.length-1; i >=0 ; i--) {
				var object = objectArray[i];
				
				if(object[key] == expectedValue) {
					return object;
				}
			}
		} else if(objectArray instanceof Object) {
			for(object in objectArray) {
				if(objectArray[object][key] == expectedValue) {
					return objectArray[object];
				}
			}
		} else {
			Log.warn("Invalid objectArray handed to Page.get");
		}
	},
	
	/**
	 * Bounces the user to a different page
	 */
	boot: function() {
		document.location = "/";
	},
	
	/**
	 * Redraws the areas on the page in response to a resize or other stimulus
	 */
	resizePanels: function() {
		if(typeof(LayoutManager) != "undefined" && LayoutManager.resizePanels) {
			LayoutManager.resizePanels();
		}
	},
	
	/**
	 * Default method, called when the url has no arguments after it
	 */
	showLanding: function() {
		
	},
	
	/**
	 * Should be overridden.
	 */
	renderTreeList: function() {
		
	},
	
	/**
	 * In order to avoid passing multiple copies of objects via AJAX, the list of objects is sent once and then all subsequent references to those objects are passed as 
	 * arrays of numeric IDs refering to a field of the desired object (usually called "id").
	 * 
	 * This method calls behaviour.page.Page.processItem repeatedly to replace the numeric reference to the object with an actual "passed by reference" style reference.
	 * @param {mixed} items
	 * @param {string} toReplace
	 * @param {number} replaceWith
	 */
	processItems: function(items, toReplace, replaceWith) {
		if(items instanceof Array) {
			for(var i = items.length-1; i>=0; i--) {
				items[i] = this.processItem(items[i], toReplace, replaceWith);
			}
		} else {
			items = this.processItem(items, toReplace, replaceWith);
		}
		
		return items;
	},
	
	/**
	 * Links fields to objects in one parent element
	 * @param {Object} item
	 * @param {string} toReplace
	 * @param {number} replaceWith
	 */
	processItem: function(item, toReplace, replaceWith) {
		for(var n = toReplace.length-1; n >=0 ; n--) {
			if(!(item[toReplace[n]] instanceof Array)) {
				item[toReplace[n]] = this[replaceWith[n]].getElement(item[toReplace[n]]);
				continue;
			}
			
			for(var k = 0; k < item[toReplace[n]].length; k++) {
				var entity = this[replaceWith[n]].getElement(item[toReplace[n]][k]);
			
				if(entity) {
					item[toReplace[n]][k] = entity;
				}
			}
		}
		
		return item;
	},
	
	/**
	 * Greys out the page and shows the passed element in the middle.  The passed element should
	 * extend behaviour.gui.GUIWidget
	 * 
	 * @param	{behaviour.gui.GUIWidget}	guiWidget
	 */
	addModalLayer: function(guiWidget) {
		try {
			if(!this.modalLayer) {
				this.modalLayer = DOMUtil.createElement("div", {className: "modalLayer", style: {display: "none"}});
				document.body.appendChild(this.modalLayer);
			}
			
			this.modalLayerContents = guiWidget;
			this.modalLayerContents.setStyle("display", "none");
			this.modalLayerContents.appendTo(document.body);
			
			if(Browser.Mozilla && Browser.version < 3) { // stop scroll bars from showing through modal layer
				$$(".ScrollableHolder").each(function(element){
					element.style.overflow = "hidden";
				});
				
				$$(".FloatingWindow .ScrollableHolder").each(function(element){
					element.style.overflow = "auto";
				});
			}
			
			Effect.Appear(this.modalLayer, {
				duration: 0.25,
				to: 0.8
			});
			
			Effect.Appear(this.modalLayerContents.getRootNode(), {
				duration: 0.25,
				to: 1
			});
			
			if(this.modalLayerContents.appear && this.modalLayerContents.disappear) {
				// behaviour.gui.FloatingWindow
				this.modalLayerContents.appear();
				this.modalLayerContents.registerOneTimeListener("onDisppear", this.clearModalLayer.bind(this));
			}
			
			return guiWidget;
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Fades out the layers added by com.proxim.page.Page.addModalLayer
	 */
	clearModalLayer: function() {
		if(this._fatalError) {
			return;
		}
		
		if(this.modalLayer) {
			Effect.Fade(this.modalLayer, {
				duration: 0.25
			});
		}
		
		if(this.modalLayerContents) {
			Effect.Fade(this.modalLayerContents.getRootNode(), {
				duration: 0.25
			});
		}
		
		if(Browser.Mozilla && Browser.version < 3) {// re-enable scroll bars
			$$(".ScrollableHolder").each(function(element){
				element.style.overflow = "auto";
			});
		}
		
		setTimeout(this._removeModalLayer.bind(this), 600);
	},
	
	/**
	 * Removes the layers added by com.proxim.page.Page.addModalLayer from the document tree
	 */
	_removeModalLayer: function() {
		if(this._fatalError) {
			return;
		}
		
		if(!this.modalLayer || this.modalLayer.parentNode != document.body) {
			return;
		}
		
		if(!this.modalLayerContents || !this.modalLayerContents.rootNode || this.modalLayerContents.rootNode.parentNode != document.body) {
			return;
		}
		
		try {
			document.body.removeChild(this.modalLayer);
			document.body.removeChild(this.modalLayerContents.rootNode);
		} catch(e) {
			Log.warn("Exception thrown while removing modal layer - " + e);
		}
		
		this.modalLayer = null;
		this.modalLayerContents = null;
	}
});

/**
 * @class behaviour.lang.Watchable 
 */
behaviour.lang.Watchable = new Class.create({
	/**
	 * Storage for callbacks registered on this object
	 */
	_callbacks: null,
	
	/**
	 * Constructor
	 */
	initialize: function() {
		this._callbacks = {};
	},
	
	/**
	 * Returns a callback array, initialising it where necessary
	 * 
	 * @private
	 */
	_getCallbacks: function(type) {
		if(Object.isUndefined(this._callbacks[type])) {
			this._callbacks[type] = new Hash();
		}
		
		return this._callbacks[type];
	},
	
	/**
	 * Example: this._dropDown.registerListener("onchange", this._subTypeChanged.bind(this, predicateType));
	 * 
	 * @param {String} type
	 * @param {Function} callback
	 */
	registerListener: function(type, callback) {
		var callbackKey = BehaviourUtil.generateGUID();
		this._getCallbacks(type).set(callbackKey, callback);
		
		return callbackKey;
	},
	
	/**
	 * Similar to Watchable.registerListener except the callback will only be called once
	 * 
	 * Example: this._dropDown.registerOneTimeListener("onchange", this._subTypeChanged.bind(this, predicateType));
	 * 
	 * @param {String} type
	 * @param {Function} callback
	 */
	registerOneTimeListener: function(type, callback) {
		callback.__oneTime = true;
		
		return this.registerListener(type, callback);
	},
	
	/**
	 * @param {String} type
	 * @param {Function} callback
	 */
	deRegisterListener: function(type, callbackKey) {
		if(callbackKey) {
			return this._getCallbacks(type).unset(callbackKey) ? true : false;
		}
		
		return false;
	},
	
	/**
	 * Notifies this object's listeners of an event.
	 * 
	 * <code>
	 * watchable.registerListener("myEvent", function() {
	 * 		alert("hello");
	 * });
	 * 
	 * watchable.notifyListeners("myEvent");
	 * // alerts "hello"
	 * </code>
	 * 
	 * By default the watchable is passed as the first argument to the callback function.  If you wish to pass extra arguments, do the following:
	 * 
	 * <code>
	 * watchable.registerListener("myEvent", function(theWatchable, someArg) {
	 * 		alert(someArg);
	 * });
	 * 
	 * watchable.notifyListeners("myEvent", "bob");
	 * // alerts "bob"
	 * </code>
	 * 
	 * @param {String} type
	 */
	notifyListeners: function() {
		var args = [this];
		var type = "";
		
		for(var i = 0; i < arguments.length; i++) {
			if(i == 0) {
				type = arguments[i];
			} else {
				args.push(arguments[i]);
			}
		}
		
		this._getCallbacks(type).keys().each(function(key) {
			this.notifyListener(type, key, args);
		}.bind(this));
		
		// notify global listeners
		behaviour.lang.Watchable.notifyGlobalListeners.apply(this, arguments);
	},
	
	/**
	 * Calls the passed callback and deregisters it if it's a one time listener.
	 * 
	 * @param {String} type				The event type
	 * @param {String} key					The callback key
	 */
	notifyListener: function(type, key, args) {
		var callback = this._getCallbacks(type).get(key);
		
		if(!callback) {
			return;
		}
		
		try {
			callback.apply(this, args);
		} catch(e) {
			Log.dumpException(e);
		}
		
		if(callback.__oneTime) {
			this.deRegisterListener(type, key);
		}
	},
	
	/**
	 * Example: this.triggerEvent("onchange");
	 * @param {String} type
	 */
	triggerEvent: function(type) {
		if(typeof(this._callbacks[type]) != "undefined") {
			this.notifyListeners(type);
		}
	}
});

/**
 * Storage for global callbacks
 */
behaviour.lang.Watchable._globalCallbacks = {};

behaviour.lang.Watchable._getGlobalCallbacks = function(type) {
	if(!Object.isArray(behaviour.lang.Watchable._globalCallbacks[type])) {
		behaviour.lang.Watchable._globalCallbacks[type] = [];
	}
	
	return behaviour.lang.Watchable._globalCallbacks[type];
}

/**
 * Allows us to register for any type of callback called on any object
 */
behaviour.lang.Watchable.registerGlobalListener = function(type, callback) {
	behaviour.lang.Watchable._getGlobalCallbacks(type).push(callback);
};

/**
 * Notifies global listeners.
 */
behaviour.lang.Watchable.notifyGlobalListeners = function() {
	var args = [this];
	var type = "";
	
	for(var i = 0; i < arguments.length; i++) {
		if(i == 0) {
			type = arguments[i];
		} else {
			args.push(arguments[i]);
		}
	}
	
	var callbacks = behaviour.lang.Watchable._getGlobalCallbacks(type);
	
	for(var i = 0; i < callbacks.length; i++) {
		try {
			callbacks[i].apply(this, args);
		} catch(e) {
			Log.dumpException(e);
		}
	}
};

/**
 * @class behaviour.lang.Delegator 
 */
behaviour.lang.Delegator = new Class.create(behaviour.lang.Watchable, {
	options: null,
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super();
		
		this.options = options ? options : {};
	},
	
	/**
	 * Example:
	 * 
	 * <code>
	 * if(this.willDelegateMethod("foo")) {
	 * 		return this.delegateMethod("foo");
	 * } else {
	 * 		// default action
	 * }
	 * </code>
	 * 
	 * @param {String} type
	 */
	delegateMethod: function(methodName, args) {
		if(this.willDelegateMethod(methodName)) {
			if(typeof(args) == "undefined") {
				args = [];
			}
			
			args.unshift(this);
			
			return this.options.delegate[methodName].apply(this, args);
		}
	},
	
	willDelegateMethod: function(methodName) {
		return this.options.delegate && this.options.delegate[methodName] instanceof Function;
	}
});

/**
 * This class is used as a base for all objects that have GUI representations.
 * 
 * The rootNode property is a DOM node that is attached to the DOM tree after the object is 
 * created via the appendTo method.
 * @class behaviour.gui.GUIWidget
 * @extends behaviour.lang.Watchable
 */
behaviour.gui.GUIWidget = new Class.create(behaviour.lang.Delegator, {
	rootNode: null,
	parentNode: null,
	childWidgets: null,
	
	/**
	 * This method should always be called explicitly by child classes.
	 * 
	 * Child classes should use the constructor to populate the rootNode variable and then call this.registerObject()
	 * @param	Object	An options object
	 * @example
	 * Supports the following options:
	 * 
	 * options {
	 * 		attributes: Object				// associative array of attributes to apply to the root node when it is set via setRootNode
	 * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.childWidgets = [];
	},
	
	/**
	 * This method should be overridden by child classes and called explicitly by the overriding method if they make use of the 
	 * childWidgets array, which they should, haha.
	 * 
	 * The idea of the method is to create a DOM node tree representation of the widget.  The root node of the tree should be 
	 * this.rootNode.  The presence of any other nodes in the DOM tree should not be relied upon.
	 * 
	 * This method will be called before the node tree is added to the main document tree (in a similar way to off-screen buffering
	 * in graphics programming) and may be called at seeming arbitrary times.  Consequently it should always create a 
	 * representation of the widget/object in it's current state but at the same time, not rely on any other portion of the DOM tree 
	 * existing.
	 */
	render: function() {
		this.childWidgets.each(function(widget) {
			if(widget.render) {
				widget.render();
			}
		});
	},
	
	/**
	 * Sets the root node and registers this object for retrieval from the root node.
	 * 
	 * This object can then be retrieved by calling owner() on the dom node passed as the argument to this method.
	 * 
	 * @param	{Node}	rootNode
	 * @example
	 * So, for example:
	 * 
	 * <code>
	 * proxim.gui.TextField = new Class.create();
	 * 
	 * Object.extend(proxim.gui.TextField.prototype, behaviour.gui.GUIWidget.prototype);
	 * 
	 * proxim.gui.TextField.prototype.initialize: function(controller, htmlID)
	 *   {
	 *   var parentMethod = initialize;
	 *   parentMethod.apply(this, arguments);
	 *   this.setRootNode(document.createElement("input"));
	 *   this.setID(htmlID);
	 *   }
	 * 
	 * ...
	 * 
	 * var foo = proxim.gui.TextField(this.controller, "exampleObject");
	 * foo.appendTo(document.getElementsByTagName("body")[0]);
	 * 
	 * ...
	 * 
	 * var bar = document.getElementById("exampleObject");
	 * var foo = bar.owner();
	 * </code>
	 * 
	 */
	setRootNode: function(rootNode) {
		if(this.rootNode) {
			var oldNode = this.rootNode;
		}
		
		if(Object.isString(rootNode)) {
			this.rootNode = document.createElement(rootNode);
		} else {
			this.rootNode = rootNode;
		}
		
		if(oldNode && oldNode.className) {
			this.addClass(oldNode.className.split(" "));
		}
		
		if(this.options && this.options.attributes) {
			var attr = this.options.attributes;
			for(var key in attr) {
				this.setAttribute(key, attr[key]);
			}
		}
		
		this.rootNode = $(this.rootNode);
		this.registerObject();
	},
	
	getRootNode: function() {
		return this.rootNode;
	},
	
	/**
	 * Sets a reference to this object on the rootNode DOM node.  This allows us to take a DOM node from the document tree and 
	 * get the GUIWidget object of which it is the root node.
	 * 
	 * See setRootNode() for more information
	 */
	registerObject: function() {
		if(this.rootNode) {
			this.rootNode.owner = function() {
				return this;
			}.bind(this);
		}
	},
	
	/**
	 * Removes all nodes attached to this GUIWidgets rootNode
	 */
	empty: function() {
		if(this.rootNode) {
			DOMUtil.emptyNode(this.rootNode);
		}
	},
	
	/**
	 * Adds a class to the root node
	 *
	  * @param	{String}	className	The name of the class to add
	 */
	addClass: function(className) {
		DOMUtil.addClass(this.rootNode, className);
	},
	
	/**
	 * Removes a class from the root node
	 * 
	 * @param	{String}	className	The name of the class to remove
	 */
	removeClass: function(className, recursively) {
		DOMUtil.removeClass(this.rootNode, className, recursively);
	},
	
	/**
	 * Attaches the root node to the passed node
	 * 
	 * @param	{Node}	pageNode	The node to attach the root node to
	 */
	appendTo: function(pageNode) {
		try {
			if(pageNode) {
				pageNode = this._getNode(pageNode);
				pageNode.appendChild(this.getRootNode());
				this.parentNode = pageNode;
			}
			
			this.render();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Adds a node or GUIWidget to the root node of this element
	 * 
	 * @param	{Mixed}	childNode	A Node, GUIWidget or array of Node and/or GUIWidget objects
	 */
	appendChild: function(childNode) {
		if(!childNode) {
			return;
		}
		
		if(childNode instanceof Array) {
			childNode.each(function(node) {
				this.appendChild(node);
			}.bind(this));
		} else {
			if(childNode && this.rootNode) {
				if(childNode.appendTo instanceof Function) {
					childNode.appendTo(this.rootNode);
					this.childWidgets.push(childNode);
				} else if(childNode.toUpperCase instanceof Function) {
					this.rootNode.appendChild(document.createTextNode(childNode));
				} else {
					this.rootNode.appendChild(childNode);
				}
			}
		}
		
		return childNode;
	},
	
	/**
	 * Attempts to remove the passed node if it is a child of this.rootNode
	 * 
	 * The passed argument can be either a DOM Node object, or a GUIWidget object.
	 * 
	 * @param	{Mixed}	A child node
	 */
	removeChild: function(childNode) {
		if(childNode && this.getRootNode()) {
			try {
				if(childNode.getRootNode instanceof Function) {
					this.getRootNode().removeChild(childNode.getRootNode());
					this.childWidgets.without(childNode);
				} else {
					this.getRootNode().removeChild(childNode);
				}
			} catch(e) {
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * Replaces a DOM node or GUIWidget that is a child of the root node of this object
	 * 
	 * @param	{Node || GUIWidget}		oldNode		The outgoing child
	 * @param	{Node || GUIWidget}		newNode		The incoming child
	 */
	replaceChild: function(oldNode, newNode) {
		if(oldNode && newNode && this.getRootNode()) {
			try {
				if((oldNode.getRootNode instanceof Function) && (newNode.getRootNode instanceof Function)) { // GUIWidgets
					// find old widget
					var oldNodeIndex = this.childWidgets.indexOf(oldNode);
					if(oldNodeIndex != -1) {
						this.childWidgets[oldNodeIndex] = newNode;
					} else { // trying to replace a widget that does not exist
						Log.warn("Old node not found in childWidgets array during replace operation");
						this.childWidgets.push(newNode);
					}
				}
				
				if(oldNode.getRootNode instanceof Function) {
					oldNode = oldNode.getRootNode();
				}
				
				if(newNode.getRootNode instanceof Function) {
					newNode = newNode.getRootNode();
				}
				
				// check that we actually contain the old node before attempting to replace it
				if(Element.descendantOf(oldNode, this.getRootNode())) {
					this.getRootNode().replaceChild(newNode, oldNode);
				}
				
			} catch(e) {
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * Sets the id attribute on the root node
	 * 
	 * @param	{string}	id
	 */
	setID: function(id) {
		this.setAttribute("id", id);
	},
	
	/**
	 * Returns the id of the root node
	 * 
	 * @return	{string}
	 */
	getID: function() {
		this.getAttribute("id");
	},
	
	/**
	 * Sets a CSS style property to the passed value on the root node
	 * 
	 * @param	{string}	styleName	e.g. "border"
	 * @param	{string}	styleValue	e.g. "1px solid #CCC"
	 */
	setStyle: function(styleName, styleValue) {
		if(this.rootNode && styleName && styleValue && this.rootNode.style) {
			try {
				if(this.rootNode.style[styleName] != styleValue) {
					this.rootNode.style[styleName] = styleValue;
				}
			} catch(e) {
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * Returns the requested CSS style property
	 * 
	 * @param	{string}	styleName	e.g. "font"
	 * @return	{string}
	 */
	getStyle: function(styleName) {
		if(this.rootNode) {
			return this.rootNode.getStyle(styleName);
		}
	},
	
	/**
	 * Sets an attribute on the root node
	 * 
	 * @param	{String}	attributeName	e.g. "id"
	 * @param	{String}	attributeValue	e.g. "anElement"
	 */
	setAttribute: function(attributeName, attributeValue) {
		if(this.rootNode) {
			try {
				if(attributeName == "style" && attributeValue instanceof Object) {
					for(var key in attributeValue) {
						this.setStyle(key, attributeValue[key]);
					}
				} else if(this.rootNode[attributeName] != attributeValue) {
					this.rootNode[attributeName] = attributeValue;
				}
			} catch(e) {
				Log.error("exeption thrown setting " + attributeName + " to " + attributeValue);
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * Returns the requested attribute from the root node
	 * 
	 * @param	{String}	attributeName	e.g. "id"
	 * @return	{String}
	 */
	getAttribute: function(attributeName) {
		if(this.rootNode) {
			return this.rootNode[attributeName];
		}
	},
	
	/**
	 * Returns whether or not the root node of this object is of the passed CSS class
	 * 
	 * @return boolean
	 */
	isClass: function(className) {
		return DOMUtil.hasClass(this.getRootNode(), className);
	},
	
	/**
	 * @return void
	 */
	resize: function() {
		this.notifyListeners("onResize");
	},
	
	_sizeScrollable: function(scrollable, dim, maxSize) {
		if(scrollable && scrollable.parentNode) {
			scrollable.owner().triggerEvent("onWillResize");
			var nodeList = $A(scrollable.parentNode.childNodes);
			
			nodeList.each(function(node){
				if(node && node != scrollable) {
						var dims = Element.getDimensions(node);
						maxSize = maxSize - dims[dim];
				}
			});
			
			scrollable.style[dim] = maxSize + "px";
			scrollable.owner().triggerEvent("onResize");
		}
	},
	
	/**
	 * Makes the passed node the first child of this object.
	 * 
	 * @param {Object} A GUIWidget or DOM Node
	 */
	insertAtTop: function(newNode) {
		this.getRootNode().insertBefore(this._getNode(newNode), this.getRootNode().firstChild);
	},
	
	/**
	 * Inserts the first passed node before the second.
	 * 
	 * @param {Object} A GUIWidget or DOM Node
	 * @param {Object} A GUIWidget or DOM Node - should be a child of this element
	 */
	insertBefore: function(newNode, referenceNode) {
		this.getRootNode().insertBefore(this._getNode(newNode), this._getNode(referenceNode));
	},
	
	/**
	 * Gets the DOM node from a GUIWidget
	 * 
	 * @param {Object} A GUIWidget or DOM Node
	 * @return {Node}
	 */
	_getNode: function(fromNode) {
		if(fromNode) {
			if(fromNode.getRootNode instanceof Function) {
				return fromNode.getRootNode();
			} else if(fromNode.appendChild) {
				return fromNode;
			}
		}
		
		Log.error("Invalid node!");
	},
	
	focus: function() {
		this.getRootNode().focus();
	},
	
	blur: function() {
		this.getRootNode().blur();
	}
});

/**
 * @class deadline.gui.notificationArea.MessageArea
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.notificationArea.MessageArea = new Class.create(behaviour.gui.GUIWidget, {
	
	_messageQueue: null,
	active: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("td");
		this.addClass("MessageArea");
		this.setStyle("display", "none");
		
		this.active = false;
		this._messageQueue = [];
	},
	
	/**
	 * @param {String} messageHeader
	 * @param {String} messageText
	 * @param {String} messageStatus
	 */
	setMessage: function(messageHeader, messageText, messageStatus) {
		this._messageQueue[this._messageQueue.length] = {
			header: messageHeader,
			text: messageText,
			status: messageStatus
		};
		
		if(!this.active) {
			this.showMessage();
		}
	},
	
	/**
	 * Shows a message
	 */
	showMessage: function() {
		if(this.active) {
			if(this._messageQueue.length == 0) {
				this.active = false;
				Effect.Fade(this.getRootNode(), {duration: 0.25});
				
				setTimeout(this.clearMessage.bind(this), 255);
				return;
			}
			
			// fade out old message and show new one
			Effect.Fade(this.getRootNode(), {duration: 0.25});
			setTimeout(this.showNextMessage.bind(this), 250);
		} else { // construct display and fade in
			this.active = true;
			this.buildMessage();
			Effect.Appear(this.getRootNode(), {duration: 0.5});
		}
		
		setTimeout(this.showMessage.bind(this), 5000);
	},
	
	/**
	 * Shows next message
	 */
	showNextMessage: function() {
		this.buildMessage();
		Effect.Appear(this.getRootNode(), {duration: 0.25});
	},
	
	/**
	 * Builds graphical representation of a message
	 */
	buildMessage: function() {
		var message = this._messageQueue.shift();
		
		this.removeClass("info");
		this.removeClass("error");
		
		if(message["status"]) {
			this.addClass(message["status"]);
		}
		
		this.empty();
		this.appendChild(DOMUtil.createTextElement("h2", message["header"]));
		this.appendChild(DOMUtil.createTextElement("p", message["text"]));
	},
	
	/**
	 * Clears message area
	 */
	clearMessage: function() {
		this.empty();
	}
});

/**
 * @class deadline.gui.notificationArea.LoadingArea
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.notificationArea.LoadingArea = new Class.create(behaviour.gui.GUIWidget, {
	
	_numLoading: null,
	_numCompleted: null,
	active: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
			
		this.setRootNode("td");
		this.addClass("LoadingArea");
		this.setStyle("display", "none");
		
		this.active = false;
		this._numLoading = 0;
		this._numCompleted = 0;
	},
	
	/**
	 * Start loading...
	 */
	startLoad: function() {
		this._numLoading++;
		
		this.render();
		
		if(this._numLoading == 1) {
			this.active = true;
			Effect.Appear(this.getRootNode(), {duration: 0.1});
		}
	},
	
	/**
	 * Stop loading...
	 */
	stopLoad: function() {
		if(this._numLoading > 0) {
			this._numLoading--;
		}
		
		if(this._numCompleted == 0) {
			this._numCompleted++;
		}
		
		if(this._numLoading == 0) {
			this.active = false;
			this._numCompleted = 0;
			Effect.Fade(this.getRootNode(), {duration: 0.5});
			return;
		}
		
		this.render();
	},
	
	/**
	 * render loading area
	 */
	render: function() {
		this.empty();
		
		if(Language.isLoaded()) {
			try {
				this.appendChild(DOMUtil.createTextElement("h2", Language.get("deadline.gui.notificationArea.LoadingArea.loadingheader")));
				
				var percent = Math.round((this._numCompleted/this._numLoading) * 100);
				
				if(percent == 0 || this._numLoading == 1) {
					this.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.notificationArea.LoadingArea.loadingmessage")));
				} else if(this._numLoading > 1) {
					this.appendChild(DOMUtil.createTextElement("p", Language.getFormatted("deadline.gui.notificationArea.LoadingArea.loadingmultiplemessage", {count: percent})));
				}
			} catch(e) {
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * clear loading area
	 */
	clearLoading: function() {
		this.empty();
	}
});
/**
 * @class behaviour.gui.updateables.InputException
 */
behaviour.gui.updateables.InputException = new Class.create({
	message: null,
	
	/**
	 * @param {String} message
	 */
	initialize: function(message) {
		this.message = message;
	}
});

/**
 * @class deadline.gui.notificationArea.NotificationArea
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.notificationArea.NotificationArea = new Class.create(behaviour.gui.GUIWidget, {
	
	innerDiv: null,
	messageArea: null,
	loadingArea: null,
	watcherInterval: null,
	active: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("NotificationArea");
		this.setStyle("display", "none");
		
		this.innerDiv = DOMUtil.createElement("div");
		DOMUtil.addClass(this.innerDiv, "innerDiv");
		this.appendChild(this.innerDiv);
		
		this.active = false;
		
		this.messageArea = new deadline.gui.notificationArea.MessageArea();
		this.loadingArea = new deadline.gui.notificationArea.LoadingArea();
		
		var table = DOMUtil.createTextElement("table");
		var tableBody = DOMUtil.createElement("tbody");
		var tableRow = DOMUtil.createElement("tr");
		
		table.appendChild(tableBody);
		tableBody.appendChild(tableRow);
		
		this.loadingArea.appendTo(tableRow);
		this.messageArea.appendTo(tableRow);
		
		this.innerDiv.appendChild(table);
	},
	
	/**
	 * Start load notification 
	 */
	startLoad: function() {
		this.loadingArea.startLoad();
		this.appear();
	},
	
	/**
	 * Stop load notification
	 */
	stopLoad: function() {
		this.loadingArea.stopLoad();
	},
	
	/**
	 * @param {String} messageHeader
	 * @param {String} messageText
	 * @param {String} messageStatus
	 */
	setMessage: function(messageHeader, messageText, messageStatus) {
		this.messageArea.setMessage(messageHeader, messageText, messageStatus ? messageStatus : "info");
		this.appear();
	},
	
	/**
	 * Sets error message
	 * @param {String} messageHeader
	 * @param {String} messageText 
	 */
	setError: function(messageHeader, messageText) {
		if(typeof(messageText) == "undefined") {
			messageText = messageHeader;
			messageHeader = Language.get("deadline.gui.notificationArea.NotificationArea.error");
		}
		
		if(messageText instanceof behaviour.gui.updateables.InputException) {
			messageText = messageText.message;
		}
		
		this.messageArea.setMessage(messageHeader, messageText, "error");
		this.appear();
	},
	
	/**
	 * Watches notification area 
	 */
	watchChildren: function() {
		if(!this.loadingArea.active && !this.messageArea.active) {
			this.active = false;
			clearInterval(this.watcherInterval);
			Effect.Fade(this.rootNode, {duration: 0.5});
		}
	},
	
	/**
	 * Appear
	 */
	appear: function() {
		if(this.active == false && (this.loadingArea.active || this.messageArea.active)) {
				this.active = true;
				this.watcherInterval = setInterval(this.watchChildren.bind(this), 500);
				this.setStyle("display", "block");
			}
	}
});

/**
 * @class behaviour.gui.FloatingWindow
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.FloatingWindow = new Class.create(behaviour.gui.GUIWidget, {
	
	_contentDiv: null,
	_content: null,
	_lastMouseX: null,
	_lastMouseY: null,
	_escapeKeyObserver: null,
	
	/**
	 * @param {mixed} options
	 * @example	
	 * Supports the following options:
	 * 
	 * options: {
	 * 		x: int						// initial x position, optional
	 * 		y: int						// initial y position, optional
	 * 		width: int				// inital width
	 * 		height: int				// initial height
	 * 		owner: Object		// should implement a method called windowClosed
	 * 		title: String				// the window title
	 * 		modal: boolean		// whether the window should be modal
	 * 		nearPointer: boolean	// whether the window should appear near to where the user clicked
	 * 		pointerEvent: Event		// the mouse click
	 * 		shouldCloseWindow: Function // a function that can return false to prevent the window from disappearing
	 * }
	 * 
	 * Supports the following events:
	 * 
	 * onAppear
	 * onDisappear
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("FloatingWindow");
		this.setStyle("position", "absolute");
		this.setStyle("width", this.options.width + "px");
		this.setStyle("height", this.options.height + "px");
		
		this.setStyle("display", "none");
		
		if(!this.options.hideChrome) {
			this._windowTitle = DOMUtil.createTextElement("a", this.options.title ? this.options.title : ".", {
				title: Language.get("bbq.gui.FloatingWindow.clickandholdtodrag"), 
				href: ".", 
				onclick: this.blurIt.bindAsEventListener(this), 
				onmousedown: this.startDrag.bindAsEventListener(this),
				className: "FloatingWindowTitle"
			});
			
			if(Browser.InternetExplorer) {
				this._windowTitle.ondrag = function() {return false};
				this._windowTitle.onselectstart = function() {return false};
			}
			
			var row = DOMUtil.createTableRow(2);
			row.childNodes[0].appendChild(this._windowTitle);
			DOMUtil.addClass(row.childNodes[0], "dragLinkCell");
			
			row.childNodes[1].appendChild(DOMUtil.createTextElement("a", Language.get("bbq.gui.FloatingWindow.close"), {href: ".", onclick: this.closeWindow.bindAsEventListener(this)}));
			DOMUtil.addClass(row.childNodes[1], "closeLinkCell");
			
			this.appendChild(DOMUtil.createTextElement("div", DOMUtil.createTextElement("table", DOMUtil.createTextElement("tbody", row), {className: "chrome"}), {className: "FloatingWindowHeader"}));
			
			this._escapeKeyObserver = function(event) {
				// if escape key was pressed and we are the front-most window
				if(event.keyCode == Event.KEY_ESC && !DOMUtil.hasClass(this.getRootNode(), "Backgrounded")) {
					this.closeWindow();
				}
			}.bind(this);
			
			Event.observe(document, "keypress", this._escapeKeyObserver);
		}
		
		this._contentDiv = DOMUtil.createElement("div", {className: "FloatingWindowContent"}); 
		
		this.appendChild(this._contentDiv);
		
		this._resizeContent();
		
		Event.observe(window, "resize", this._windowResized.bind(this));
		
		if(this.options.modal) {
			currentPage.addModalLayer(this);
		}
		
		// register ourselves with the window list
		behaviour.gui.FloatingWindow.windows.push(this);
		
		// watch the content window for clicks to bring the window to front
		var bringToFront = this.bringToFront.bind(this);
		Event.observe(this._contentDiv, "click", bringToFront);
		
		this.registerListener("onWindowClosed", function() {
			// stop observing content window to prevent memory leak
			Event.stopObserving(this._contentDiv, "click", bringToFront);
			
			// remove ourselves from the window list
			for(var i = 0; i < behaviour.gui.FloatingWindow.windows.length; i++) {
				if(behaviour.gui.FloatingWindow.windows[i] == this) {
					behaviour.gui.FloatingWindow.windows.splice(i, 1);
					i--;
				}
			}
		}.bind(this));
	},
	
	isFrontMostWindow: function() {
		return this.getStyle("zIndex") == behaviour.gui.FloatingWindow.topZIndex;
	},
	
	/**
	 * Brings this window in front of all other instances of FloatingWindow
	 */
	bringToFront: function() {
		behaviour.gui.FloatingWindow.topZIndex++;
		this.setStyle("zIndex", behaviour.gui.FloatingWindow.topZIndex);
		this.removeClass("Backgrounded");
		
		for(var i = 0; i < behaviour.gui.FloatingWindow.windows.length; i++) {
			if(behaviour.gui.FloatingWindow.windows[i] != this) {
				behaviour.gui.FloatingWindow.windows[i].addClass("Backgrounded");
			}
		}
	},
	
	/**
	 * Shows the passed content in the window
	 */
	setContent: function(content) {
		if(content) {
			this._content = content;
			DOMUtil.emptyNode(this._contentDiv);
			
			if(this._content.appendTo) {
				this._content.setID(null);
				//this._content.setStyle("height", DOMUtil.getStyle(this._contentDiv, "height"));
				this._content.appendTo(this._contentDiv);
			} else {
				this._content.id = null;
				//DOMUtil.setStyle(this._content, "height", DOMUtil.getStyle(this._contentDiv, "height"));
				this._contentDiv.appendChild(this._content);
			}
			
			this._resizeContent();
		}
	},
	
	/**
	 * @private
	 */
	_minusStyle: function(node, style) {
		var dim = parseInt(node.getStyle(style))
		
		if(!isNaN(dim)) {
			return dim;
		}
		
		return 0;
	},
	
	/**
	 * @private
	 */
	_resizeContent: function() {
		var dims = Element.getDimensions(this.getRootNode());
		
		dims.width -= this._minusStyle(this._contentDiv, "paddingLeft");
		dims.width -= this._minusStyle(this._contentDiv, "paddingRight");
		dims.height -= this._minusStyle(this._contentDiv, "paddingTop");
		dims.height -= this._minusStyle(this._contentDiv, "paddingBottom");
		
		if(!this.options.hideChrome) {
			dims.height -= 30;
			dims.width -= 4;
		}
		
		DOMUtil.setStyle(this._contentDiv, "width", Math.abs(dims.width) + "px");
		DOMUtil.setStyle(this._contentDiv, "height", Math.abs(dims.height) + "px");
		
		if(this._content) {
			DOMUtil.setStyle(this._content, "height", Math.abs(dims.height - 2) + "px");
			//make sure that hight of content and contentDiv are different to please IE
			DOMUtil.setStyle(this._contentDiv, "height", Math.abs(dims.height) + "px");
			
			if(this._content.resize) {
				this._content.resize();
			}
		}
	},
	
	/**
	 * Sets the window title to the passed string
	 * 
	 * @param String title The new title
	 */
	setWindowTitle: function(title) {
		if(!this._windowTitle) {
			return;
		}
		
		DOMUtil.emptyNode(this._windowTitle);
		
		if(Object.isString(title)) {
			this._windowTitle.appendChild(document.createTextNode(title ? title : " "));
		} else {
			this._windowTitle.appendChild(title);
		}
	},
	
	/**
	 * @override
	 */
	render: function() {
		if(this._content && this._content.render) {
			this._content.render();
		}
	},
	
	/**
	 * Makes the window visible
	 */
	appear: function() {
		this.appendTo(document.body);
		
		this._resizeContent();
		
		Effect.Appear(this.getRootNode(), {
			duration: 0.1,
			afterFinish: function() {
				this._resizeContent();
				this.notifyListeners("onAppear");
				this.bringToFront();
			}.bind(this)
		});
	},
	
	/**
	 * Makes the window invisible
	 */
	disappear: function() {
		Effect.Fade(this.rootNode, { duration: 0.25 });
		setTimeout(function() {
			if(!this.options.modal) {
				var parentNode = this.rootNode.parentNode;
		
				if(parentNode) {
					parentNode.removeChild(this.rootNode);
				}
			}
			
			this.notifyListeners("onDisppear");
		}.bind(this), 260);
		
		Event.stopObserving(document, "keypress", this._escapeKeyObserver);
	},
	
	/**
	 * @override
	 */
	appendTo: function(node) {
		behaviour.gui.GUIWidget.prototype.appendTo.apply(this, arguments);
		
		Effect.Appear(this.getRootNode(), { duration: 0.1 });
		
		this._positionWindow();
	},
	
	/**
	 * @private
	 */
	_positionWindow: function() {
		var dims = Element.getDimensions(this.getRootNode());
		var windowDims = BehaviourUtil.getWindowSize();
		
		if(this.options.x && this.options.y) {
			this.setStyle("left", this.options.x + "px");
			this.setStyle("top", this.options.y + "px");
		} else if(this.options.pointerEvent) {
			var mouseDims = {
				x: Event.pointerX(this.options.pointerEvent),
				y: Event.pointerY(this.options.pointerEvent)
			}
			
			var windowPosition = {x: 0, y: 0};
			
			if(mouseDims.x < (windowDims.width/2)) { //left hand side of screen
				if(mouseDims.y < (windowDims.height/2)) { // top half of screen
					windowPosition.x = mouseDims.x + 10;
					windowPosition.y = mouseDims.y - 10;
				} else { // bottom half of screen
					windowPosition.x = mouseDims.x + 10;
					windowPosition.y = (mouseDims.y - dims.height) + 10;
				}
			} else { // right hand side of screen
				if(mouseDims.y < (windowDims.height/2)) { // top half of screen
					windowPosition.x = (mouseDims.x - dims.width) - 10;
					windowPosition.y = mouseDims.y - 10;
				} else { // bottom half of screen
					windowPosition.x = (mouseDims.x - dims.width) - 10;
					windowPosition.y = (mouseDims.y - dims.height) + 10;
				}
			}
					
			this.setStyle("left", windowPosition.x + "px");
			this.setStyle("top", windowPosition.y + "px");
		} else {
			this.setStyle("left", Math.abs((windowDims.width - dims.width)/2) + "px");
			this.setStyle("top", Math.abs((windowDims.height - dims.height)/2) + "px");
		}
	},
	
	/**
	 * Makes the window disappear unless options.shouldCloseWindow is set and returns false.
	 */
	closeWindow: function(event) {
		BehaviourUtil.clearFocus(event);
		
		if(this.options.shouldCloseWindow instanceof Function && !this.options.shouldCloseWindow()) {
			return false;
		}
		
		this.notifyListeners("onWindowClosed");
		this.disappear();
		
		return false;
	},
	
	/**
	 * @private
	 */
	blurIt: function(event) {
		BehaviourUtil.clearFocus(event);
		return false;
	},
	
	/**
	 * @private
	 */
	startDrag: function(event) {
		BehaviourUtil.clearFocus(event);
		Event.stop(event);
		
		this.bringToFront();
		this._lastMouseX = Event.pointerX(event);
		this._lastMouseY = Event.pointerY(event);
		
		document.onmousemove = this._doDrag.bindAsEventListener(this);
		document.onmouseup = this._stopDrag.bindAsEventListener(this);
	},
	
	/**
	 * @private
	 */
	_stopDrag: function() {
		document.onmousemove = null;
		document.onmouseup = null;
	},
	
	/**
	 * @private
	 */
	_doDrag: function(event) {
		var x = parseInt(this.getStyle("left").replace("px", "")) - (this._lastMouseX - Event.pointerX(event));
		var y = parseInt(this.getStyle("top").replace("px", "")) - (this._lastMouseY - Event.pointerY(event))
		var windowDims = BehaviourUtil.getViewportSize();
		
		if(x >= 0 && x <= (windowDims.width - this.options.width - 10)) {
			this.setStyle("left", x + "px");
			this._lastMouseX = Event.pointerX(event);
		}
		
		if(y >= 0  && y <= (windowDims.height - this.options.height - 10)) {
			this.setStyle("top", y + "px");
			this._lastMouseY = Event.pointerY(event);
		}
	},
	
	/**
	 * Animates a change in the window size.
	 */
	setWindowSize: function(width, height, duration) {
		this.options.width = width;
		this.options.height = height;
		
		if(Object.isUndefined(duration)) {
			duration = 0.5;
			
			new Effect.Morph(this.getRootNode(), { 
				style: {
					width: this.options.width + "px",
					height: this.options.height + "px"
				},
				afterUpdate: function() {
					this._resizeContent();
					
					this._windowResized(true);
				}.bind(this),
				afterFinish: function() {
					this.notifyListeners("onAfterWindowResize");
				}.bind(this),
				duration: duration
			});
		} else {
			if(this._contentDiv) {
				this._contentDiv.style.display = "none";
			}
			
			new Effect.Morph(this.getRootNode(), {
				style: {
					width: this.options.width + "px",
					height: this.options.height + "px"
				},
				afterUpdate: function() {
					this._resizeContent();
					
					this._windowResized(true);
				}.bind(this),
				afterFinish: function() {
					if(this._contentDiv) {
						Effect.Appear(this._contentDiv, {duration: duration/2});
					}
					
					this.notifyListeners("onAfterWindowResize");
				}.bind(this),
				duration: duration
			});
		}
	},
	
	/**
	 * @private
	 */
	_windowResized: function(animate) {
		this._resizeContent();
		
		if(this.options.centerWindow) {
			// move window into center of screen
			this._positionWindow();
		} else {
			// make sure window is still entirely on the screen
			var windowDims = BehaviourUtil.getViewportSize();
			var x = parseInt(this.getStyle("left"));
			var y = parseInt(this.getStyle("top"));
			var onScreenX = (windowDims.width - this.options.width - 10);
			var onScreenY = (windowDims.height - this.options.height - 10);
			
			if(onScreenX < 0) {
				onScreenX = 0;
			}
			
			if(x > onScreenX) {
				if(animate) {
					new Effect.Morph(this.getRootNode(), {
						style: {
							left: onScreenX + "px"
						}, 
						duration: 0.15
					});
				} else {
					this.setStyle("left", onScreenX + "px");
				}
			}
			
			if(onScreenY < 0) {
				onScreenY = 0;
			}
			
			if(y > onScreenY) {
				if(animate) {
					new Effect.Morph(this.getRootNode(), {
						style: {
							top: onScreenY + "px"
						}, 
						duration: 0.15
					});
				} else {
					this.setStyle("top", onScreenY + "px");
				}
			}
		}
	}
});

behaviour.gui.FloatingWindow.topZIndex = 100;
behaviour.gui.FloatingWindow.windows = [];

/**
 * @class behaviour.gui.FloatingWindow
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.ModalWindow = new Class.create(behaviour.gui.FloatingWindow, {
	/**
	 * @param {mixed} options
	 * @example	
	 * Supports the following options:
	 * 
	 * options: {
	 * 		showChrome: boolean						// Whether to be draggable, show close window button, etc
	 * }
	 * 
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.modal = true;
		
		$super(options);
		
		this.addClass("ModalWindow");
		
		if(this.options.hideChrome) {
			// superclass adds chrome to window so get rid of it
			this.addClass("ModalWindow_withoutChrome");
		} else {
			this.addClass("ModalWindow_withChrome");
		}
		
		currentPage.addModalLayer(this);
	}
});

/**
 * @class behaviour.gui.panel.Panel
 * @extends behaviour.gui.GUIWidget 
 */
behaviour.gui.panel.Panel = new Class.create(behaviour.gui.GUIWidget, {
	_childPanels: {},
	
	/**
	 * @param	{Object}	options		An associative array
	 * @example
	 * 
	 * Supports the following options:
	 * 
	 * options = {
	 * 		fixedHeight: boolean		// If true, the panel will not be resized in height - set the desired height in CSS  NB. The panel preceeding this panel will be reized to fill all remaining height
	 * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("Panel");
		
		this._childPanels = {};
		
		if(this.options.direction != "vertical") {
			this.options.direction = "horizontal";
		}
	},
	
	/**
	 * Adds a child panel to this panel object.  Child panels are named so they can be replaced by passing a new panel
	 * with the same name.
	 * 
	 * @param	{string}	panelName
	 * @param	{mixed}	panelContent	Can be behaviour.gui.GUIWidget or Node
	 */
	_setChildPanel: function(panelName, panelContent) {
		if(typeof(this._childPanels[panelName]) != "undefined" && typeof(panelContent) != "undefined") {
			this.replaceChild(this._childPanels[panelName], panelContent);
		}
		
		this._childPanels[panelName] = panelContent;
	},
	
	/**
	 * Returns the panel with the specified name
	 * 
	 * @param	{string}	panelName
	 * @return	{mixed}		Can be behaviour.gui.GUIWidget or Node
	 */
	_getChildPanel: function(panelName) {
		if(typeof(this._childPanels[panelName]) == "undefined") {
			return null;
		}
		
		return this._childPanels[panelName];
	},
	
	/**
	 * @param {Object} options Should be behaviour.gui.panel.Panel 
	 * @example
	 * addPanel({panel: Panel, withName: String})
	 */
	addPanel: function(options) {
		if(Object.isUndefined(options.withName)) {
			options.withName = BehaviourUtil.generateGUID();
		}
		
		this._setChildPanel(options.withName, options.panel);
		behaviour.gui.GUIWidget.prototype.appendChild.call(this, options.panel);
		
		return options.panel;
	},
	
	/**
	 * Replace a child panel.  Pass in the panel to replace or it's name, and the new panel.
	 * 
	 * @param {Mixed}	oldPanel		A string or a behaviour.gui.panel.Panel object.  Must be a child of this panel
	 * @param {behaviour.gui.panel.Panel}		newPanel	The new panel
	 */
	replacePanel: function(oldPanel, newPanel) {
		if(oldPanel && newPanel) {
			var panelName;
			
			if(oldPanel.toUpperCase) {
				panelName = oldPanel;
			} else {
				panelName = this._getPanelName(oldPanel);
			}
			
			if(!panelName) {
				Log.warn("Panel to replace is not a child of this panel");
				return;
			}
			
			var panelToReplace = this._childPanels[panelName];
			
			if(!panelToReplace) {
				Log.warn("Panel to replace is not a child of this panel");
				return;
			}
			
			// replace the DOM node
			var parentNode = panelToReplace.getRootNode().parentNode;
			
			if(parentNode) {
				newPanel.render();
				parentNode.replaceChild(newPanel.getRootNode(), panelToReplace.getRootNode());
			}
			
			// add to our local store
			this._setChildPanel(panelName, newPanel);
		}
	},
	
	/**
	 * @private
	 */
	_getPanelName: function(panel) {
		for(var key in this._childPanels) {
			if(this._childPanels[key] == oldPanel) {
				return key;
			}
		}
		
		return null;
	},
	
	/**
	 * Appends child to a panel. Child can be ancestor of Panel or GUIWidget.
	 * 
	 * @param {Object} child
	 */
	appendChild: function($super, child) {
		if(child && child.isClass && child.isClass("panel")) {
			this._setChildPanel(BehaviourUtil.generateGUID(), child);
		}
		
		return $super(child);
	},
	
	/**
	 * Returns a child panel by name
	 * @param {String} byName
	 * @return {Object}
	 */
	getPanel: function(byName) {
		return this._getChildPanel(byName);
	},
	
	/**
	 * Sets a child on a Panel object
	 * 
	 * @param {String} withName
	 * @param {Panel} withPanel
	 * @return {Panel}
	 */
	setPanel: function(withName, withPanel) {
		this._setChildPanel(withName, withPanel);
		return withPanel;
	},
	
	/**
	 * @private
	 */
	_getPanelHeight: function(node) {
		if(!node) {
			//Log.error("Invalid node passed to Panel#_getPanelHeight");
			return NaN;
		}
		
		node = (node.getRootNode ? node.getRootNode() : node);
		
		if(node.style.display == "none") {
			return 0;
		}
		
		var occupiedDims = DOMUtil.getOccupiedDimensions(node);
		
		if(isNaN(occupiedDims.height)) {
			//Log.warn("height NaN "+ node.className);
			var dims = Element.getDimensions(node);
			
			if(isNaN(dims.height)) {
				Log.error("height still NaN "+ node.className);
			} else {
				//Log.warn("height was "+ dims.height);
				occupiedDims.height = dims.height;
			}
		}
		//Log.info("returning " + (occupiedDims.height < 0 ? 0 : occupiedDims.height));
		return occupiedDims.height < 0 ? 0 : occupiedDims.height;
	},
	
	/**
	 * @private
	 */
	_getResizeCandidate: function(panels, scrollable) {
		if(typeof(scrollable) != "undefined" && scrollable) {
			return scrollable;
		} else {
			return panels.last();
		}
	},
	
	/**
	 * @private
	 */
	_expandPreviousPanel: function(panel, height) {
		if(panel) {
			panel.setStyle("height", height + "px");
			
			if(panel.resize) {
				panel.resize();
			}
			
			return true;
		}
		
		return false;
	},
	
	/**
	 * Resizes and notifies listeners "onResize"
	 */
	resize: function() {
		try {
			if(Object.isUndefined(this.getRootNode().style.height)) {
				return;
			}
			/*
			if(this.options.direction == "vertical") {
				this._resizeVertical();
			} else {
				this._resizeHorizontal();
			}
			
			return;
			*/		
			var height = this._getPanelHeight(this);
			var styleHeight = parseInt(this.getRootNode().style.height);
			
			if(height > styleHeight) {
				height = styleHeight;
			}
			
			if(height <= 0) {
				return;
			}
			
			var panels = [];
			var scrollable = false;
			
			for(var key in this._childPanels) {
				var panel = this._childPanels[key];
				
				// skip hidden panels
				if(panel.getStyle("display") == "none") {
					continue;
				}
				
				if(panel.isClass && panel.isClass("ScrollableHolder")) {
					scrollable = panel;
				}
				
				if(panel.options && panel.options.fixedHeight) {
					height -= this._getPanelHeight(panel);
				} else {
					panels.push(panel);
				}
			}
			
			if(this.options.direction == "vertical") {
				panels.each(function(panel, index) {
					height -= this._getPanelHeight(panel);
					
					if(panel.resize) {
						panel.resize();
					}
					
				}.bind(this));
				
				if(height != 0) {
					var resizeCandidate = this._getResizeCandidate(panels, scrollable);
					var newHeight = height + this._getPanelHeight(resizeCandidate);
					
					if(newHeight > 0) {
						this._expandPreviousPanel(resizeCandidate, newHeight);
					}
				}
			} else {
				panels.each(function(panel, index) {
					panel.setStyle("height", height + "px");
					
					if(panel.resize) {
						panel.resize();
					}
				}.bind(this));
			}
			
			this.notifyListeners("onResize");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_resizeVertical: function() {
		var scrollable = false;
		var height = DOMUtil.getOccupiedDimensions(this).height;
		
		for(var key in this._childPanels) {
			var panel = this._childPanels[key];
			
			// skip hidden panels
			if(panel.getStyle("display") == "none") {
				continue;
			}
			
			height -= DOMUtil.getOccupiedDimensions(panel).height;
			
			if(Object.isFunction(panel.resize)) {
				panel.resize();
			}
			
			if(!panel.options.fixedHeight) {
				scrollable = panel;
			}
		}
		
		Log.info("have " + height + " left over scrollable " + scrollable);
		
		if(height > 0 && scrollable) {
			scrollable.setStyle("height", DOMUtil.getOccupiedDimensions(scrollable) + height + "px");
			
			if(Object.isFunction(scrollable.resize)) {
				scrollable.resize();
			}
		}
	},
	
	_resizeHorizontal: function() {
		var height = this._getPanelHeight(this);
		
		for(var key in this._childPanels) {
			var panel = this._childPanels[key];
			panel.setStyle("height", height + "px");
			
			if(Object.isFunction(panel.resize)) {
				panel.resize();
			}
		}
	},
	
	/**
	 * Checks whether the panel has a minimised child
	 * @return {Boolean}
	 */
	hasMinimisedChild: function() {
		for(var key in this._childPanels) {
			if(this._childPanels[key].minimised) {
				return true;
			}
		}
		
		return false;
	},
	
	/**
	 * Returns a minimised height
	 * @return {Integer} height
	 */
	getMinimisedSize: function() {
		var height = parseInt(this.getStyle("height"));
		
		for(var key in this._childPanels) {
			if(this._childPanels[key].minimised) {
				var childHeight = parseInt(this._childPanels[key].getStyle("height"));
				
				if((height - childHeight) < 0) {
					return height;
				}
				
				height -= childHeight;
			}
		}
		
		return height;
	}
});

/**
 * Holds behaviour.gui.button.GUIButtons
 * @class behaviour.gui.button.ButtonHolder
 * @extends behaviour.gui.panel.Panel
 */
behaviour.gui.button.ButtonHolder = Class.create(behaviour.gui.panel.Panel, {
	_disabled: false,
	_selectedIndex: 0,
	_buttonNames: null,
	
	/**
	 * Supports the following options:
	 * 
	 * options: {
	 * 		vertical: boolean				// Pass true if these buttons are orientated vertically, otherwise will be horiztonal
	 * 		ignoreKeyPresses: boolean		// Pass true to ignore key presses
	 * }
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("ul");
		this.addClass("ButtonHolder");
		
		this._buttonNames = new Hash();
		this.options.fixedHeight = true;
	},
	
	/**
	 * @param	{behaviour.gui.button.GUIButton}	button
	 */
	addButton: function(button, buttonName) {
		button.setIndex(this.childWidgets.length);
		button.buttonHolder = this;
		
		if(button.getRootNode().tagName.toLowerCase() != "li") {
			this.appendChild(DOMUtil.createTextElement("li", button));
		} else {
			this.appendChild(button);
		}
		
		if(buttonName) {
			this._buttonNames.set(buttonName, button);
		}
		
		return button;
	},
	
	/**
	 * Removes the down state on all child buttons
	 */
	clearDown: function() {
		this.childWidgets.invoke("clearDown");
	},
	
	/**
	 * Disables every child button
	 */
	setDisabled: function(disabled) {
		this._disabled = disabled;
		this.childWidgets.invoke("setDisabled", disabled);
		this._buttonNames.each(function(button) {
			button[1].setDisabled(disabled);
		})
		
		if(this._disabled) {
			this.clearDown();
			this.loseFocus();
		}
	},
	
	/**
	 * Returns a button
	 * 
	 * @param	{integer}	index
	 */
	getButton: function(index) {
		if(Object.isString(index)) {
			return this._buttonNames.get(index);
		}
		
		return this.childWidgets[index];
	},
	
	/**
	 * @return	Returns the index of the currently selected button
	 * @type {integer}
	 */
	getSelectedIndex: function() {
		return this._selectedIndex;
	},
	
	/**
	 * Sets the currently selected button index
	 * @param {integer} index
	 */
	setSelectedIndex: function(index) {
		this._selectedIndex = index;
	},
	
	/**
	 * @private
	 */
	_buttonClicked: function(button, event) {
		this.setSelectedIndex(button.getIndex());
		
		// only register for keypresses if an event was passed.  This may not always be the case - ie. if the button's buttonClicked method was invoked manually
		if(event) {
			FocusWatcher.setKeypressCallbackObject(this);
		}
	},
	
	/**
	 * Accepts focus if not disabled
	 */
	acceptFocus: function() {
		if(!this._disabled) {
			this.addClass("hasFocus");
		}
	},
	
	/**
	 * Loose focus
	 */
	loseFocus: function() {
		this.removeClass("hasFocus");
	},
	
	/**
	 * Processes key presses on the button holder
	 * @param {Event} event
	 */
	processKeypress: function(event) {
		if(!this.options.ignoreKeyPresses && !this._disabled) {
			var nextEntity = false;
			var index = this.getSelectedIndex();
			
			if(index != -1) {
				// process keypress
				if(this.options.vertical) {
					if(event.keyCode == Event.KEY_UP) { // previous button
						nextEntity = this.getButton(index - 1);
					} else if(event.keyCode == Event.KEY_DOWN) {  // next button
						nextEntity = this.getButton(index + 1);
					}
				} else {
					if(event.keyCode == Event.KEY_LEFT) { // previous button
						nextEntity = this.getButton(index - 1);
					} else if(event.keyCode == Event.KEY_RIGHT) {  // next button
						nextEntity = this.getButton(index + 1);
					}
				}
			}
			
			if(nextEntity) {
				nextEntity.buttonClicked();
			}
			
			return true;
		}
	}
});

/**
 * @class behaviour.gui.error.FatalError
 * @extends behaviour.gui.ModalWindow
 */
behaviour.gui.error.FatalError = new Class.create(behaviour.gui.ModalWindow, {
	/**
	 * @param {mixed} options
	 * @example	
	 * Supports the following options:
	 * 
	 * options: {
	 * 		showChrome: boolean						// Whether to be draggable, show close window button, etc
	 * }
	 * 
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.modal = true;
		
		if(!options.width) {
			options.width = 400;
		}
		
		if(!options.height) {
			options.height = 500;
		}
		
		options.hideChrome = true;
		
		$super(options);
		
		this.addClass("FatalError");
		
		var content = DOMUtil.createTextElement("div", [ 
			DOMUtil.createTextElement("h2", this.getHeader()),
			this.getMessage()
		], {className: "FatalErrorContent"});
		
		if(!this.options.noReload) {
			content.appendChild(DOMUtil.createTextElement("p", Language.get("bbq.gui.error.FatalError.error", "message")));
			
			var reload = new behaviour.gui.button.ButtonHolder();
			reload.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("bbq.gui.error.FatalError.button"), onclick: function() {
				window.location.reload();
			}.bind(this)}));
			
			reload.appendTo(content);
		}
		
		this.setContent(content);
		
		// stop edit watchers from throwing up a dialogue if the user refreshes the page.
		EditWatcher.deRegisterAllEditors();
	},
	
	getHeader: function() {
		return Language.get("bbq.gui.error.FatalError.header");
	},
	
	getMessage: function() {
		return Language.get("bbq.gui.error.FatalError.message");
	}
});

/**
 * @class behaviour.gui.error.NotLoggedIn
 * @extends behaviour.gui.error.FatalError
 */
behaviour.gui.error.NotLoggedIn = new Class.create(behaviour.gui.error.FatalError, {
	
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.height = 120;
		options.noReload = true;
		
		$super(options);
		
		this.addClass("NotLoggedIn");
		
		setTimeout(function() {
			document.location = "/";
		}, 5000);
	},
	
	getHeader: function() {
		return "Not logged in";
	},
	
	getMessage: function() {
		var documentFragment = document.createDocumentFragment();
		documentFragment.appendChild(DOMUtil.createTextElement("p", Language.get("bbq.gui.error.NotLoggedIn.notloggedin")));
		
		return documentFragment;
	}
});

/**
 * Wrapper for Prototype Ajax class.
 * 
 * Adds extras such as an independent server timeout and error handling
 * @class behaviour.ajax.AJAXRequest
 * 
 */
behaviour.ajax.AJAXRequest = Class.create({
	onSuccess: null,
	onFailure: null,
	onException: null,
	onComplete: null,
	timeOut: null,
	interval: null,
	url: null,
	options: null,
	
	/**
	 * Constructor
	 * 
	 * @param	{Object} options	The URL to send the request to
	 * 
	 * @example
	 * Supports the following options:
	 * options {
	 * 		url:	String						// where to send the request to
	 * 		method: String						// post or get
	 * 		args: Object						// key->value pairs to convert to query string
	 * 		onsuccess: Function
	 * 		onfaliure: Function
	 * 		onexception: Function
	 * }
	 */
	initialize: function(options) {
		this.options = options;
		
		if(!this.options.method) {
			this.options.method = "post";
		}
		
		if(!this.options.args) {
			this.options.args = {};
		}
		
		this.sendRequest();
	},
	
	/**
	 * Pre-encodes passed parameters so that encodeURI does not fall over deep within Prototype
	 * 
	 * @param {Object} args The arguments to encode
	 * 
	 * @return void
	 */
	_escapeArguments: function(args) {
		if(!args || Object.isFunction(args) || Object.isNumber(args)) {
			return;
		}
		
		if(Object.isArray(args)) {
			for(var i = 0; i < args.length; i++) {
				if(Object.isString(args[i])) {
					args[i] = encodeURIComponent(args[i]);
				} else {
					this._escapeArguments(args[i]);
				}
			}
		} else if(Object.isHash(args)) {
			args.keys().each(function(key) {
				if(Object.isString(args.get(key))) {
					args.set(key, encodeURIComponent(args.get(key)));
				} else {
					this._escapeArguments(args.get(key));
				}
			}.bind(this));
		} else {
			for(var key in args) {
				if(Object.isString(args[key])) {
					args[key] = encodeURIComponent(args[key]);
				} else {
					this._escapeArguments(args[key]);
				}
			}
		}
	},
	
	/**
	 * Sends the request via the specified method
	 * 
	 * @return	void
	 */
	sendRequest: function() {
		this._escapeArguments(this.options.args);
		
		var request = new Ajax.Request(this.options.url, {
			method: this.options.method, 
			postBody: Object.toJSON(this.options.args),
			onSuccess: this.onSuccess.bind(this), 
			onFailure: this.onFailure.bind(this), 
			onExcepton: this.onException.bind(this),
			requestHeaders: {
				"X-Content-Type": "application/json"
			}
		});
		
		if(typeof(firebug) != "undefined" && firebug.watchXHR instanceof Function) {
			// enable firebug lite to watch the ajax call status
			request.transport._name = this.options.method.toUpperCase() + ' ' + this.options.url;
			firebug.watchXHR(request.transport);
		}
		
		// get time out data from server configuration
		if(typeof(ServerConfig) != "undefined" && ServerConfig["timeout"]) {
			this.timeOut = ServerConfig["timeout"];
		} else {
			this.timeOut = 30;
		}
		
		// check timeout every second
		this.interval = setInterval(this.checkTimeOut.bind(this), 1000);
		
		if(typeof(NotificationArea) != "undefined") {
			NotificationArea.startLoad();
		}
	},
	
	/**
	 * @access	protected
	 * @param {String} handlerName
	 * @param {Object} args
	 */
	_callHandler: function(handlerName, args) {
		if(typeof(NotificationArea) != "undefined") {
			NotificationArea.stopLoad();
		}
		
		clearInterval(this.interval);
		
		if(this.options[handlerName] && this.options[handlerName] instanceof Function) {
			this.options[handlerName].apply(this, args);
		} else if(this.options["onAnything"] && this.options["onAnything"] instanceof Function) {
			this.options["onAnything"].apply(this, args);
		}
	},
	
	/**
	 * @param {Object} serverResponse
	 */
	onSuccess: function(serverResponse) {
		if(serverResponse.getResponseHeader("X-bbq-responseType") == -100) {
			var errorMessage = new behaviour.gui.error.ServerError({
				url: this.options.url,
				args: this.options.args,
				serverResponse: BehaviourUtil.urlDecode(serverResponse.getResponseHeader("X-responseMessage"))
			});
			errorMessage.appear();
		} else if(serverResponse.getResponseHeader("X-bbq-responseType") == -99) {
			var errorMessage = new behaviour.gui.error.NotLoggedIn();
			errorMessage.appear();
		} else {
			this._callHandler("onSuccess", $A(arguments));
		}
	},
	
	onFailure: function() {
		Log.error('Request to ' + this.options.method.toUpperCase() + ' ' + this.options.url + " failed");
		this._callHandler("onFaliure", $A(arguments));
	},
	
	onException: function() {
		Log.error('Request to ' + this.options.method.toUpperCase() + ' ' + this.options.url + " threw exception");
		this._callHandler("onException", $A(arguments));
	},
	
	/**
	 * Checks to see if the timer has reached 0.  If so the server request has timed out.
	 * 
	 * @return	void
	 */
	checkTimeOut: function() {
		if(this.timeOut == 0) {
			this.timedOut();
			clearInterval(this.interval);
		} else {
			this.timeOut--;
		}
	},
	
	/**
	 * Shows the user a warning
	 * 
	 * @return	void
	 */
	timedOut: function() {
		Log.warn("Ajax call to " + this.options.url + " timed out");
		
		if(typeof(NotificationArea) != "undefined" && typeof(Language) != "undefined" && Language.get instanceof Function) {
			NotificationArea.stopLoad();
			NotificationArea.setMessage(
				Language.get("bbq.ajax.AJAXRequest.ajaxtimeoutheader"), 
				Language.get("bbq.ajax.AJAXRequest.ajaxtimeoutmessage"), 
				"error"
			);
			NotificationArea.setMessage(
				Language.get("bbq.ajax.AJAXRequest.reloadpageheader"), 
				Language.get("bbq.ajax.AJAXRequest.reloadpagemessage"), 
				"error"
			);
		}
	}
});


/**
 * @class behaviour.gui.error.ServerError
 * @extends behaviour.gui.error.FatalError
 */
behaviour.gui.error.ServerError = new Class.create(behaviour.gui.error.FatalError, {
	/**
	 * @param {mixed} options
	 * @example	
	 * Supports the following options:
	 * 
	 * options: {
	 * 		showChrome: boolean						// Whether to be draggable, show close window button, etc
	 * }
	 * 
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.height = 500;
		
		$super(options);
		
		this.addClass("ServerError");
	},
	
	getMessage: function($super) {
		var documentFragment = document.createDocumentFragment();
		documentFragment.appendChild(DOMUtil.createTextElement("p", $super()));
		
		var errorDiv = DOMUtil.createTextElement("div", [
			DOMUtil.createTextElement("p", Language.get("bbq.gui.error.ServerError.time"), {className:"ServerError_diagnosticHeader"}),
			DOMUtil.createTextElement("pre", new Date().toGMTString()),
			DOMUtil.createTextElement("p", Language.get("bbq.gui.error.ServerError.url"), {className:"ServerError_diagnosticHeader"}),
			DOMUtil.createTextElement("pre", this.options.url),
			DOMUtil.createTextElement("p", Language.get("bbq.gui.error.ServerError.request"), {className:"ServerError_diagnosticHeader"}),
			DOMUtil.createTextElement("pre", Object.toJSON(this.options.args)),
			DOMUtil.createTextElement("p", Language.get("bbq.gui.error.ServerError.response"), {className:"ServerError_diagnosticHeader"}),
			DOMUtil.createTextElement("pre", this.options.serverResponse)
		], {className: "ServerError_errorDisplay"});
		
		documentFragment.appendChild(errorDiv);
		
		return documentFragment;
	}
});

/**
 * @class behaviour.ajax.JSONRequest is a subclass of behaviour.ajax.AJAXRequest
 * @extends behaviour.ajax.AJAXRequest
 */
behaviour.ajax.JSONRequest = Class.create(behaviour.ajax.AJAXRequest, {
	/**
	 * @param	{String}		handlerName
	 * @param	{Object}		args
	 */
	_callHandler: function($super, handlerName, args) {
		var serverResponse = args[0];
		var json = {};
		
		try {
			if(serverResponse.responseText != "") {
				json = serverResponse.responseText.evalJSON(true);
				this._descapeResponse(json);
			}
		} catch(e) {
			Log.dumpException(e);
			
			var errorMessage = new behaviour.gui.error.ServerError({
				url: this.options.url,
				args: this.options.args,
				serverResponse: serverResponse.responseText
			});
			errorMessage.appear();
		}
		
		$super(handlerName, [serverResponse, json]);
	},
	
	_descapeResponse: function(args) {
		if(!args || Object.isFunction(args) || Object.isNumber(args)) {
			return;
		}
		
		if(Object.isArray(args)) {
			for(var i = 0; i < args.length; i++) {
				if(Object.isString(args[i])) {
					args[i] = unescape(args[i]);
				} else {
					this._descapeResponse(args[i]);
				}
			}
		} else if(Object.isHash(args)) {
			args.keys().each(function(key) {
				if(Object.isString(args.get(key))) {
					args.set(key, unescape(args.get(key)));
				} else {
					this._descapeResponse(args.get(key));
				}
			}.bind(this));
		} else {
			for(var key in args) {
				if(Object.isString(args[key])) {
					args[key] = unescape(args[key]);
				} else {
					this._descapeResponse(args[key]);
				}
			}
		}
	}
});

/**
 * @class behaviour.gui.error.NoFlash
 * @extends behaviour.gui.error.FatalError
 */
behaviour.gui.error.NoFlash = new Class.create(behaviour.gui.error.FatalError, {
	/**
	 * @param {mixed} options
	 * @example	
	 * Supports the following options:
	 * 
	 * options: {
	 * 		showChrome: boolean						// Whether to be draggable, show close window button, etc
	 * }
	 * 
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.height = 200;
		options.noReload = true;
		
		$super(options);
		
		this.addClass("NoFlash");
	},
	
	getMessage: function() {
		var documentFragment = document.createDocumentFragment();
		documentFragment.appendChild(DOMUtil.createTextElement("p", Language.get("bbq.gui.error.NoFlash.noflash")));
		documentFragment.appendChild(DOMUtil.createTextElement("a", Language.get("bbq.gui.error.NoFlash.installflash"), {href: "http://www.adobe.com/go/getflashplayer", className: "NoFlash_flashLink"}));
		
		return documentFragment;
	}
});

/**
 * Uses the SWFObject library to wrapper an embedded flash movie.
 * @class behaviour.web.FlashEmbed
 * @extends behaviour.gui.GUIWidget 
 */
behaviour.web.FlashEmbed = new Class.create(behaviour.gui.GUIWidget, {
	
	_flashObject: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Supports the following options:
	 * 
	 * options {
	 * 		swf: {
	 * 			path: string,					// Path to the flash movie
	 * 			id: string,						// The ID of the flash movie node - this must be specified
	 * 			width: int,						// Width of the flash movie
	 * 			height: int,						// Height of the flash movie
	 * 			flashVars: {					// Variables to pass to the movie in key: value pairs
	 * 				key: value,
	 * 				...
	 * 			}
	 * 		}
	 * 		
	 * }
	 * 
	 * Supports the following events:
	 * 
	 * onLoad
	 */
	initialize: function($super, options) {
		$super(options);
		
		if(Object.isUndefined(this.options.swf)) {
			this.options.swf = {};
		}
		
		if(Object.isUndefined(this.options.swf.flashVars)) {
			this.options.swf.flashVars = {};
		}
		
		this.options.swf.id += "_" + BehaviourUtil.generateGUID().replace(/-/g, "");
		
		if(typeof(behaviour.web.FlashEmbed.instances[this.options.swf.id]) != "undefined") {
			Log.warn("Duplicate flash movie in page");
		}
		
		behaviour.web.FlashEmbed.instances[this.options.swf.id] = this;
		
		this._flashObject = false;
		
		if(options.swf.path.search(/\?/) == -1) {
			options.swf.path += "?nocache=" + BehaviourUtil.generateGUID();
		} else {
			options.swf.path += "&nocache=" + BehaviourUtil.generateGUID();
		}
	},
	
	loaded: function() {
		return this._flashObject ? true : false;
	},
	
	/**
	 * @param {Node} node
	 */
	appendTo: function(node) {
		var so = new SWFObject(this.options.swf.path, this.options.swf.id, this.options.swf.width, this.options.swf.height, this.options.swf.version ? this.options.swf.version : 9);
		so.addParam("allowScriptAccess", "always");
		so.addParam("swliveconnect", "true");
		
		if(this.options.transparent) {
			so.addParam("wmode", "transparent");
		}
		
		if(this.options.swf.flashVars instanceof Object) {
			//Log.info("Setting flashVars on SWFObject");
			for(var key in this.options.swf.flashVars) {
				so.addVariable(key, this.options.swf.flashVars[key]);
			}
		}
		
		// pass pageObject id to Flash movie so it can call methods on us
		so.addVariable("pageObject", this.options.swf.id);
		
		var div = DOMUtil.createElement("div");
		so.write(div);
		
		// if there are no children of the div, this normally means Flash is not installed - prompt the user to install it
		if(!div.firstChild) {
			var errorNotification = new behaviour.gui.error.NoFlash();
			errorNotification.appear();
		} else {
			node.appendChild(div.firstChild);
			
			this.rootNode = div.firstChild;
		}
	},
	
	/**
	 * @private
	 */
	_loaded: function() {
		//Log.info("Getting flash object from DOM with ID " + this.options.swf.id);
		
		if(!this._flashObject) {
			if($(this.options.swf.id)) {
				this._flashObject = $(this.options.swf.id);
				Log.info("notifying onLoad listeners");
				this.notifyListeners("onLoad");
			} else {
				Log.info("DOM node not loaded yet");
				setTimeout(this._loaded.bind(this), 500);
			}
		}
	},
	
	/**
	 * @param {string} methodName
	 * @param {Object} args
	 */
	callFlashFunction: function(methodName, args) {
		//Log.info("Calling flash function " + methodName + " with args " + Object.toJSON(args));
		
		if(!this._flashObject) {
			Log.warn("method call on flashObject that does not exist (" + methodName + ")");
			
			if($(this.options.swf.id)) {
				Log.warn("Flash object is in the page though");
				this._flashObject = $(this.options.swf.id);
			}
		}
		
		if(this._flashObject[methodName]) {
			//Log.info("Found method " + methodName + " on Flash object - " + typeof(this._flashObject[methodName]));
			if(args) {
				return this._flashObject[methodName](args);
			}
			
			return this._flashObject[methodName]();
		}
		
		Log.warn("Could not find method " + methodName + " on Flash object");
	},
	
	getOption: function(key) {
		return this.options[key];
	}
});

behaviour.web.FlashEmbed.instances = {};
/**
 * @class behaviour.lang.DataHolder
 */
behaviour.lang.DataHolder = new Class.create({
	
	_objectArray: null,
	_arrayIndexes: null,
	options: null,
	
	/**
	 * @param {Object} options
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		entities: Array		Entities to pre-populate with
	 * 		entityKey: String	Name of property or method that should be accessed to return a unique ID for each entity
	 * }
	 */
	initialize: function(options) {
		this.options = options ? options : {};
		this._objectArray = [];
		this._arrayIndexes = {};
		
		if(this.options.entities && this.options.entities instanceof Array) {
			this.options.entities.each(function(entity) {
				this.addElement(entity);
			}.bind(this));
		}
	},
	
	/**
	 * @return {integer} number of elements in object array
	 */
	getLength: function() {
		return this._objectArray.length;
	},
	
	setLength: function(num) {
		this._objectArray.length = num;
		this._syncArray();
	},
	
	/**
	 * @param {mixed} by	An array index or a GUID
	 */
	getElement: function(by) {
		if(BehaviourUtil.isGUID(by)) {
			by = this.indexOf(by);
		}
		
		return this._objectArray[by];
	},
	
	/**
	 * @param {mixed} object	An object or a GUID
	 * @return {integer}
	 */
	indexOf: function(object) {
		if(!BehaviourUtil.isGUID(object)) {
			object = BehaviourUtil.getKey(object, this.options.entityKey);
		}
		
		return this._arrayIndexes["index-" + object];
	},
	
	_put: function(object, index) {
		this._arrayIndexes["index-" + BehaviourUtil.getKey(object, this.options.entityKey)] = index;
	},
	
	/**
	 * Places the passed object at the specified index
	 * 
	 * @param {integer} index
	 * @param {Object} object
	 */
	setElement: function(index, object) {
		this._objectArray[index] = object;
		
		// try to store item
		if(BehaviourUtil.getKey(object, this.options.entityKey)) {
			this._put(object, index);
		}
		
		return object;
	},
	
	/**
	 * @return {Array} array of elements
	 */
	getElements: function() {
		return this._objectArray;
	},
	
	/**
	 * @param {Object} element
	 */
	addElement: function(element) {
		return this.addElementAtIndex(element, this._objectArray.length);
	},
	
	/**
	 * @param {Object} element
	 * @param {integer} index
	 */
	addElementAtIndex: function(element, index) {
		//Log.info(index);
		this._objectArray[index] = element;
		this._put(element, index);
		
		return element;
	},
	
	/**
	 * Removes the passed entity
	 * 
	 * @param {mixed} An element of the same type contained in this list or a GUID
	 */
	remove: function(object) {
		var entityKey = BehaviourUtil.getKey(object, this.options.entityKey);
		
		for(var i = 0; i < this._objectArray.length; i++) {
			if(BehaviourUtil.getKey(this._objectArray[i], this.options.entityKey) == entityKey) {
				this._objectArray.splice(i, 1);
				//delete this._arrayIndexes["index-" + entityKey];
				i--;
			}
		}
		
		this._syncArray();
	},
	
	/**
	 * removes all elements
	 */
	clear: function() {
		this._objectArray.splice(0, this._objectArray.length);
		this._arrayIndexes = {};
	},
	
	/**
	 * Updates the internal shortcut array
	 */
	_syncArray: function() {
		this._arrayIndexes = {};
		
		for(var i=this._objectArray.length-1; i>=0; i--) {
			this._put(this._objectArray[i], i);
		}
	}
});

/**
 * @class deadline.entities.DeadlineEntity
 * @extends behaviour.lang.Watchable
 */
deadline.entities.DeadlineEntity = new Class.create(behaviour.lang.Watchable, {
		
	id: null,
	options: null,
	_data: null,
	_dataLoaded: null,
	_partialLoad: null,
	_loadedFields: null,
	_retrieveURL: null,
	_propertyDisplays: null,
	_propertyDisplayCleanupInterval: null,
	_loadingData: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.options = options ? options : {};
		this._data = {};
		this._propertyDisplays = new Hash();
		this._loadedFields = new Hash();
		
		this.processData(this.options.data);
	},
	
	/**
	 * Should return an object similar to the data structure of this class.
	 * 
	 * The object should contain properties that mirror the output of getArray() in the PHP on the server.
	 * @private
	 * @return {Object}
	 */
	_getDefaultObject: function() {
		return {
			id: false
		}
	},
	
	/**
	 * Sets properties on this object and creates getters/setters for accessing them
	 * 
	 * Also used by child classes to replace IDs with references to the actual objects
	 * 
	 * @param	{Object}	data
	 * @return	void
	 */
	processData: function(data) {
		if(data && data instanceof Object) {
			this.id = data.id;
			
			var defaultObject = this._getDefaultObject();
			
			for(var key in data) {
				// skip fields not defined on this object - this way we do not end up with erroneous getters and setters
				if(typeof(defaultObject[key]) == "undefined") {
					Log.warn("skipping " + key + " on object loading data from " + this._retrieveURL);
					continue;
				}
				
				var camel = BehaviourUtil.capitalize(key);
				
				if(this["set" + camel] instanceof Function) {
					this["set" + camel](data[key]);
				} else {
					//Log.info("creating " + camel);
					this["get" + camel] = (new Function("return this._get(\"" + key + "\");")).bind(this);
					this["set" + camel] = (new Function("this._set(\"" + key + "\", arguments[0]);")).bind(this);
				
					this["set" + camel](data[key]);
				}
				
				this._loadedFields.set(key, true);
			}
			
			this._partialLoad = false;
			
			// start delete me later
			var missingProperties = [];
			
			// ensure we have loaded all of our properties
			for(var key in defaultObject) {
				if(typeof(data[key]) == "undefined") {
					missingProperties.push(key);
				}
			}
			
			if(missingProperties.length > 0) {
				Log.warn(this._retrieveURL + " missing properties " + missingProperties.join(", "));
			}
			// end delete me later
			
			// ensure we have loaded all of our properties
			for(var key in defaultObject) {
				if(Object.isUndefined(data[key])) {
					this._dataLoaded = false;
					this._partialLoad = true;
					
					// missing at least one property, get out of loop
					break;
				}
			}
			
			var keys = Object.keys(data);
			
			if(keys.length == 1 &&  keys[0] == "id") {
				this.loadData();
			} else if(!this._partialLoad) {			
				this._dataLoaded = true;
			}
		}
	},
	
	dataLoaded: function() {
		return this._dataLoaded === true;
	},
	
	/**
	 * Makes an entity load it's data.
	 * 
	 * Register for listener "onDataLoaded" to interact with this object after data has been loaded.
	 * 
	 * @return void
	 */
	loadData: function() {
		if(this._loadingData) {
			return;
		}
		
		this._loadingData = true;
		
		if(!this._retrieveURL) {
			var className = '';
			
			for(var key in deadline.entities) {
				if(this instanceof deadline.entities[key]) {
					className = "deadline.entities." + key;
				}
			}
			
			Log.error("DeadlineEntity " + className + " must specify where to load data from");
			return;
		}
		
		this._dataLoaded = false;
		this._partialLoad = false;
	
		new behaviour.ajax.JSONRequest({
			url: this._retrieveURL, 
			args: {id: this.getId()}, 
			onSuccess: this._loadedData.bind(this), 
			method: "post"
		});
	},
	
	/**
	 * @return void
	 */
	_loadedData: function(serverResponse, json) {
		try {
			this._loadingData = false;
			
			this.processData(json);
			
			if(this.dataLoaded()) {
				this.notifyListeners("onDataLoaded");
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * {@inheritDoc}
	 */
	registerListener: function(type, callback) {
		var callbackKey = behaviour.lang.Watchable.prototype.registerListener.apply(this, arguments);
		
		if(type == "onDataLoaded") {
			if(this.dataLoaded()) {
				// if the callback is onDataLoaded and we've already loaded our data, call the callback immediately
				this.notifyListener(type, callbackKey, [this]);
			} else {
				// otherwise trigger data load
				this.loadData();
			}
		}
		
		return callbackKey;
	},
	
	/**
	 * @private
	 * @param	{String}	key
	 * @return	{mixed}
	 */
	_get: function(key) {
		//Log.info("returning " + this._data[key] + " for key " + key);
		return typeof(this._data[key]) != "undefined" ? this._data[key] : null;
	},
	
	/**
	 * @private
	 * @param	{String}	key
	 * @param	{mixed}	value
	 */
	_set: function(key, value) {
		this._data[key] = value;
		
		// update property displays for this property
		// set a timeout so that all the properties on this object have been updated by the time the first propertyDisplay update occurs
		setTimeout(this._updatePropertyDisplays.bind(this, key), 500);
		
		return this._data[key];
	},
	
	/**
	 * Returns the unique identifier of this object, a GUID
	 * 
	 * @return	{String} 
	 */
	getID: function() {
		return this.id;
	},
	
	equals: function(deadlineEntity) {
		if(BehaviourUtil.isGUID(deadlineEntity)) {
			return this.getId() == deadlineEntity;
		}
		return deadlineEntity && deadlineEntity.getId && this.getID() == deadlineEntity.getId();
	},
	
	/**
	 * @param	String		property		A property on this object
	 */
	getProperty: function(property) {
		try {
			if(property.indexOf(".") != -1) {
				property = "" + property.split(".", 1);
			}
			
			if(this["get" + BehaviourUtil.capitalize(property)] instanceof Function) {
				return this["get" + BehaviourUtil.capitalize(property)]();
			}
		} catch(e) {
			Log.error("getProperty threw a wobbly on " + property + " " + this._createURL);
			Log.error("this.get" + BehaviourUtil.capitalize(property) + " = " + this["get" + BehaviourUtil.capitalize(property)]);
			Log.dumpException(e);
			Log.dumpObject(this);
		}
	},
	
	/**
	 * Returns a DOM element (by default a SPAN) that contains a textual representation of the requested property of this element.
	 * 
	 * Will be updated automatically to contain the current value.
	 * 
	 * Supports getting properties of sub objects.  For example, if we want the name of this objects's creator, we can do:
	 * 
	 * <code>
	 * object.getPropertyDisplay({property: "creator.fullname"});
	 * </code>
	 * 
	 * This will have the same effect as:
	 * 
	 * <code>
	 * var creator = object.getCreator();
	 * creator.getPropertyDisplay({property: "fullname"});
	 * </code>
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		property: String			// The name of the property that is to be displayed
	 * 		formatter: Function		// Optional.  A function that takes the property value as an argument and returns a String or a Node
	 * 		createNode: Function	// Optional.  Should return a DOM node.  Omit this to use a SPAN.  If passed you should also pass a function for updateNode
	 * 		updateNode: Function // Optional.  Expect two arguments - a node and the property value.  Return nothing.  If passed you should also pass a function for createNode
	 * }
	 * 
	 * @param	Object			options
	 */
	getPropertyDisplay: function(options) {
		try {
			if(options.property.indexOf(".") != -1) {
				// pass request on to child object
				var parts = options.property.split(".");
				var myProperty = parts.shift();
				
				var object = this.getProperty(myProperty)
				
				options.property = parts.join(".");
				
				if(object) {
					// object is valid, pass the request on
					return object.getPropertyDisplay(options);
				} else {
					// an attempt to call a function on a child object that has not been set.  return a placeholder
					var node = options.createNode instanceof Function ? options.createNode() : DOMUtil.createElement("span");
					
					if(options.formatter) {
						var value = options.formatter(null);
						
						if(value) {
							DOMUtil.append(value, node);
						}
					}
					
					return node;
				}
			}
			
			var propertyDisplay = {
				node: options.createNode instanceof Function ? options.createNode() : DOMUtil.createElement("span"),
				formatter: options.formatter,
				property: options.property,
				updateNode: options.updateNode
			};
			
			if(this["get" + BehaviourUtil.capitalize(options.property)] instanceof Function) {
				// we've loaded our data already, update current property displays
				this._updatePropertyDisplay(propertyDisplay);
			} else {
				// ensure that this property display will be updated
				this.registerOneTimeListener("onDataLoaded", function() {
					this._updatePropertyDisplay(propertyDisplay);
				}.bind(this));
				
				// if this object is partially loaded and requested property has not been loaded yet, trigger loading of this objects data
				if(this._partialLoad && !this._loadedFields.get(options.property)) {
					Log.info("Partially loaded object triggering loadData");
					this.loadData();
				}
			}
			
			// create array for the requested property
			if(!this._propertyDisplays.get(options.property)) {
				this._propertyDisplays.set(options.property, []);
			}
			
			// add it to our list of property diplays
			this._propertyDisplays.get(options.property).push(propertyDisplay);
			
			// clean up previously created property displays that are no longer in the DOM
			this._cleanUpPropertyDisplays();
			
			// return the node for addition to the DOM
			return propertyDisplay.node;
		} catch(e) {
			Log.error("Exception thrown while trying to retrieve property display " + this._createURL);
			Log.dumpObject(options);
			Log.dumpException(e);
		}
	},
	
	/**
	 * Loops through all existing property displays and updates them.
	 * 
	 * @private
	 */
	_updatePropertyDisplays: function(property) {
		if(this._propertyDisplays.get(property)) {
			this._propertyDisplays.get(property).each(function(displayProperty) {
				this._updatePropertyDisplay(displayProperty);
			}.bind(this));
		}
	},
	
	/**
	 * Updates stored property displays to contain the current value as known by this object
	 * 
	 * @private
	 */
	_updatePropertyDisplay: function(propertyDisplay) {
		DOMUtil.emptyNode(propertyDisplay.node);
		
		var value = this.getProperty(propertyDisplay.property);
		
		if(propertyDisplay.formatter instanceof Function) {
			value = propertyDisplay.formatter(value);
		}
		
		if(propertyDisplay.updateNode instanceof Function) {
			propertyDisplay.updateNode(propertyDisplay.node, value);
		} else {
			if(!value) {
				value = " ";
			}
			
			// default action is to treat node as if it is a SPAN
			if(Object.isString(value)) {
				var theText = value.split("\n");
				
				for(var i = 0; i < theText.length; i++) {
					propertyDisplay.node.appendChild(document.createTextNode(theText[i]));
					
					if(theText.length > 1 && i != (theText.length - 1)) {
						propertyDisplay.node.appendChild(document.createElement("br"));
					}
				}
			} else {
				DOMUtil.append(value, propertyDisplay.node);
			}
		}
	},
	
	/**
	 * Loops through all stored property displays, removing any references to nodes that have been removed from the DOM
	 * 
	 * @private
	 */
	_cleanUpPropertyDisplays: function() {
		if(this._propertyDisplayCleanupInterval) {
			clearInterval(this._propertyDisplayCleanupInterval);
		}
		
		// set an interval to allow whatever rendering action that is currently underway to complete
		// use interval instead of timeout so that we only do this once
		this._propertyDisplayCleanupInterval = setInterval(function() {
			this._propertyDisplays.keys().each(function(key) {
				for(var i = 0; i < this._propertyDisplays.get(key).length; i++) {
					if(!DOMUtil.isInDOM(this._propertyDisplays.get(key)[i].node)) {
						// element has been removed from DOM, delete our reference
						this._propertyDisplays.get(key).splice(i, 1);
						i--;
					}
				}
			}.bind(this));
			
			clearInterval(this._propertyDisplayCleanupInterval);
		}.bind(this), 1000);
	}
});


/**
 * @class deadline.entities.CreatedEntity
 * @extends deadline.entities.DeadlineEntity
 */
deadline.entities.CreatedEntity = new Class.create(deadline.entities.DeadlineEntity, {
	
	_createURL: null,
	_updateURL: null,
	_deleteURL: null,
	_newEntity: false,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		id: String					// the GUID of this object
	 * 		data: Object				// The data to create this entity from.  If omitted, a new entity will be created
	 * 		
	 * }
	 */
	initialize: function($super, options) {
		if(typeof(options) == "undefined") {
			options = {};
		}
		
		if(typeof(options.data) == "undefined") {
			options.data = this._getDefaultObject();
			options.newEntity = true;
			this._newEntity = true;
			this._dataLoaded = true;
		} else {
			this._newEntity = false;
		}
		
		$super(options);
	},
	
	_getDefaultObject: function() {
		return Object.extend({
			createdBy: null,
			creationDate: new Date(),
			lastmodifieddate: new Date(),
			lastmodifiedby: null,
			canedit: true,
			archived: false
		}, deadline.entities.DeadlineEntity.prototype._getDefaultObject.call(this));
	},
	
	/**
	 * Returns true if this entity is newly created
	 * 
	 * @return boolean
	 */
	isNew: function() {
		return this._newEntity;
	},
	
	/**
	 * Takes a collection of data (an Object or Prototype Hash) and posts it to the URL specified by the _createURL or _updateURL properties defined on this object
	 * 
	 * @param	{mixed}	data		An Object or Prototype Hash.  Should have key:pair values that reflect the properties of this object
	 */
	saveData: function(data) {
		try {
			if(!this.isNew()) {
				data.id = this.getId();
			}
			// ensure that we don't send any entity objects to the server, send their IDs instead
			if(data instanceof Hash) {
				data.keys().each(function(key) {
					if(data.get(key) && data.get(key).getId) {
						data.set(key, data.get(key).getId());
					}
				});
			} else {
				for(var key in data) {
					if(data[key] && data[key].getId) {
						data[key] = data[key].getId();
					}
				}
			}
			
			Log.info("Dumping data");
			//Log.dumpObject(data);
			// create the request
			new behaviour.ajax.JSONRequest({
				url: this.isNew() ? this._createURL : this._updateURL, 
				args: data, 
				onSuccess: function(serverResponse, json) {
					var wasNew = this.isNew();
					this._newEntity = false;
					
					try {
						var multiple = false;
						
						if(json instanceof Array) {
							multiple = json;
							json = json[0];
						}
						
						this.processData(json);
						
						if(wasNew) {
							if(multiple) {
								this.notifyListeners("onMultipleEntitiesCreated", multiple);
							} else {
								this.notifyListeners("onCreate");
							}
						} else {
							this._propertyDisplays.keys().each(function(property) {
								this._updatePropertyDisplays(property);
							}.bind(this));
							
							this.notifyListeners("onUpdate");
						}
					} catch(e) {
						Log.dumpException(e);
					}
				}.bind(this), 
				method: "post"
			});
		} catch(e) {
			NotificationArea.setError("Error", e);
			Log.dumpException(e);
			throw e;
		}
	},
	
	/**
	 * Creates appropriate getters and setters on data passed.
	 * @param {Object} data A tuple from the database
	 */
	processData: function($super, data) {
		$super(data);
		
		if(this._data.lastmodifiedby && BehaviourUtil.isGUID(this._data.lastmodifiedby)) {
			this._data.lastmodifiedby = currentPage.getEntity(this._data.lastmodifiedby, "staff", "Staff");
		}
	},
	
	/**
	 * @return {Object} Returns a creator of an object
	 */
	getCreator: function() {
		return currentPage.getEntity(this._data.createdBy, "staff", "Staff");
	},
	
	/**
	 * Returns whether or not the current user can edit this story
	 * 
	 * @return	{boolean}
	 */
	canEdit: function() {
		return this._data.canedit == true;
	},
	
	deleteEntity: function() {
		new behaviour.ajax.JSONRequest({
			url: this._deleteURL, 
			args: {id: this.getId()}, 
			onSuccess: function() {
				this.notifyListeners("onDelete");
			}.bind(this), 
			method: "post"
		});
	}
});

/**
 * @class deadline.entities.User
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.User = new Class.create(deadline.entities.CreatedEntity, {
	_retrieveURL: "/backend/user/get",
	
	/**
	 * Constructor
	 * @param	{Object} options An options object
	 */
	initialize: function($super, options) {
		$super(options);
	},
	
	_getDefaultObject: function() {
		return {
			id: false,
			title: "",
			fullname: "",
			firstname: "",
			lastname: "",
			username: "",
			desks: [],
			country: "",
			editorOnDesks: [],
			preferences: {},
			permissions: {}
		};
	},
	
	/**
	 * Creates appropriate getters and setters on data passed.
	 * @param {Object} data A tuple from the database
	 */
	processData: function($super, data) {
		$super(data);
		
		if(this._data.desks) {
			for(var i = 0; i < this._data.desks.length; i++) {
				this._data.desks[i] = currentPage.getEntity(this._data.desks[i], "desks", "Desk");
			}
		}
		
		if(this._data.editorOnDesks) {
			for(var i = 0; i < this._data.editorOnDesks.length; i++) {
				this._data.editorOnDesks[i] = currentPage.getEntity(this._data.editorOnDesks[i], "desks", "Desk");
			}
		}
	},
	
	/**
	 * @param	{String}	key
	 * @return	{String}	Will be the requested value or null
	 */
	getPreference: function(key) {
		return typeof(this._data.preferences[key]) != "undefined" ? this._data.preferences[key] : null;
	},
	
	/**
	 * @param {String} key
	 * @param {String} value
	 */
	setPreference: function(key, value) {
		this._data.preferences[key] = value;
		
		new behaviour.ajax.JSONRequest({
			url: "/backend/preferences/set", 
			args: {"key": key, "value": value},
			method: "post"
		});
	},
	
	/**
	 * @return {Array} Returns an array of desk titles
	 */
	getDeskTitles: function() {
		var output = {};
		
		this.getDesks().each(function(desk) {
			output[desk.getId()] = desk.getTitle();
		});
		
		return output;
	},
	
	getDeskIDs: function() {
		var output = [];
		
		this.getDesks().each(function(desk) {
			output.push(desk.getId());
		});
		
		return output;
	},
	
	/**
	 * @return {boolean} Will return true if the current user is an editor on at least one desk
	 */
	isDeskEditor: function() {
		//TODO: Enforce story creation ACL 
		return this.getEditorOnDesks().length > 0;
	},
	
	hasPermission: function(key, entity) {
		var entityKey =  BehaviourUtil.getKey(entity);
		
		if(!(this.getPermissions()[entityKey] instanceof Array)) {
			this.getPermissions()[entityKey] = [];
		}
		
		return this.getPermissions()[entityKey].indexOf(key) != -1;
	}
});

deadline.entities.Organisation = new Class.create(deadline.entities.CreatedEntity,{
	_createURL: "/backend/organisation/create",
	_retrieveURL: "/backend/organisation/get",
	_updateURL: "/backend/organisation/update",
	_deleteURL: "/backend/organisation/delete",
	
	/**
	 * Constructor
	 * @param {Object} options An options object.
	 */
	initialize: function($super, options) {
		$super(options);
	},
	
	_getDefaultObject: function() {
		return {
			id: false,
			name: "",
			type: 0,
			language: 0,
			dateformat: 0,
			theme: "",
			country: null
		};
			
		return object;
	}
});

/**
 * 
 * GUIButton
 * 
 * This class creates a standards compliant button that should be used in conjunction with a ButtonHolder object.  It
 * is based around the HTML list element an contains an anchor tag.
 * 
 * @class behaviour.gui.button.GUIButton
 * @extends behaviour.gui.GUIWidget
 * 
 */
behaviour.gui.button.GUIButton = Class.create(behaviour.gui.GUIWidget, {
	_index: 0,
	_anchor: null,
	disabled: false,
	buttonHolder: null,
	buttonIsDown: false,
	
	/**
	 * Constructor!
	 * 
	 * Supports the following options: 
	 * options: {
	 * 		buttonText: String,
	 * 		startDisabled: boolean,
	 * 		startDown: boolean,
	 * 		rememberDownState: boolean,
	 * 		toggleButton: boolean,
	 * 		onclick: Function,
	 * 		onmouseout: Function,
	 * 		onmouseover: Function,
	 * 		onmousedown: Function,
	 * 		onmouseup: Function
	 * }
	 * @param {mixed} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("li");
		this.addClass("GUIButton");
		
		this._anchor = DOMUtil.createTextElement("a", (this.options.buttonText ? this.options.buttonText : " "), {
			href: this.options.anchor ? this.options.anchor : ".", 
			title: (this.options.toolTip ? this.options.toolTip : "")
		});
		
		this.appendChild(this._anchor);
		
		if(this.options.startDisabled) {
			this.setDisabled(true);
		} else {
			this.setDisabled(false);
		}
		
		if(this.options.startDown) {
			this.setDown(true);
		} else {
			this.setDown(false);
		}
		
		this._anchor.onclick = this.buttonClicked.bindAsEventListener(this);
		this._anchor.onmouseout = this.mouseOut.bindAsEventListener(this);
		this._anchor.onmouseover = this.mouseOver.bindAsEventListener(this);
		this._anchor.onmousedown = this.mouseDown.bindAsEventListener(this);
		this._anchor.onmouseup = this.mouseUp.bindAsEventListener(this);
	},
	
	getAnchor: function() {
		return this._anchor;
	},
	
	/**
	 * Button clicked handler function
	 * @param {Event} event
	 */
	buttonClicked: function(event) {
		if(event && this.options.onclick) {
			Event.stop(event);
		}
		
		BehaviourUtil.clearFocus(event);
		
		if(this._processCallback("onclick", event)) {
			if(this.buttonHolder) {
				this.buttonHolder._buttonClicked(this, event);
				this.buttonHolder.clearDown();
			}
			
			if(this.options.rememberDownState) {
				this.setDown(true);
			}
			
			if(this.options.toggleButton) {
				this.setDown(this.buttonIsDown);
			}
		}
		
		if(this.options.onclick) {
			return false;
		}
	},
	
	/**
	 * Mouse out handler function
	 * @param {Event} event
	 */
	mouseOut: function(event) {
		if(!this.disabled) {
			this.removeClass("buttonOver");
			this._processCallback("onmouseout", event);
		}
	},
	
	/**
	 * Mouse over handler function
	 * @param {Event} event
	 */
	mouseOver: function(event) {
		if(!this.disabled) {
			this.addClass("buttonOver");
			this._processCallback("onmouseover", event);
		}
	},
	
	/**
	 * Mouse down handler function
	 * @param {Event} event
	 */
	mouseDown: function(event) {
		if(!this.disabled) {
			this.addClass("buttonDown");
			this._processCallback("onmousedown", event);
		}
	},
	
	/**
	 * Mouse up handler function
	 * @param {Event} event
	 */
	mouseUp: function(event) {
		if(!this.disabled) {
			this.removeClass("buttonDown");
			this._processCallback("onmouseup", event);
		}
	},
	
	/**
	 * @private
	 * Calls any callback method if defined and the button is enabled.
	 * 
	 * @return	boolean	true if we were able to callback, false otherwise
	 * @type mixed
	 */
	_processCallback: function(callback, event) {
		try {
			if(!this.disabled && this.options[callback] && this.options[callback] instanceof Function) {
				var output = this.options[callback].call(this, event, this);
				
				this.notifyListeners(callback, event);
				
				if(typeof(output) == "undefined") {
					return true;
				}
				
				return output;
			}
		} catch(e) {
			Log.dumpException(e);
		}
		
		return false;
	},
	
	/**
	 * Down state setter
	 * @param {boolean} down
	 */
	setDown: function(down) {
		this.buttonIsDown = down;
		
		if(this.buttonIsDown) {
			if(this.buttonHolder) {
				this.buttonHolder.clearDown();
				this.buttonHolder.setSelectedIndex(this.getIndex());
			}
	
			this.addClass("buttonDown");
		} else {
			this.removeClass("buttonDown");
		}
	},
	
	/**
	 * Clears button down state
	 */
	clearDown: function() {
		this.removeClass("buttonDown");
	},
	
	/**
	 * Checks if button is down.
	 * @return {boolean}
	 */
	isDown: function() {
		return this.buttonIsDown;
	},
	
	/**
	 * Button disabled status setter
	 * @param {boolean} disabled
	 */
	setDisabled: function(disabled) {
		this.disabled = disabled;
		this[(this.disabled ? "add" : "remove") + "Class"]("buttonDisabled");
		this[(this.disabled ? "remove" : "add") + "Class"]("buttonEnabled");
	},
	
	isDisabled: function() {
		return this.disabled;
	},
	
	/**
	 * sets the function to call on click event
	 * @param {Function} callback
	 */
	setOnClick: function(callback) {
		this.options["onclick"] = callback;
	},
	
	/**
	 * Button index getter.
	 * @return {integer}
	 */
	getIndex: function() {
		return this._index;
	},
	
	/**
	 * Button index setter
	 * @param {integer} index
	 */
	setIndex: function(index) {
		this._index = index;
	},
	
	setText: function(text) {
		DOMUtil.emptyNode(this._anchor);
		this.anchor.appendChild(document.createTextNode(text));
	}
});

/**
 * @class deadline.entities.Desk
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Desk = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/desks/create",
	_retrieveURL: "/backend/desks/get",
	_updateURL: "/backend/desks/update",
	_deleteURL: "/backend/desks/delete",
	
	/**
	 * Constructor
	 * @param	{Object}	options	An options object.
	 */
	initialize: function($super, options) {
		$super(options);
	},
	
	_getDefaultObject: function() {
		return {
			id: false,
			title: "",
			description: "",
			canedit: true,
			numStaff: 0/*,
			instance: null*/
		};
	}
});

/**
 * @class deadline.entities.Role
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Role = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/roles/create",
	_retrieveURL: "/backend/roles/get",
	_updateURL: "/backend/roles/update",
	_deleteURL: "/backend/roles/delete",
	
	/**
	 * Constructor
	 * @param {Object} options An options object.
	 */
	initialize: function($super, options) {
		$super(options);
	},
	
	_getDefaultObject: function() {
		return {
			id: false,
			description: null,
			canedit: true
		};
	}
});
/**
 * @class behaviour.date.DateFormat
  */
behaviour.date.DateFormat = new Class.create({
	_getString: function(options) {
		var now = new Date();
		
		if(options.withStrings) {
			if(options.date.getFullYear() == now.getFullYear() && 
					options.date.getMonth == now.getMonth() && 
					options.date.getDay() == now.getDay()) {
				return Language.get("bbq.date.DateFormat.today");
			}
			
			var modDate = new Date(options.date.getTime() - 86400000);
			
			if(modDate.getFullYear() == now.getFullYear() && 
					modDate.getMonth == now.getMonth() && 
					modDate.getDay() == now.getDay()) {
				return Language.get("bbq.date.DateFormat.tomorrow");
			}
			
			modDate = new Date(options.date.getTime() + 86400000);
			
			if(modDate.getFullYear() == now.getFullYear() && 
					modDate.getMonth == now.getMonth() && 
					modDate.getDay() == now.getDay()) {
				return Language.get("bbq.date.DateFormat.yesterday");
			}
		}
		
		return false;
	},
	
	getDateSeparator: function() {
		return this._dateSeparator;
	},
	
	getTimeSeparator: function() {
		return this._timeSeparator;
	},
	
	getLongDate: function(options) {
		var string = this._getString(options);
		
		return (string ? string : this._getDate(options)) + " " + this._getTime(options);
	},

	getShortDate: function(options) {
		var string = this._getString(options);
		
		return (string ? string : this._getDate(options));
	},
	
	_getTime: function(options) {
		return options.date.getHours() + this._timeSeparator + (options.date.getMinutes() < 10 ? "0" : "") +  options.date.getMinutes();
	}
});

/**
 * @class behaviour.date.DateFormat0 represents UK dates
 * @extends behaviour.date.DateFormat
 * 
 */
behaviour.date.DateFormat0 = new Class.create(behaviour.date.DateFormat, {
	_dateSeparator: "/",
	_timeSeparator: ":",
	
	_getDate: function(options) {
		return options.date.getDate() + this._dateSeparator + (options.date.getMonth() + 1) + this._dateSeparator + options.date.getFullYear();
	},
	
	getOrder: function(options) {
		if(options.shortDate) {
			return ["Day", "DateSeparator", "Month", "DateSeparator", "Year"];
		}
		
		return ["Day", "DateSeparator", "Month", "DateSeparator", "Year", "BreakableSpace", "Hour", "TimeSeparator", "Minute"];
	}
});

/**
 * @class behaviour.date.DateFormat1 represents US dates
 * @extends behaviour.date.DateFormat
 * 
 */
behaviour.date.DateFormat1 = new Class.create(behaviour.date.DateFormat, {
	_dateSeparator: "/",
	_timeSeparator: ":",
	
	_getDate: function(options) {
		return (options.date.getMonth() + 1) + this._dateSeparator + options.date.getDate() + this._dateSeparator + options.date.getFullYear();
	},
	
	getOrder: function(options) {
		if(options.shortDate) {
			return ["Month", "DateSeparator", "Day", "DateSeparator", "Year"];
		}
		
		return ["Month", "DateSeparator", "Day", "DateSeparator", "Year", "BreakableSpace", "Hour", "TimeSeparator", "Minute"];
	}
});

/**
 * @class behaviour.date.DateFormat1 represents US dates
 * @extends behaviour.date.DateFormat
 * 
 */
behaviour.date.DateFormat2 = new Class.create(behaviour.date.DateFormat, {
	_dateSeparator: ".",
	_timeSeparator: ":",
	
	_getDate: function(options) {
		return options.date.getDate() + this._dateSeparator + (options.date.getMonth() + 1) + this._dateSeparator + options.date.getFullYear();
	},
	
	getOrder: function(options) {
		if(options.shortDate) {
			return ["Day", "DateSeparator", "Month", "DateSeparator", "Year"];
		}
		
		return ["Day", "DateSeparator", "Month", "DateSeparator", "Year", "BreakableSpace", "Hour", "TimeSeparator", "Minute"];
	}
});

/**
 * @class behaviour.date.DateFormat1 represents US dates
 * @extends behaviour.date.DateFormat
 * 
 */
behaviour.date.DateFormat3 = new Class.create(behaviour.date.DateFormat, {
	_dateSeparator: "-",
	_timeSeparator: ":",
	
	_getDate: function(options) {
		return options.date.getFullYear() + this._dateSeparator + (options.date.getMonth() + 1) + this._dateSeparator + options.date.getDate();
	},
	
	getOrder: function(options) {
		if(options.shortDate) {
			return ["Year", "DateSeparator", "Month", "DateSeparator", "Day"];
		}
		
		return ["Year", "DateSeparator", "Month", "DateSeparator", "Day", "BreakableSpace", "Hour", "TimeSeparator", "Minute"];
	}
});

/**
 * @class behaviour.date.DateFormat1 represents US dates
 * @extends behaviour.date.DateFormat
 * 
 */
behaviour.date.DateFormat4 = new Class.create(behaviour.date.DateFormat, {
	_dateSeparator: " ",
	_timeSeparator: ":",
	
	getLongDate: function(options) {
		var offset = options.date.getTimezoneOffset()/60;
		
		if(offset > 0) {
			if(offset > 9) {
				offset = "+" + offset + "00";
			} else {
				offset = "+0" + offset + "00";
			}
		} else if(offset < 0) {
			if(offset < -9) {
				offset = "-" + Math.abs(offset) + "00";
			} else {
				offset = "-0" + Math.abs(offset) + "00";
			}
		} else {
			offset = "+0000";
		}
		
		return Language.get("bbq.date.DateFormat4.days" + options.date.getDay()).substr(0, 3) + ", " + this._getDate(options) + " " + this._getTime(options) + " " + offset;
	},
	
	getShortDate: function(options) {
		var string = this._getString(options);
		
		return (string ? string : this._getDate(options));
	},
	
	_getDate: function(options) {
		return options.date.getDate() + this._dateSeparator + Language.get("bbq.date.DateFormat4.months" + options.date.getMonth()).substr(0, 3) + this._dateSeparator + options.date.getFullYear();
	},
	
	getOrder: function(options) {
		if(options.shortDate) {
			return ["Year", "DateSeparator", "Month", "DateSeparator", "Day"];
		}
		
		return ["Year", "DateSeparator", "Month", "DateSeparator", "Day", "BreakableSpace", "Hour", "TimeSeparator", "Minute"];
	}
});

/**
 * @class deadline.gui.web.Broadcaster
 * @extends behaviour.web.FlashEmbed
 */
deadline.web.Broadcaster = new Class.create(behaviour.web.FlashEmbed, {
	
	_connected: null,
	
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options = {
			swf: {
				path: "/swf/Broadcaster.swf",
				id: "Broadcaster",
				width: 1,
				height: 1
			},
			transparent: true,
			server: ServerConfig.broadcast_server
		};
		
		$super(options);
		
		if(ServerConfig.rtmp_server == "none") {
			return;
		}
		
		this._connected = false;
		
		var serverError = false;
		
		this.registerListener("onConnectSuccess", function() {
			if(serverError) {
				NotificationArea.setMessage(Language.get("deadline.web.Broadcaster.updateserver"), Language.get("deadline.web.Broadcaster.reconnected"));
				serverError = false;
			}
			
			this._connected = true;
		}.bind(this));
		
		this.registerListener("onConnectionClosed", function() {
			NotificationArea.setError(Language.get("deadline.web.Broadcaster.updateserver"), Language.get("deadline.web.Broadcaster.lostconnection"));
			serverError = true;
			this._connected = false;
		}.bind(this));
		
		this.registerListener("onAuthenticationFaliure", function() {
			serverError = true;
			this._connected = false;
		}.bind(this));
		
		this.registerListener("onConnectAttempt", function() {
			this._connected = false;
		}.bind(this));
		
		this.registerListener("onConnectAborted", function() {
			NotificationArea.setError(Language.get("deadline.web.Broadcaster.updateserver"), Language.get("deadline.web.Broadcaster.noconnection"));
			serverError = true;
			this._connected = false;
		}.bind(this));
	},
	
	appendTo: function(node) {
		if(ServerConfig.rtmp_server == "none") {
			return;
		}
		
		behaviour.web.FlashEmbed.prototype.appendTo.call(this, node);
	},
	
	callLocalMethod: function(callerId, objectType, objectID, method, args) {
		if(typeof(args) == "undefined") {
			Log.warn("no arguments set");
			args = [];
		} else if(!(args instanceof Array)) {
			Log.error("Invalid argument type " + typeof(args) + " = " + args);
			return;
		}
		
		var dataHolder = currentPage[objectType];
		
		if(!dataHolder) {
			Log.warn("Cannot call method " + method + " on object type "+ objectType + " as dataholder does not exist on this page");
			return;
		}
		
		if(typeof(objectID) != "undefined") {
			var objects = [dataHolder.getElement(objectID)];
		} else {
			var objects = dataHolder.getElements();		
		}
		
		Log.info("Invoking " + method + " on " + objects.length + " objects with args " + args);
		objects.each(function(object) {
			if(!(object[method] instanceof Function)) {
				Log.error("Invalid method name " + method + " on object type " + objectType);
				return;
			}
			
			object[method].apply(object, args);
		});
	},
	
	callLocalFunction: function(callerId, functionName, args) {
		if(typeof(args) == "undefined") {
			Log.warn("no arguments set");
			args = [];
		} else if(!(args instanceof Array)) {
			Log.error("Invalid argument type " + typeof(args) + " = " + args);
			return;
		}
		
		var object = window;
		var funcName = functionName;
		
		if(functionName.search(/\./)) {
			var parts = functionName.split(/\./);
			funcName = parts.pop();
			
			for(var i = 0; i < parts.length; i++) {
				object = object[parts[i]];
			}
		}
		
		Log.info("Invoking " + functionName + " with args " + args);
		
		if(!(object[funcName] instanceof Function)) {
			Log.error("Invalid function name " + functionName);
			return;
		}
		
		object[funcName].apply(object, args);
	},
	
	isConnected: function() {
		return this._connected;
	}
});

/**
 * A panel with two and only two child panels
 * @class behaviour.gui.panel.DualPanel
 * @extends behaviour.gui.panel.Panel
 * 
 */
behaviour.gui.panel.DualPanel  = new Class.create(behaviour.gui.panel.Panel, {
	_panel1Name: null,
	_panel2Name: null,
	
	/**
	 * @param {Object} options
	 * 
	 * Supports the following options: 
	 * 
	 * options: {
	 * 		panel1: behaviour.gui.panel.Panel
	 * 		panel2: behaviour.gui.panel.Panel
	 * }
	 */
	initialize: function(options) {
		// call parent method
		behaviour.gui.panel.Panel.prototype.initialize.apply(this, arguments);
		
		this.addClass("DualPanel");
		
		this._panel1Name = "panel1";
		this._panel2Name = "panel2";
		
		if(this.options.panel1) {
			this.setPanel1(this.options.panel1);
		}
		
		if(this.options.panel2) {
			this.setPanel2(this.options.panel2);
		}
		
		if(this.options.direction == "horizontal") {
			this.addClass("DualPanel_Horizontal");
		} else {
			this.addClass("DualPanel_Vertical");
		}
	},
	
	setPanel1: function(content, panelName) {
		if(!content) {
			content = new behaviour.gui.panel.Panel();
		}
		
		DOMUtil.addClass(content, "DualPanel1");
		
		if(this.options.direction == "horizontal") {
			DOMUtil.addClass(content, "DualPanel_Horizontal_DualPanel1");
		} else {
			DOMUtil.addClass(content, "DualPanel_Vertical_DualPanel1");
		}
		
		if(typeof(panelName) != "undefined") {
			this._panel1Name = panelName;
		}
		
		this._setChildPanel(this._panel1Name, content);
		
		return content;
	},
	
	getPanel1: function() {
		return this._getChildPanel(this._panel1Name);
	},
	
	setPanel2: function(content, panelName) {
		if(!content) {
			content = new behaviour.gui.panel.Panel();
		}
		
		DOMUtil.addClass(content, "DualPanel2");
		
		if(this.options.direction == "horizontal") {
			DOMUtil.addClass(content, "DualPanel_Horizontal_DualPanel2");
		} else {
			DOMUtil.addClass(content, "DualPanel_Vertical_DualPanel2");
		}
		
		if(typeof(panelName) != "undefined") {
			this._panel2Name = panelName;
		}
		
		this._setChildPanel(this._panel2Name, content);
		
		return content;
	},
	
	getPanel2: function() {
		return this._getChildPanel(this._panel2Name);
	},
	
	render: function() {
		this.empty();
		
		try {
			this.appendChild(this.getPanel1());
			this.appendChild(this.getPanel2());
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	replacePanel: function($super, oldPanel, newPanel) {
		var oldName = this._getPanelName(oldPanel);
		
		$super(oldPanel, newPanel);
		
		if(oldName == this._panel1Name) {
			this.setPanel1(newPanel);
		} else if(oldName == this._panel2Name) {
			this.setPanel2(newPanel);
		}
	}
});

/**
 * @class behaviour.gui.LoadingNotification
 * @extends behaviour.gui.GUIWidget 
 */
behaviour.gui.LoadingNotification = new Class.create(behaviour.gui.GUIWidget, {
	/**
	 * @param {mixed} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("p");
		this.addClass("LoadingNotification");
		
		if(typeof(this.options.text) == "undefined") {
			this.options.text = Language.get("bbq.gui.LoadingNotification.loading");
		}
	},
	
	/**
	 * Renders
	 */
	render: function() {
		this.empty();
		this.appendChild(this.options.text);
	}
});

/**
 * A panel with two and only two child panels
 * @class behaviour.gui.panel.ScrollableHolder
 * @extends behaviour.gui.panel.Panel
 */
behaviour.gui.panel.ScrollableHolder  = new Class.create(behaviour.gui.panel.Panel, {
	_scrollTop: 0,
	
	/**
	 * @param {mixed} options
	 * @example
	 * supports the following callbacks:
	 * 
	 * onScroll
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("ScrollableHolder");
		this.getRootNode().onscroll = this._onscroll.bindAsEventListener(this);
		this.registerListener("onWillResize", this._onWillResize.bind(this));
		this.registerListener("onResize", this._onResize.bind(this));
		
		if(this.options.contents) {
			this.appendChild(this.options.contents);
		}
		
		this.registerListener("onBeforeRemoveFromDOM", function() {
			this._scrollTop = this.getScrollTop();
			//Log.info("ScrollableHolder removed from DOM scrollTop" + this._scrollTop);
		}.bind(this));
	},
	
	_onscroll: function(event) {
		this.notifyListeners("onScroll");
	},
	
	/**
	 * If we have been scrolled downwards, store the old scroll value.
	 */
	_onWillResize: function(event) {
		Log.info('onWillResize scrollTop = ' + this.getScrollTop());
		if(this.getScrollTop() > 0) {
			this._scrollTop = this.getScrollTop();
		}
	},
	
	/**
	 * When we are removed from the DOM tree, our scrollTop becomes 0, so if we've previously been
	 * scrolled down, restore the old scroll value.
	 */
	_onResize: function(event) {
		if(this.getScrollTop() == 0 && this._scrollTop > 0) {
			this.setScrollTop(this._scrollTop);
			// blank the old value so we don't jump around unexpectedly
			this._scrollTop = 0;
		}
		if(typeof(this._scrollTop) == 'undefined') {
			this._scrollTop = 0;
		}
		//Log.info('onResize called in ScrollableHolder scrollTop = '+this._scrollTop);
	},
	
	appendChild: function(childNode) {
		behaviour.gui.panel.Panel.prototype.appendChild.call(this, childNode);
		
		if(childNode && childNode.setScrollableHolder instanceof Function) {
			childNode.setScrollableHolder(this);
			/*
			var scrollTop;
			
			childNode.registerListener("onBeforeSelectedEntityChange", function() {
				scrollTop = this.getScrollTop();
				Log.info("stored scrollTop " + scrollTop);
			}.bind(this));
			childNode.registerListener("onAfterSelectedEntityChange", function() {
				this.setScrollTop(scrollTop);
			}.bind(this));*/
		}
		
		return childNode;
	},
	
	getScrollTop: function() {
		//Log.info('getScrollTop = ' + this.getRootNode().scrollTop);
		return this.getRootNode().scrollTop;
	},
	
	setScrollTop: function(scrollTop) {
		//Log.info('setScrollTop = ' + scrollTop);
		return this.getRootNode().scrollTop = scrollTop;
	},
	
	appendTo: function(node) {
		behaviour.gui.panel.Panel.prototype.appendTo.apply(this, arguments);
		
		if(this._scrollTop > 0) {
			this.setScrollTop(this._scrollTop);
		}
	}
});

/**
 * @class behaviour.gui.SortableGUIWidget
 * @extends behaviour.gui.panel.Panel 
 */
behaviour.gui.SortableGUIWidget = new Class.create(behaviour.gui.GUIWidget, {
	_currentSortKey: null,
	
	sortIt: function(event) {
		
	},
	
	ascSortFunction: function (a, b) {
		var aValue = (a[this._currentSortKey] instanceof Function ? a[this._currentSortKey].call(a, a) : a[this._currentSortKey]);
		var bValue = (b[this._currentSortKey] instanceof Function ? b[this._currentSortKey].call(b, b) : b[this._currentSortKey]);
		
		if(aValue == null && bValue) {
			return 1;
		} else if(aValue && bValue == null) {
			return -1;
		} else if(aValue == null && bValue == null) {
			return 0;
		}
		
		if(typeof(aValue) != "undefined") {
			if(aValue === true || aValue === false) {
				return this.sortBool(aValue, bValue);
			} else if(aValue instanceof Array) {
				return this.sortArray(aValue, bValue)
			} else if(aValue.toLowerCase) {
				return this.sortString(aValue, bValue);
			} else {
				return aValue - bValue;
			}
		} else {
			var key = this._currentSortKey.split(".");
			
			try {
				if(aValue === true || aValue === false) {
					return this.sortBool(aValue, bValue);
				} else if(a[key[0]][key[1]] instanceof Array) {
					return this.sortArray(a[key[0]][key[1]], b[key[0]][key[1]])
				} else if(a[key[0]][key[1]].toLowerCase) {
					return this.sortString(a[key[0]][key[1]], b[key[0]][key[1]]);
				} else {
					return a[key[0]][key[1]] - b[key[0]][key[1]];
				}
			} catch(e) {
				Log.warn("Error thrown while using " + key + " as a sort field");
				Log.warn("a :");
				Log.dumpObject(a);
				Log.warn("b :");
				Log.dumpObject(b);
				Log.dumpException(e);
				throw e;
			}
		}
	},
	
	descSortFunction: function (a, b) {
		var aValue = (a[this._currentSortKey] instanceof Function ? a[this._currentSortKey].call(a, a) : a[this._currentSortKey]);
		var bValue = (b[this._currentSortKey] instanceof Function ? b[this._currentSortKey].call(b, b) : b[this._currentSortKey]);
		
		if(aValue == null && bValue) {
			return -1;
		} else if(aValue && bValue == null) {
			return 1;
		} else if(aValue == null && bValue == null) {
			return 0;
		}
		
		if(typeof(aValue) != "undefined") {
			if(aValue === true || aValue === false) {
				return this.sortBool(bValue, aValue);
			} else if(aValue instanceof Array) {
				return this.sortArray(bValue, aValue)
			} else if(aValue.toLowerCase) {
				return this.sortString(bValue, aValue);
			} else {
				return bValue - aValue;
			}
		} else {
			var key = this._currentSortKey.split(".");
			
			try {
				if(aValue === true || aValue === false) {
					return this.sortBool(bValue, aValue);
				} else if(a[key[0]][key[1]] instanceof Array) {
					return this.sortArray(b[key[0]][key[1]], a[key[0]][key[1]])
				} else if(a[key[0]][key[1]].toLowerCase) {
					return this.sortString(b[key[0]][key[1]], a[key[0]][key[1]]);
				} else {
					return b[key[0]][key[1]] - a[key[0]][key[1]];
				}
			} catch(e) {
				Log.warn("Error thrown while using " + key + " as a sort field");
				Log.warn("a :");
				Log.dumpObject(a);
				Log.warn("b :");
				Log.dumpObject(b);
				Log.dumpException(e);
				throw e;
			}
		}
	},
	
	sortString: function(a, b, asc) {
		if(b.toLowerCase() > a.toLowerCase()) {
			return (asc ? -1 : 1);
		} else if(b.toLowerCase() < a.toLowerCase()) {
			return (asc ? 1 : -1);
		} else {
	 		return 0;
	 	}
	},
	
	sortBool: function(a, b) {
		if(a == b) {
			return 0;
		} else if(a) {
			return -1;
		} else {
	 		return 1;
	 	}
	},
	
	sortArray: function(a, b) {
		if(b.length > a.length) {
			return -1;
		} else if(b.length < a.length) {
			return 1;
		} else {
	 		return 0;
	 	}
	}
});

/**
 * @class behaviour.gui.ScrollLoadGUIWidget
 * @extends behaviour.gui.GUIWidget 
 */
behaviour.gui.ScrollLoadGUIWidget = new Class.create(behaviour.gui.GUIWidget, {
	
	_scrollableHolder: null,
	_lastRange: null,
	_scrollingTimeout: null,
	_numEntities: null,
	_initialLoad: null,
	_loading: null,
	_entities: null,
	_callbacks: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * The URL passed as part of the options object should return in the following format:
	 * 
	 *  { numEntities: int, entities: {"en7": data, "en8": data, "en9": data,...}}     // <-  enN is zero indexed!
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		rowHeight: int								// roughly the expected height of one row.
	 * 		createEntity: function(data)		// should return one new entity
	 * 		url: String										// where to load from
	 * 		args: Object									// arguments to pass
	 * 		numToLoad: int							// how many entities to load initially and on every column sort
	 * 		loadingText: String						// shown while doin the inital load
	 * 		noEntitiesText:	String					// shown when there is nothing to show
	 * 		entityKey: String							// the key field on each entity.  Pass this OR getEntityKey
	 * 		getEntityKey: Function					// should take an entity and return it's id Pass this OR entityKey
	 * }
	 * 
	 * Supports observers for the following events
	 * 
	 * onEntitiesLoad
	 * onEmptyList
	 * onEntitiesLoaded
	 * onSelectedEntityChange
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("ScrollLoadGUIWidget");
		this._lastRange = {start: 0, end: 0};
		
		if(typeof(this.options.args) == "undefined") {
			this.options.args = {};
		}
		
		if(typeof(this.options.startSorted) != "undefined") {
			this.options.args.sortBy = parseInt(this.options.startSorted.column);
			this.options.args.sortDirection = this.options.startSorted.direction == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC ? foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC : foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC;
			this.options.args.includeArchived = false;
		} else {
			this.options.args.sortBy = 0;
			this.options.args.sortDirection = foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC;
			this.options.args.includeArchived = false;
		}
		
		this._entities = new behaviour.lang.DataHolder({entityKey: this.options.entityKey});
		this._loading = false;
		this._initialLoad = true;
		
		this._callbacks = {};
	},
	
	_getEntityKey: function(entity) {
		if(this.options.getEntityKey) {
			return this.options.getEntityKey(entity);
		}
		
		return BehaviourUtil.getKey(entity, this.options.entityKey);
	},
	
	_storeCallback: function(entity, action, callback) {
		if(!(callback instanceof Function)) {
			return;
		}
		
		var key = this._getEntityKey(entity);
		
		if(typeof(this._callbacks[key]) == "undefined") {
			this._callbacks[key] = {};
		}
		
		this._callbacks[key][action] = callback;
	},
	
	_processEvent: function(event, entity) {
		BehaviourUtil.clearFocus(event);
		this._invokeCallback(entity, event.type);
		
		if(FocusWatcher) {
			FocusWatcher.setKeypressCallbackObject(this);
		}
		
		return false;
	},
	
	_invokeCallback: function(entity, action) {
		try {
			var key = this._getEntityKey(entity);
			
			if(this._callbacks[key] && this._callbacks[key][action] instanceof Function) {
				// only set the item down if the callback does not return false
				var result = this._callbacks[key][action](entity);
				
				if(result !== false) {
					this.setDown(entity);
				}
				
				return result;
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	setDown: function(entity) {
		this.notifyListeners("onSelectedEntityChange");
	},
	
	/**
	 * Set the scrollable that holds this widget.  This is necessary so we can watch it to find out when we should try to reload the 
	 * data contained within ourselves.
	 */
	setScrollableHolder: function(scrollableHolder) {
		this._scrollableHolder = scrollableHolder;
		this._scrollableHolder.registerListener("onScroll", function() {
			this._scrollableScrolled();
		}.bind(this));
		this._scrollableHolder.registerListener("onResize", function() {
			this._scrollableScrolled();
		}.bind(this));
	},
	
	/**
	 * Returns the scrollable holder that contains this widget
	 */
	getScrollableHolder: function() {
		return this._scrollableHolder;
	},
	
	/**
	 * @protected
	 * 
	 * Callback for when the containing scrollable is scrolled.
	 */
	_scrollableScrolled: function() {
		if(this._scrollingTimeout) {
			clearTimeout(this._scrollingTimeout);
		}
		
		this._scrollingTimeout = setTimeout(this._workOutMovement.bind(this), 500);
	},
	
	/**
	 * @protected
	 * 
	 * Override this method in your subclass.  It should work out which elements (loaded or not) 
	 * are currently visible and call:
	 * 
	 * this._loadDetails(startElement, endElement);
	 * 
	 * Where the arguments to _loadDetails are their indexes in the _entities array
	 */
	_workOutMovement: function() {	
		Log.error("Non overriden call to ScrollLoadGUIWidget._workOutMovement");
	},
	
	_loadDetails: function(start, end) {
		try {
			if(this._scrollingTimeout) {
				clearTimeout(this._scrollingTimeout);
			}
			
			//Log.info("passed " + start + " to " + end);
			if(typeof(start) == "undefined" || start  < 0) {
				start = 0;
			}
			
			if(start > end) {
				start = end - 1;
			}
			
			var needLoad = false;
			
			if(this._initialLoad) {
				needLoad = true;
			} else {
				//Log.info("checking " + start + " to " + end + " of " + this._entities.length);
				
				// see which entities we need to load data for
				for(var i = start; i <= end; i++) {
					if(!this._entities.getElement(i)) {
						//Log.info("item " + i + " triggered load");
						needLoad = true;
						break;
					}
				}
			}
			
			if(!this._loading && needLoad) {
				this.options.args["entityOffset"] = start;
				this.options.args["entityLength"] = end - start;
				
				new behaviour.ajax.JSONRequest({
					url: this.options.url, 
					args: this.options.args,
					onSuccess: this._loadedDetails.bind(this), 
					method: "post"
				});
				
				this._loading = true;
				
				this.notifyListeners("onEntitiesLoad");
			} else {
				this.notifyListeners("onAllEntitiesLoadedAlready");
			}
		} catch(e) {
			Log.dumpException(e);	
		}
	},
	
	dataLoaded: function() {
		if(this._initialLoad) {
			return false;
		}
		
		return !this._loading;
	},
	
	_loadedDetails: function(serverResponse, json) {
		try {
			this._loading = false;
			this._initialLoad = false;
			var numEntities = json.numEntities;
			if(!(json.entities instanceof Array)) {
				if(this._entities.getLength() != numEntities) {
					if(numEntities > this._entities.getLength()) {
						// pad the array
						for(var i = numEntities-1; i >= 0; i--) {
							if(typeof(this._entities.getElement(i)) == "undefined") {
								this._entities.setElement(i, false);
							}
						}
					} else {
						// truncate list
						this._entities.setLength(numEntities);
					}
				}
				
				this._processNewEntities(json);
			}
			
			this.render();
			
			this.notifyListeners("onEntitiesLoaded");
			
			if(this._entities.getLength() == 0) {
				this.notifyListeners("onEmptyList");
			}
		} catch(e) {
			Log.warn("thrown _loadedDetails");
			Log.dumpException(e);
		}
	},
	
	_processNewEntities: function(json) {
		var entities = json.entities;
		for(var key in entities) {
			var index = parseInt(key.replace("en", ""));
					
			if(this.options.createEntity) {
				this._entities.setElement(index, this.options.createEntity(entities[key], index));
			} else {
				this._entities.setElement(index, entities[key]);
			}
		}
	},
	
	appendTo: function(pageNode) {
		behaviour.gui.GUIWidget.prototype.appendTo.apply(this, arguments);
		clearTimeout(this._scrollingTimeout);
		this._scrollingTimeout = setTimeout(this._workOutMovement.bind(this), 1000);
	},
	
	/**
	 * Loads the entities currently visible in the viewport if they have not been loaded already
	 */
	loadEntities: function() {
		clearTimeout(this._scrollingTimeout);
		this._workOutMovement();
	},
	
	/**
	 * Empties the list of currently loaded entities and reloads the entities currently visible in the viewport.
	 * 
	 * Use this method if the order of items has been changed.
	 */
	reloadEntities: function() {
		this._entities.clear();
		this._initialLoad = true;
		this.render();
		this._workOutMovement();
	},
	
	getFirstEntity: function() {
		return this._entities.getElement(0);
	},
	
	getNumEntities: function() {
		return this._entities.getLength();
	},
	
	/**
	 * Sorts the entity set by the given index and direction.
	 * 
	 * @param {int} index
	 * @param {int} direction
	 */
	sortByIndex: function(index, direction) {
		direction = 0 + direction;
		this.options.args.sortBy = parseInt(index);
		this.options.args.sortDirection = parseInt(direction) == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC ? foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC : foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC;
		this.reloadEntities();
		return false;
	},
	
	setSearchTerm: function(newTerm) {
		this.options.args.searchTerm = newTerm;
	}
});

/**
 * @class behaviour.gui.table.ScrollLoadTable
 * @extends behaviour.gui.ScrollLoadGUIWidget 
 */
behaviour.gui.table.ScrollLoadTable = new Class.create(behaviour.gui.ScrollLoadGUIWidget, {
	_headerHeight: 0,
	_tableHead: null,
	_tableBody: null,
	_table: null,
	_selectedIndex: 0,
	_selectedKey: null,
	
	/**
	 * A table that loads data from somewhere. 
	 * 
	 * The URL passed as part of the options object should return in the following format:
	 * 
	 *  { numEntities: int, entities: {"en7": data, "en8": data, "en9": data,...}}     // <-  enN is zero indexed!
	 * 
	 * @param	Object		options					Options for the whole table
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		rowHeight: int																	// roughly the expected height of one row.
	 * 		createEntity: function(data, index)								// should return one new entity
	 * 		url: String																			// where to load from
	 * 		args: Object																		// arguments to pass to the url
	 * 		loadingText: String															// shown while doin the inital load
	 * 		noEntitiesText:	String														// shown when there is nothing to show
	 * 		defaultActionColumn: int												// the index of the column who's onclick handler should be invoked when the user keypresses over the rows
	 * 		columnData = [{
	 * 			text: function(entity, index, cell, ScrollLoadTable)	// Should return either a string, a node or a GUIButton
	 * 			shorten: int																	// The maximum length of the field value - nb. this will only be applied if a string is returned from text()
	 * 			sortField: boolean														// If we should allow sorting by this column
	 * 			ignoreDownState: bool												// Will not set the down state for the row if a link in this column is clicked
	 * 			onclick: function(entity)												// Invoked if the text is clicked
	 * 			ondblclick: function(entity)										// Invoked if the text is double clicked
	 * 			className: function(entity)										// Should return a string or null to get added as a CSS class to the td element
	 * 			
	  * 	}, {...}, {...}]
	 * }
	 * 
	 * N.B. The down state referred to below means that a specified tr element will have a CSS class titled "down" applied to it.
	 * 
	 * Supports observers for the following events
	 * 
	 * onEntitiesLoad
	 * onEmptyList
	 * onEntitiesLoaded
	 * onSort
	 * onBeforeSort
	 * onAfterSort
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("ScrollLoadTable");
		this._table = DOMUtil.createElement("table", {className: "ScrollLoadTable"});
		
		if(this.options.headerRows) {
			this._tableHead = this._table.appendChild(DOMUtil.createElement("thead"));
		}
		
		if(typeof(this.options.defaultActionColumn) == "undefined") {
			this.options.defaultActionColumn = 0;
		}
		
		this._tableBody = this._table.appendChild(DOMUtil.createElement("tbody"));
		
		this._selectedIndex = -1;
		this._selectedKey = false;
	},
	
	/**
	 * Parses through the entity list and creates the table
	 */
	render: function() {
		var scrollTop = 0;
		
		if(this._scrollableHolder) {
			scrollTop = this._scrollableHolder.getScrollTop();
		}
		
		this.empty();
		
		var eLength = this._entities.getLength();
		
		if(this._initialLoad == true) {
			// show loading text
			this.appendChild(new behaviour.gui.LoadingNotification({text: this.options.loadingText}));
		} else if(eLength == 0) {
			// show "no items" type notification
			this.appendChild(DOMUtil.createTextElement("p", this.options.noEntitiesText, {className: "ScrollLoadTableEmptyList"}));
		} else {
			try {	
				// create header rows
				if(this.options.headerRows) {
					DOMUtil.emptyNode(this._tableHead);
					this._tableHead.appendChild(DOMUtil.createTextElement("tr", this._generateHeaderRows()));
				}
				
				DOMUtil.emptyNode(this._tableBody);
				
				// create one row for each entity
				for(var i = 0; i < eLength; i++) {
					this._tableBody.appendChild(this._generateRow(i, this._entities.getElement(i)));
				}
				
				// add style to last row
				if(eLength > 0) {
					DOMUtil.addClass(this._tableBody.childNodes.item(this._tableBody.childNodes.length - 1), "lastRow");
				}
				
				this.appendChild(this._table);
			} catch(e) {
				Log.dumpException(e);
			}
		}
		
		if(this._scrollableHolder) {
			this._scrollableHolder.setScrollTop(scrollTop);
		}
	},
	
	_generateHeaderRows: function() {
		var cells = [];
		
		for(var i = 0; i < this.options.headerRows.length; i++) {
			var cell = document.createElement("th");
			
			if(!this.options.columnData[i]["sortField"] || typeof(this.options.columnData[i]["sortField"]) == "undefined") {
				// not a header that the data is supposed to be sortable by
				cell.appendChild(document.createTextNode(this.options.headerRows[i]));
			} else {
				// create link that when clicked sorts the table
				var anchor = DOMUtil.createTextElement("a", this.options.headerRows[i], {href: ".", onclick: this.sortByIndex.bind(this, i, this.options.args.sortDirection == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC ? foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC : foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC)});
							
				// are we currently sorted by this header?
				if(this.options.args.sortBy == i) {
					DOMUtil.addClass(anchor, "sortedBy" + ((this.options.args.sortDirection == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC) ? "DESC" : "ASC"));
				}
				
				cell.appendChild(anchor);
			}
			
			if(this.options.columnData[i] && this.options.columnData[i]["iconColumn"]) {
				DOMUtil.addClass(cell, "iconColumnHeader");
			}
			// add cell to row
			cells.push(cell);
		}
		
		return cells;
	},
	
	_generateRow: function(index, entity) {
		var row = document.createElement("tr");
		
		if(!entity) { // invalid item
			row = this._handleInvalidItem(row, index);
		} else if(this.options.createRow instanceof Function) { // custom item
			row = this.options.createRow(row, entity, index);
			row.owningEntity = entity;
		} else { // create row from column data
			row = 	this._handleValidItem(row, index, entity);
			
			if(this.isSelectedEntity(entity)) {
				DOMUtil.addClass(row, "down");
			}
		}
		
		if(index % 2 == 0) {
			DOMUtil.addClass(row, "oddRow");
		} else {
			DOMUtil.addClass(row, "evenRow");
		}
		
		return row;
	},
	
	_handleValidItem: function(row, rowIndex, entity) {
		var cData = this.options.columnData;
		
		for(var n = 0, nCount=this.options.columnData.length; n < nCount; n++) { // process one entity (eg. one row)
			var cell = row.appendChild(DOMUtil.createElement("td", {className: "column" + n}));
			
			if(this.options.columnData[n].iconColumn) {
				DOMUtil.addClass(cell, "ScrollLoadTableIconColumn");
			}
			
			if(!(this.options.columnData[n].text instanceof Function)) {
				Log.error("Please pass an instance of Function to ScrollLoadTable to generate cell text");
				return;
			}
			
			var cellContent = this.options.columnData[n].text(entity, n, cell, this);
			
			if(cellContent) {
				if(cellContent.appendTo) {
					// passed GUIWidget
					cellContent.appendTo(cell);
				} else {
					// passed text
					if(this.options.columnData[n].onclick || this.options.columnData[n].ondblClick) {
						// make text clickable
						var link = DOMUtil.createTextElement("a", cellContent, {
							href: ".",
							onclick: this._processEvent.bindAsEventListener(this, entity),
							ondblclick: this._processEvent.bindAsEventListener(this, entity)
						});
						
						if(Object.isElement(cellContent)) {
							Event.observe(cellContent, "click", function() {
								link.blur();
								return true;
							});
						}
						
						cellContent = link;
						
						if(this.options.columnData[n].onclick) {
							this._storeCallback(entity, "click", this.options.columnData[n].onclick.bind(this, entity));
						}
						
						if(this.options.columnData[n].ondblclick) {
							this._storeCallback(entity, "dblclick", this.options.columnData[n].ondblclick.bind(this, entity));
						}
					}
					
					if(Object.isString(cellContent)) {
						cellContent = document.createTextNode(cellContent);
					}
					
					cell.appendChild(cellContent);
				}
			
				if(this.options.columnData[n]["className"]) {
					var className;
					
					if(className = this.options.columnData[n]["className"](entity)) {
						//Log.info("custom class " + className);
						DOMUtil.addClass(cellContent, className);
					}
				}
			}
		}
		return row;
	},
	
	/**
	 * Sets the down state on the row containing the passed element
	 * 
	 * @param	{mixed}	object	Either an entity contained within this table or an ID
	 */
	setDown: function(entity) {
		this.notifyListeners("onBeforeSelectedEntityChange");
		if(!entity) {
			this.clearDown();
		} else {
			var index = this._entities.indexOf(entity);
			
			if(index != this._selectedIndex) {
				this.clearDown();
				this._selectedIndex = index;
				this._selectedKey =  this._getEntityKey(entity);
				
				var rows = $A(this._tableBody.getElementsByTagName("tr"));
				DOMUtil.addClass(rows[this._selectedIndex], "down");
				
				behaviour.gui.ScrollLoadGUIWidget.prototype.setDown.call(this, entity);
			}
		}
		this.notifyListeners("onAfterSelectedEntityChange");
	},
	
	/**
	 * Removes the down state from all table rows
	 */
	clearDown: function() {
		this._selectedIndex = -1;
		this._selectedKey = false;
		DOMUtil.removeClass(this.getRootNode(), "down", true);
	},
	
	acceptFocus: function() {
		this.addClass("hasFocus");
	},
	
	loseFocus: function() {
		this.removeClass("hasFocus");
	},
	
	processKeypress: function(event) {
		var nextEntity = false;
		
		// process keypress
		if(event.keyCode == Event.KEY_DOWN) {
			nextEntity = this._entities.getElement(this._selectedIndex + 1);
		} else if(event.keyCode == Event.KEY_UP) {
			nextEntity = this._entities.getElement(this._selectedIndex - 1);
		}
		
		if(nextEntity) {
			this.setDown(nextEntity);
			this._invokeCallback(nextEntity, "click");
		}
		
		return true;
	},
	
	isSelectedEntity: function(entity) {
		if(this._selectedKey && entity) {
			return this._selectedKey ==  this._getEntityKey(entity);
		}
		
		return false;
	},
	
	_handleInvalidItem: function(row, index) {
		row.appendChild(DOMUtil.createTextElement("td", new behaviour.gui.LoadingNotification(), {className: "column0", colSpan: this.options.columnData.length, style: {height: this.options.rowHeight + "px"}}));
		return row;
	},
	
	getHeaderHeight: function() {
		if(this.getRootNode().getElementsByTagName("thead")[0]) {
			return Element.getHeight(this.getRootNode().getElementsByTagName("thead")[0]);
		}
		
		return 0;
	},
	
	_workOutMovement: function() {	
		if(this._scrollingTimeout) {
			clearTimeout(this._scrollingTimeout);
		}
		
		// if we've no scrollableholder, we won't know how many to load
		if(!this._scrollableHolder) {
			return;
		}
		
		var offset = this._scrollableHolder.getRootNode().scrollTop - this.getHeaderHeight();
		
		if(offset < 0) {
			offset = 0;
		}
		
		// div height or table height if not scrolling
		var visibleHeight = Element.getHeight(this._scrollableHolder.getRootNode());
		
		if(visibleHeight == 0) {
			return;
		}
		
		var startRow = Math.floor(offset/this.options.rowHeight);
		var endRow = startRow + Math.floor(visibleHeight/this.options.rowHeight);
		
		if(this._lastRange.start != startRow || this._lastRange.end != endRow || this._initialLoad === true || this._forceLoad) {
			this._lastRange.start = startRow;
			this._lastRange.end = endRow;
			
			// load missing details
			//Log.info("calling loadDetails for rows " + (startRow) + " to " + (endRow + 1) + " this._forceLoad = " + this._forceLoad);
			this._loadDetails(startRow, endRow + 1);
		}
	}
});

/**
 * SortableTable
 * 
 * @class behaviour.gui.table.SortableTable This class allows creation of tables displaying lists of data.
 * @extends behaviour.gui.SortableGUIWidget 
 */
behaviour.gui.table.SortableTable = new Class.create(behaviour.gui.SortableGUIWidget, {
	_tableHead: null,
	_callBacks: null,
	_boundCallBacks: null,
	_selectedElementID: null,
	sortedByColumnIndex: null,
	sortedByDirection: null,
	_selectedEntity: null,
	
	/**
	 * @param	Object		options					Options for the whole table
	 * @example
	 * It supports the following options:
	 * 
	 * options = {
	 * 		entities: Array								An array of objects to build the table from	
	 * 		entityID: String								The name of the id field of the objects above
	 * 		listItemsKey: String						Use object field with the passed name as entities
	 * 		startSorted: {
	 * 			column:	int				Which column to sort by - default 0
	 * 			direction : string	Sort direction: default ASC
	 * 		},
	 * 		columnData = [{
	 * 			text: mixed								Either a string which references a property on the current entity or a function that conforms to function(entity, index) and returns a Node
	 * 			shorten: int								The maximum length of the field
	 * 			sortField: string						The name of the object property to sort this column by.  Omit for a non-sortable column.
	 * 			ignoreDownState: bool			Will not set the down state for the row if a link in this column is clicked
	 * 	}, {...}, {...}]
	 * }
	 * 
	 * N.B. The down state referred to below means that a specified tr element will have a CSS class titled "down" applied to it.
	 * 
	 * Functions attached to onclick and ondblclick should return false to prevent their row from becoming selected.
	 * 
	 * onSort
	 * onBeforeSort
	 * onAfterSort
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("table");
		
		// steal styling from ScrollLoadTable
		this.addClass("ScrollLoadTable");
		
		this.addClass("SortableTable");
		
		this._callBacks = {};
		this.options.entityID = this.options.entityID ? this.options.entityID : "id";
		
		if(this.options.entities) {
			if(this.options.entities.getElements) {
				this.options.entities = this.options.entities.getElements();
			}
		} else {
			this.options.entities = [];
		}
		
		this._selectedEntity = {
			row: false,
			entity: false
		};
		
		this._boundCallBacks = {
			onclick: this._itemClicked.bindAsEventListener(this),
			ondblclick: this._itemDoubleClicked.bindAsEventListener(this)
		}
	},
	
	/**
	  Overrides ancestor method in order to sort data after the ancestor method calls render();
	 */
	appendTo: function($super, pageNode) {
		$super(pageNode);
		
		if(this.options.startSorted) {
			if(this.options.startSorted.direction) {
				this.sortedByDirection = this.options.startSorted.direction == "DESC" ? "ASC" : "DESC";
			}
			
			this.sortByIndex(this.options.startSorted.column ? this.options.startSorted.column : 0);
		} else {
			this.sortByIndex(0);
		}
	},
	
	/**
	 * Parses through the entity list and creates the table
	 */
	render: function() {
		this.empty();
		
		try {
			var cData = this.options.columnData;
			
			if(this.options.headerRows) {
				var headerRow = DOMUtil.createTextElement("tr", this._generateHeaderRows());
				/*
				var headerRow = document.createElement("tr");
			
				for(var i = 0, iCount=hRows.length; i < iCount; i++) {
					var cell = document.createElement("th");
					
					if(!cData[i]["sortField"] || Object.isUndefined(cData[i]["sortField"])) {
						// not a header that the data is supposed to be sortable by
						cell.appendChild(document.createTextNode(hRows[i]));
					} else {
						// create link that when clicked sorts the table
						var anchor = DOMUtil.createTextElement("a", hRows[i], {href: ".", onclick: this.sortByColumn.bindAsEventListener(this, i)});
						
						// are we currently sorted by this header?
						if(this.sortedByColumnIndex == i) {
							DOMUtil.addClass(anchor, "sortedBy" + this.sortedByDirection);
						}
						
						cell.appendChild(anchor);
					}
					
					if(cData[i] && cData[i]["iconColumn"]) {
						DOMUtil.addClass(cell, "iconColumnHeader");
					}
					
					// add cell to row
					headerRow.appendChild(cell);
				}
				*/
				this._tableHead = document.createElement("thead");
				this._tableHead.appendChild(headerRow);
				this.appendChild(this._tableHead);
			}
			
			// updates data needed to build the table nodes
			var entityGroup = this.getEntityGroup();
			
			var tableBody = document.createElement("tbody");
			this.appendChild(tableBody);
			
			for(var i = 0; i < entityGroup.length; i++) {
				tableBody.appendChild(this._generateRow(i, entityGroup[i]));
			}
			
			this.scrollToSelectedEntity();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_generateHeaderRows: function() {
		var cells = [];
		
		for(var i = 0; i < this.options.headerRows.length; i++) {
			var cell = document.createElement("th");
			
			if(!this.options.columnData[i]["sortField"] || typeof(this.options.columnData[i]["sortField"]) == "undefined") {
				// not a header that the data is supposed to be sortable by
				cell.appendChild(document.createTextNode(this.options.headerRows[i]));
			} else {
				// create link that when clicked sorts the table
				var anchor = DOMUtil.createTextElement("a", this.options.headerRows[i], {href: ".", onclick: this.sortByIndex.bind(this, i, this.options.args.sortDirection == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC ? foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTASC : foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC)});
							
				// are we currently sorted by this header?
				if(this.options.args.sortBy == i) {
					DOMUtil.addClass(anchor, "sortedBy" + ((this.options.args.sortDirection == foundation.constants.FOUNDATION_DATABASE_PAGINATOROPTIONS_SORTDESC) ? "DESC" : "ASC"));
				}
				
				cell.appendChild(anchor);
			}
			
			if(this.options.columnData[i] && this.options.columnData[i]["iconColumn"]) {
				DOMUtil.addClass(cell, "iconColumnHeader");
			}
			// add cell to row
			cells.push(cell);
		}
		
		return cells;
	},
	
	_generateRow: function(index, entity) {
		var row = document.createElement("tr");
				
		if(!entity) { // invalid item
			row = this._handleInvalidItem(row, index);
		} else if(this.options.createRow instanceof Function) { // custom item
			row = this.options.createRow(row, entity, index);
			row.owningEntity = entity;
		} else { // create row from column data
			row = 	this._handleValidItem(row, index, entity);
			
			if(entity[this.options.entityID] == this._selectedElementID) {
				DOMUtil.addClass(row, "down");
				this._selectedEntity.row = row;
				this._selectedEntity.entity = entity;
			}
		}
		
		if(index % 2 == 0) {
			DOMUtil.addClass(row, "oddRow");
		} else {
			DOMUtil.addClass(row, "evenRow");
		}
		
		return row;
	},
	
	_handleValidItem: function(row, rowIndex, entity) {
		var cData = this.options.columnData;
		for(var n = 0, nCount=cData.length; n < nCount; n++) { // process one entity (eg. one row)
			var cell = document.createElement("td");
			
			if(cData[n].iconColumn) {
				DOMUtil.addClass(cell, "ScrollLoadTableIconColumn");
			}
			
			row.appendChild(cell);
			DOMUtil.addClass(cell, "column" + n);
			
			if(cData[n]["text"] instanceof Function) {
				var cellContent = cData[n]["text"].call(this, entity, n, cell);
				
				if(cellContent) {
					if(cellContent.appendTo) {
						// passed GUIWidget
						cellContent.appendTo(cell);
					} else {
							this._processCallbacks(cellContent, entity, n);
							cell.appendChild(cellContent.appendChild ? cellContent : document.createTextNode(cellContent));
					}
				}
			} else {
				var text = this.getText(entity, cData[n]["text"]);
				cell.appendChild(document.createTextNode(text ? text : " "));
			}
			
			cell.owningEntity = entity;
		}
		
		row.owningEntity = entity;
		
		return row;
	},
	
	_handleInvalidItem: function(row) {
		return row;
	},
	
	/**
	 * Stores onclick and ondblclick so we can call them after setting the down state of the row
	 * 
	 * @private
	 * @param	{Node}	node	A node that we suspect has onclick, etc attributes defined on it
	 * @param	{Object}	entity	The entity that the row was made from that the node is from
	 */
	_processCallbacks: function(node, entity, columnIndex) {
		if(node) {
			try {
				node.columnIndex = columnIndex;
				
				for(var key in {onclick: "", ondblclick: ""}) { // check for onclick and ondblclick
					if(node[key]) { // if it's defined
						if(!this._callBacks[entity[this.options.entityID]]) { // make sure the callback holder is defined
							this._callBacks[entity[this.options.entityID]] = {};
						}
						
						if(!this._callBacks[entity[this.options.entityID]][columnIndex]) { // make sure the callback holder is defined
							this._callBacks[entity[this.options.entityID]][columnIndex] = {};
						}
						
						this._callBacks[entity[this.options.entityID]][columnIndex][key] = node[key]; // store the callback for calling later
						node[key] = this._boundCallBacks[key]; // replace it with our generic callback
					}
				}
			} catch(e) {
				// this will fail when something that isn't a DOM node is passed to be the contents of a cell.
				//  since we are only concerned with anchor tags and the like, we don't mind so swallow the exception
			}
		}
	},
	
	/**
	 * Sets the down state on a row clicked by an user
	 * 
	 * @private
	 * @param	{Event}	An onclick event
	 */
	_itemClicked: function(event) {
		this._processEvent(BehaviourUtil.clearFocus(event), "onclick");
		
		return false;
	},
	
	_itemDoubleClicked: function(event) {
		this._processEvent(BehaviourUtil.clearFocus(event), "ondblclick");
		
		return false;
	},
	
	/**
	 * @private
	 */
	_processEvent: function(node, eventName) {
		var entity = node.parentNode.owningEntity;
		var columnIndex = node.columnIndex;
		
		if(this._callBacks[entity[this.options.entityID]] && this._callBacks[entity[this.options.entityID]][columnIndex] && this._callBacks[entity[this.options.entityID]][columnIndex][eventName] && this._callBacks[entity[this.options.entityID]][columnIndex][eventName] instanceof Function) {
			// if the callback returns false, do not allow the current row to become selected
			if(this._callBacks[entity[this.options.entityID]][columnIndex][eventName].call(this, entity) === false) {
				return;
			}
		}
		
		if(!this.options.columnData[columnIndex].ignoreDownState) {
			this._setItemDown(node);
			this._selectedElementID = entity[this.options.entityID];
			this.render();
		}
		
		if(FocusWatcher) {
			FocusWatcher.setKeypressCallbackObject(this);
		}
	},
	
	/**
	 * Sets the down state on the row containing the passed element
	 * 
	 * @private
	 * @param	{Node}	Typically an anchor node
	 */
	_setItemDown: function(element) {
		this.clearDown();
		
		var row = element.parentNode.parentNode;
		DOMUtil.addClass(row, "down");
	},
	
	/**
	 * Removes the down state from all table rows
	 */
	clearDown: function() {
		this._selectedElementID = null;
		DOMUtil.removeClass(this.rootNode, "down", true);
		
		this._selectedEntity = {
			row: false,
			entity: false
		};
	},
	
	/**
	 * Returns either the value of the entity property using text as a key or text itself.
	 * 
	 * So getText({name: "alex"}, "name") would return "alex" but getText({name: "alex"}, "age") would return "age".  
	 * 
	 * If entityID has . characters in it, this method will step down into entity to find the key, so 
	 * getText({name: "alex", innerObject : {name: "bob"}}, "innerObject.bob") would return "bob"
	 * 
	 * @param	{Object}		entity
	 * @param	{string}		text
	 */
	getText: function(entity, text) {
		if(text.search(/(\.)/) > -1) {
			return this._findIt(entity, text.split("."));
		} else if(entity[text]) {
			return entity[text];
		}
		
		return text;
	},
	
	/**
	 * Returns the ID of the entity.  If entityID has . characters in it, this method will step down into entity to find the key.
	 */
	getEntityID: function(entity, entityID) {
		if(entityID.search(/\./)) {
			return this._findIt(entity, entityID.split("."));
		}
		
		return entity[entityID];
	},
	
	/**
	 * Called by getText and getEntityID to step down into objects.
	 * 
	 * @private
	 * @param	{Object}	entity
	 * @param	{Array}	keys
	 */
	_findIt: function(entity, keys) {
		var output = entity[keys[0]];
			
		for(var i = 1, iCount=keys.length; i < iCount; i++) {
			output = output[keys[i]];
		}
			
		return output;
	},
	
	/**
	 * Sets the appropriate class name on the clicked column header and calls sortByIndex to do the sorting
	 * 
	 * @param	{Event}	event
	 * @return	{boolean}
	 */
	sortByColumn: function(event, index) {
		var element = BehaviourUtil.clearFocus(event);
		
		DOMUtil.removeClass(this._tableHead, "sortedByASC", true);
		DOMUtil.removeClass(this._tableHead, "sortedByDESC", true);
		
		this.sortByIndex(index);
		
		return false;
	},
	
	/**
	 * Gets the entities to make the table from
	 */
	getEntityGroup: function() {
		if(this.options["listItemsKey"]) {
			return this.options.entities[this.options["listItemsKey"]];
		} else if(this.options.entities instanceof Function) {
			return this.options.entities();
		}
		
		return this.options.entities;
	},
	
	sort: function() {
		this.sortedByDirection = (this.sortedByDirection == "DESC" ? "ASC" : "DESC");
		this.sortByIndex(this.sortedByColumnIndex);
	},
	
	/**
	 * Sorts the table entries by this.sortedByColumnIndex or a specified column - 
	 * 0 = first column, 1 = second column, etc
	 * 
	 * @param	{integer}	index
	 * @return	void
	 */
	sortByIndex: function(index) {
		this.notifyListeners("onBeforeSort");
		
		if(index == -1) {
			return;
		}
		
		if(this.sortedByColumnIndex == index) {
			this.sortedByDirection = (this.sortedByDirection == "DESC" ? "ASC" : "DESC");
		} else {
			this.sortedByDirection = "DESC";
		}
		
		//Log.info("sorting by " + this.sortedByDirection);
		
		this.sortedByColumnIndex = index;
		this.currentSortKey = this.options.columnData[this.sortedByColumnIndex]["sortField"];
		
		var entityGroup = this.getEntityGroup();
		
		if(this.sortedByDirection == "ASC") {
			entityGroup.sort(this.ascSortFunction.bind(this));
		} else {
			entityGroup.sort(this.descSortFunction.bind(this));
		}
		
		this.render();
		this.notifyListeners("onAfterSort");
		this.notifyListeners("onSort");
	},
	
	/**
	 * Returns the ID of the first item in the entity array
	 * 
	 * @return	{string}
	 */
	getFirstEntity: function() {
		var entityGroup = this.getEntityGroup();
		
		if(entityGroup instanceof Array) {
			return entityGroup[0];
		}
	},
	
	/**
	 * Sets the down state on the row formed from the passed entity.  Or, more correctly, sets the down state on the row formed from
	 * the entity originally passed to the constructor with an identification field that matches the entity passed to this method.
	 * 
	 * @param	{Object}		The entity whose row to set to the down state
	 */
	setDown: function(entity) {
		if(entity) {
			this._selectedElementID = entity[this.options.entityID];
			
			this._selectedEntity = {
				row: false,
				entity: entity
			};
			
			this.render();
		}
	},
	
	/**
	 * Removes a row from th table.  NB. this will destructively affect the entity array passed to this object's constructor
	 * 
	 * @param	{Object}	entity	The entity to remove
	 * @param	{bool}	selectNew	Whether or not to select the first item in the table if the currently selected entity is the one we are deleting
	 */
	removeEntity: function(entity, selectNew) {
		var ents = this.options.entities;
		for(var i = 0; i < ents.length; i++) {
			if(ents[i] && ((entity.equals && entity.equals(ents[i])) || ents[i][this.options.entityID] == entity[this.options.entityID])) {
				ents.splice(i, 1);
				i--;
			}
		}
		
		this.render();
	},
	
	acceptFocus: function() {
		this.addClass("hasFocus");
	},
	
	loseFocus: function() {
		this.removeClass("hasFocus");
	},
	
	processKeypress: function(event) {
		var nextEntity = false;
		var foundEntity = false;
		
		// process keypress
		if(event.keyCode == Event.KEY_DOWN) { // if we can go one further down the list, do it but skip the contents of closed folders
			$A(this.rootNode.getElementsByTagName("tr")).each(function(row){
				if(foundEntity && !nextEntity) {
					nextEntity = row.owningEntity;
				}
				
				if(this.isSelectedEntity(row.owningEntity)) {
					foundEntity = true;
				}
			}.bind(this));
		} else if(event.keyCode == Event.KEY_UP) {  // if we can go one further up the list, do it but skip the contents of closed folders
			$A(this.rootNode.getElementsByTagName("tr")).each(function(row){
				if(this.isSelectedEntity(row.owningEntity)) {
					foundEntity = true;
					throw $break;
				}
				
				nextEntity = row.owningEntity;
			}.bind(this));
		}
		
		if(nextEntity) {
			this.setDown(nextEntity);
			
			if(this._callBacks[nextEntity[this.options.entityID]] && this._callBacks[nextEntity[this.options.entityID]][0] && this._callBacks[nextEntity[this.options.entityID]][0]["onclick"] && this._callBacks[nextEntity[this.options.entityID]][0]["onclick"] instanceof Function) {
				this._callBacks[nextEntity[this.options.entityID]][0]["onclick"].call(this, nextEntity);
			}
		}
		
		return true;
	},
	
	isSelectedEntity: function(entity) {
		if(entity) {
			return this._selectedElementID == entity[this.options.entityID];
		}
	},
	
	scrollToSelectedEntity: function() {
		if(this._selectedEntity.row && this._selectedEntity.row.scrollIntoView) {
			//this._selectedEntity.row.scrollIntoView();
		}
	}
});

/**
 * @class behaviour.gui.button.IconButton 
 * @extends behaviour.gui.button.GUIButton 
 */
behaviour.gui.button.IconButton = Class.create(behaviour.gui.button.GUIButton, {
	/**
	 * @param {mixed} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode(this._anchor);
		this.addClass("IconButton");
	}
});

/**
 * @class deadline.gui.button.VideoChatIcon 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.VideoChatIcon = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("VideoChatIcon");
	}
});

/**
 * @class deadline.gui.button.TextChatIcon 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.TextChatIcon = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("TextChatIcon");
	}
});

/**
 * @class behaviour.gui.button.AddButton 
 * @extends behaviour.gui.button.IconButton 
 */
behaviour.gui.button.AddButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("AddButton");
	}
});

/**
 * @class behaviour.gui.button.DeleteButton 
 * @extends behaviour.gui.button.IconButton 
 */
behaviour.gui.button.DeleteButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("DeleteButton");
	}
});

/**
 * @class behaviour.gui.token.TextToken 
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.token.TextToken = new Class.create(behaviour.gui.GUIWidget, {
	_editMode: false,
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("span");
		this.addClass("TextToken");
	},
	
	/**
	 * Renders
	 */
	render: function() {
		this.empty();
		
		this.appendChild(DOMUtil.createElement("span", {className: "TextTokenText_left"}));
		this.appendChild(DOMUtil.createElement("span", {className: "TextTokenText_right"}));
		this.appendChild();
		
		var text;
		
		if(this.options.propertyDisplay) {
			text = this.options.propertyDisplay.entity.getPropertyDisplay({property: this.options.propertyDisplay.property});
		} else {
			text = DOMUtil.createTextElement("span", this.options.text);
		}
		
		DOMUtil.addClass(text, "TextTokenText");
		
		if(this._editMode && this.options.deleteCallback) {
			this.appendChild(DOMUtil.createTextElement("span", new behaviour.gui.button.DeleteButton({onclick: this.options.deleteCallback}), {className: "TextTokenText_button"}));
			DOMUtil.addClass(text, "TextTokenText_withButton");
		}
		
		this.appendChild(text);
	},
	
	/**
	 * @param {boolean} mode Sets edit mode
	 */
	setEditMode: function(mode) {
		this._editMode = mode;
		this.render();
	}
});

/**
 * @class	deadline.gui.token.StaffToken
 * @extends	behaviour.gui.token.TextToken
 */
deadline.gui.token.StaffToken = new Class.create(behaviour.gui.token.TextToken, {
	/**
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		if(options.staff) {
			options.propertyDisplay = {
				entity: options.staff,
				property: "fullname"
			};
			
			delete options.staff;
		}
		
		$super(options);
		
		this.addClass("StaffToken");
	}
});

/**
 * @class	deadline.gui.token.StaffChatToken
 * @extends	deadline.gui.token.StaffToken
 */
deadline.gui.token.StaffChatToken = new Class.create(deadline.gui.token.StaffToken, {
	/**
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.options.deleteCallback = function(){};
		
		this.addClass("StaffChatToken");
		this.setStatus(this.options.status);
		
		this.setEditMode(true);
	},
	
	setStatus: function(status) {
		this.removeClass("StaffChatToken_" + this.options.status);
		
		this.options.status = status;
		
		this.addClass("StaffChatToken_" + this.options.status);
	}
});

/**
 * @class deadline.entities.Event
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Event = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/events/create",
	_retrieveURL: "/backend/events/get",
	_updateURL: "/backend/events/update",
	_deleteURL: "/backend/events/delete",
	
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates a default object.
	 * @private
	 * @return {Object} 
	 */
	_getDefaultObject: function() {
		var date = BehaviourUtil.getRoundedDate();
		
		return {
			id: false,
			lastmodifiedby: User.getId(),
			lastmodifieddate: new Date(),
			createdBy: User.getId(),
			canedit: true,
			archived: 0,
			title: Language.get("deadline.entities.Event.defaulttitle"),
			description: "",
			startdate: date,
			enddate: date.getTime() + 601200000, // one week
			numDesks: 0,
			numStories: 0,
			keywords: []
		};
	},
	 
	deleteEntity: function(mode) {
		new behaviour.ajax.JSONRequest({
			url: this._deleteURL, 
			args: {id: this.getId()}, 
			onSuccess: function() {
				currentPage.showEvents();
			}, 
			method: "post"
		});
	},
	
	/**
	 * @param {Object} story
	 */
	addedStory: function(story) {
		this._data.stories.push(story);
		currentPage.renderTreeList();
	},
	
	/**
	 * @param {Object} story
	 */
	removedStory: function(story) {
		for(var i = 0; i < this._data.stories.length; i++) {
			if(this._data.stories[i].getId() == story.id) {
				this._data.stories.splice(i, 1);
				i--;
			}
		}
		
		currentPage.reloadTreeList();
	}
});

/**
 * @class deadline.entities.Story
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Story = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/stories/create",
	_retrieveURL: "/backend/stories/get",
	_updateURL: "/backend/stories/update",
	_deleteURL: "/backend/stories/delete",
	
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates appropriate getters and setters on data passed.
	 * @param {Object} data A tuple from the database
	 */
	processData: function($super, data) {
		$super(data);
		
		if(BehaviourUtil.isGUID(this._data.desk)) {
			this._data.desk = currentPage.getEntity(this._data.desk, "desks", "Desk");
		}
		
		if(BehaviourUtil.isGUID(this._data.event)) {
			this._data.event = currentPage.getEntity(this._data.event, "events", "Event");
		}
	},
	
	/**
	 * Creates a default Story object.
	 * @private
	 * @return {Object} 
	 */
	_getDefaultObject: function() {
		var date = BehaviourUtil.getRoundedDate();
			
		return Object.extend({
			id: false,
			event: null,
			canedit: true,
			deadline: date.getTime() + 601200000, // one week
			startdate: date.getTime(),
			status: deadline.constants.DEADLINE_STORYSTATUS_SCHEDULED,
			archived: 0,
			title: Language.get("deadline.entities.Story.defaulttitle"),
			description: null,
			keywords: [],
			desk: User.getDesks()[0].getId(),
			numTeam: 1,
			numAssignments: 0,
			numAssets: 0,
			numContacts: 0,
			numMessages: 0
		}, deadline.entities.CreatedEntity.prototype._getDefaultObject.call(this));
	},
	
	deleteEntity: function(mode) {
		new behaviour.ajax.JSONRequest({
			url: "/backend/stories/delete", 
			args: {	id: this.getId()}, 
			onSuccess: function() {
				currentPage.showStories();
			}, 
			method: "post"
		});
	}
});

/**
 * The purpose of an assignment is to generate assets.
 * 
 * @class deadline.entities.Assignment
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Assignment = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/assignments/create",
	_retrieveURL: "/backend/assignments/get",
	_updateURL: "/backend/assignments/update",
	_deleteURL: "/backend/assignments/delete",
	
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates appropriate getters and setters on data passed.
	 * @param {Object} data A tuple from the database
	 */
	processData: function($super, data) {
		$super(data);
		
		// if we can, get the story this assignment is attached to from the local data store
		if(BehaviourUtil.isGUID(this._data.story)) {
			this._data.story = currentPage.getEntity(this._data.story, "stories", "Story");
		}
	},
	
	/**
	 * Creates a default object.
	 * @private
	 * @return {Object}
	 */
	_getDefaultObject: function() {
		var date = BehaviourUtil.getRoundedDate();
		return {
			id: false,
			"new": false,
			story: null,
			canedit: true,
			deadline: date,
			startdate: date,
			status: deadline.constants.DEADLINE_ASSIGNMENTSTATUS_SCHEDULED,
			archived: 0,
			title: Language.get("deadline.entities.Assignment.defaulttitle"),
			description: null,
			lastmodifieddate: new Date(),
			lastmodifiedby: User.getId(),
			createdBy: User.getId(),
			keywords: [],
			numMessages: 0,
			numTeam: 0,
			numContacts: 0,
			numAssets: 0
		}
	},
	
	deleteEntity: function(mode) {
		new behaviour.ajax.JSONRequest({
			url: this._deleteURL, 
			args: {id: this.getId()}, 
			onSuccess: function() {
				currentPage.showStories();
			}, 
			method: "post"
		});
	},
	
	/**
	 * Sets the read status on a message
	 */
	getDetailView: function() {
		if(this.getNew()) {
			new behaviour.ajax.JSONRequest({
				url: "/backend/assignments/read", 
				args: {id: this.id}, 
				onSuccess: function() {
					this.setNew(false);
				}.bind(this), 
				method: "post"
			});
		}
	}
});

/**
 * @class behaviour.gui.tree.ScrollLoadTree
 * @extends behaviour.gui.ScrollLoadGUIWidget 
 */
behaviour.gui.tree.ScrollLoadTree = new Class.create(behaviour.gui.ScrollLoadGUIWidget, {
	_currentlySelectedID: null,
	_selectedIndex: null,
	_selectedKey: null,
	_listConstructionData: null,
	_scrollTop: null,
	_list: null,
	_entityTree: null,
	
	/**
	 * @param {Object} options
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		saveOpenStateURL: String,		The URL to post folder open state data to
	  * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("ScrollLoadTree");
		
		this._listConstructionData = [];
		this._selectedIndex = -1;
		
		this._entityTree = {};
	},
	
	/**
	 * @param {Object} constructionData
	 * @example
	 * Expects an object with the following properties:
	 * 
	 * constructionData: {
	 * 		text: function(entity),								// this should return the text to be displayed for the entry
	 * 		onclick: function(entity),						// a function that is called when the item is clicked
	 * 		[collapsible: boolean,]								// can this level be collapsed?
	 * 		[startCollapsed: function(entity),]			// if collapsible is true, this should return true if the level is to start collapsed
	 * 		[propertyName: string]							// if specified, this is the property on the parent object that contains the elements for this tree level
	 * }
	 */
	addLevel: function(constructionData) {
		this._listConstructionData.push(constructionData);
	},
	
	/**
	 * Renders
	 */
	render: function() {
		/*
		if(this._scrollableHolder) {
			Log.info('scrollTop in folderTree = ' + this._scrollableHolder.getRootNode().scrollTop);
		}*/
		this.empty();
		var eLength = this._entities.getLength();
		if(this._initialLoad == true) {
			this.appendChild(new behaviour.gui.LoadingNotification({text: this.options.loadingText}));
		} else if(eLength == 0) {
			this.appendChild(DOMUtil.createTextElement("p", this.options.noEntitiesText, {className: "ScrollLoadTreeEmptyList"}));
		} else {
			try {	
				this._list = DOMUtil.createElement("ul");
				
				for(var i = 0; i < eLength; i++) {
					var entity = this._entities.getElement(i);
					
					if(entity) {
						this._list.appendChild(this._handleValidItem(entity, i));
					} else {
						this._list.appendChild(this._handleInvalidItem(entity));
					}
				}
				
				this.appendChild(this._list);
			} catch(e) {
				Log.dumpException(e);
			}
		}
	},
	
	/**
	 * @private
	 */
	_handleValidItem: function(entity, index) {
		try {
			var entityKey = BehaviourUtil.getKey(entity);
			var treeData = this._entityTree[entityKey];
			
			if(!treeData) {
				Log.warn("Could not determing tree data for entity");
				Log.dumpObject(entity);
				return;
			}
			
			var constructionData = this._listConstructionData[treeData["level"]];
			
			var output = DOMUtil.createElement("li", {
				className: "CollapseExpandListTitle ScrollLoadTreeLevel" + treeData["level"]
			});
					
			// set down if has been selcted before
			//if(index == this._selectedIndex) {
			if(entityKey == this._selectedKey) {
				DOMUtil.addClass(output, "down");
			}
			
			if(!constructionData) {
				Log.info("could not get construction data for level " + treeData["level"]);
			}
			
			// add collapse/expand button
			if(constructionData.collapsible) {
				var startCollapsed = !treeData["folderOpen"];
				
				output.collapsible = true;
				output.collapsed = startCollapsed;
				
				if(treeData["children"].length > 0) {
					output.appendChild(DOMUtil.createTextElement("a", Language.get("bbq.gui.tree.ScrollLoadTreeList.collapseexpand"), {
						href: ".",
						onclick: function(event, entity) {
							try {
								BehaviourUtil.clearFocus(event);
								this._folderClicked(entity);
							} catch(e) {
								Log.dumpException(e);
							}
							
							return false;
						}.bindAsEventListener(this, entity),
						title: Language.get("bbq.gui.tree.ScrollLoadTreeList.collapseexpand"),
						className: "CollapseExpand  CollapseExpand" + (startCollapsed ? "Collapsed" : "Expanded"),
						collapsed: startCollapsed
					}));
				} else {
					// no children, add placeholder
					output.appendChild(DOMUtil.createElement("span", {
						className: "CollapseExpand  CollapseExpandCollapserPlaceHolder"
					}));
				}
			}
			
			var text = constructionData.text(entity);
			var folderTitle;
			
			if(constructionData.onclick || constructionData.ondblclick) {
				folderTitle = DOMUtil.createTextElement("a", text, {
					href: ".",
					onmousedown: this._processEvent.bindAsEventListener(this, entity),
					onclick: this._processEvent.bindAsEventListener(this, entity),
					ondblclick: this._processEvent.bindAsEventListener(this, entity),
					className: "CollapseExpandFolderTitle"
				});
				
				if(Object.isElement(text)) {
					Event.observe(text, "click", function() {
						folderTitle.blur();
						return true;
					});
				}
				
				if(constructionData.onclick) {
					this._storeCallback(entity, "click", constructionData.onclick.bind(this, entity));
				}
				
				if(constructionData.ondblclick) {
					this._storeCallback(entity, "dblclick", constructionData.ondblclick.bind(this, entity));
				}
			} else {
				if(Object.isElement(text)) {
					folderTitle = text;
				} else {
					folderTitle = DOMUtil.createTextElement("span", text);
				}
				
				DOMUtil.addClass(folderTitle, "CollapseExpandFolderTitle");
			}
			
			if(constructionData.className instanceof Function) {
				var className = constructionData.className(entity, [folderTitle, output]);
				
				if(Object.isString(className)) {
					DOMUtil.addClass(folderTitle, className);
					DOMUtil.addClass(output, className);
				}
			}
			
			output.appendChild(folderTitle);
			
			return output;
		} catch(e) {
			Log.dumpException(e);
		}
		
		return output;
	},
	
	/**
	 * @private
	 */
	_handleInvalidItem: function(entity) {
		return DOMUtil.createTextElement("li", new behaviour.gui.LoadingNotification()); 
	},
	
	/**
	 * @private
	 */
	_folderClicked: function(entity, newStatus) {
		var treeData = this._entityTree[BehaviourUtil.getKey(entity)];
		
		// newStatus is passed by left/right arrow keypress handler.  abort if our status will not change.
		if(typeof(newStatus) != "undefined" && newStatus == !treeData["folderOpen"]) {
			return;
		}
		
		// store where we are scrolled to so that we can scroll to it after loading
		this._scrollTop = this._scrollableHolder.getRootNode().scrollTop;
		
		// store collapsed state
		new behaviour.ajax.JSONRequest({
			url: "/backend/setFolderCollapsedStatus", 
			args: {
				entity:  this._getEntityKey(entity),
				closed: treeData["folderOpen"]
			}, 
			onSuccess: this.reloadEntities.bind(this)
		});
		
		return false;
	},
	
	/**
	 * Selects the element in the tree
	 * 
	 * @param {Object} object
	 * @return void
	 */
	setDown: function(entity) {
		this.notifyListeners("onBeforeSelectedEntityChange");
		
		var index = this._entities.indexOf(entity);
	
		if(index != this._selectedIndex) {
			this.clearDown();
			this._selectedIndex = index;
			this._selectedKey = BehaviourUtil.getKey(entity);
			
			if(this._list) {
				var rows = $A(this._list.getElementsByTagName("li"));
				DOMUtil.addClass(rows[this._selectedIndex], "down");
				behaviour.gui.ScrollLoadGUIWidget.prototype.setDown.call(this, entity);
			}
		}
		
		this.notifyListeners("onAfterSelectedEntityChange");
	},
	
	/**
	 * Removes selection
	 */
	clearDown: function() {
		this._selectedIndex = -1;
		this._selectedKey = null;
		this.removeClass("down", true);
	},
	
	/**
	 * Adds focus to the tree
	 */
	acceptFocus: function() {
		this.addClass("hasFocus");
	},
	
	/**
	 * Removes focus from the tree
	 */
	loseFocus: function() {
		this.removeClass("hasFocus");
	},
	
	/**
	 * Process key presses
	 * 
	 * @param {Event} event
	 * @return {Boolean} true
	 */
	processKeypress: function(event) {
		var increment = 1;
		var nextEntity = this._getNextEntity(event, increment);
		
		while(nextEntity) {
			if(this._invokeCallback(nextEntity, "click") === false) {
				increment++;
				nextEntity = this._getNextEntity(event, increment);
			} else {
				return true;
			}
		}
		
		return true;
	},
	
	_getNextEntity: function(event, increment) {
		var nextEntity = false;
		
		// process keypress
		if(event.keyCode == Event.KEY_DOWN) {
			nextEntity = this._entities.getElement(this._selectedIndex + increment);
		} else if(event.keyCode == Event.KEY_UP) {
			nextEntity = this._entities.getElement(this._selectedIndex - increment);
		} else if(event.keyCode == Event.KEY_RIGHT) { // if the currently selected level is collapsible and collapsed, expand it
			this._folderClicked(this._entities.getElement(this._selectedIndex), false);
		} else if(event.keyCode == Event.KEY_LEFT) { // if the currently selected level is collapsible and expanded, collapse it
			this._folderClicked(this._entities.getElement(this._selectedIndex), true);
		}
		
		return nextEntity;
	},
	
	/**
	 * @private
	 * Override
	 */
	 _processNewEntities: function(json) {
		try {
			var keyToEntity = {};
			
			for(var i = 0, iCount=json.numEntities; i < iCount; i++) {
				var entityData = json.entities["en" + i];
				
				// do not process missing items
				if(typeof(entityData) == "undefined") {
					continue;
				}
				
				// overwrite currently stored entity with entity passed from server, otherwise preserve entitiy 
				// if we have it already, otherwise make false to trigger placeholder
				if(this.options.createEntity instanceof Function) {
					this._entities.setElement(i, this.options.createEntity(entityData, i));
				} else {
					this._entities.setElement(i, entityData);
				}
				
				if(this._entities.getElement([i])) {
					if(!this._entities.getElement(i).getId) {
						Log.dumpObject(this._entities.getElement(i));
					} else{
						keyToEntity[this._entities.getElement(i).getId()] = this._entities.getElement(i);
					}
				}
			}
			var tree = json.entityTree;
			// store tree construction data
			for(var key in tree) {
				if(!key) {
					continue;
				}
				
				if(this._entityTree[key]) {
					this._entityTree[key]["folderOpen"] = tree[key]["folderOpen"];
					this._entityTree[key]["children"] = this._entityTree[key]["children"].concat(tree[key]["children"]).uniq();
				} else {
					this._entityTree[key] = {
						folderOpen: tree[key]["folderOpen"] ? true : false,
						children: tree[key]["children"] ? tree[key]["children"] : [],
						level: tree[key]["level"]
					};
				}
			}
			
			this.render();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_workOutMovement: function() {	
		if(this._scrollingTimeout) {
			clearTimeout(this._scrollingTimeout);
		}
		
		// do not try to load entities if there were none last time as chances are there still won't be any
		if(!this._initialLoad && this._entities.getLength() == 0) {
			return;
		}
		
		// if we've no scrollabelholder, we won't know how many to load
		if(!this._scrollableHolder) {
			return;
		}
		
		var offset = this._scrollableHolder.getRootNode().scrollTop;
		
		// div height or table height if not scrolling
		var visibleHeight = Element.getHeight(this._scrollableHolder.getRootNode());
		
		if(visibleHeight == 0) {
			return;
		}
		
		var startRow = Math.floor(offset/this.options.rowHeight);
		var endRow = startRow + Math.floor(visibleHeight/this.options.rowHeight);
		
		if(this._lastRange.start != startRow || this._lastRange.end != endRow || this._initialLoad) {
			this._lastRange.start = startRow;
			this._lastRange.end = endRow;
			
			// load missing details
			//Log.info("calling loadDetails for rows " + (startRow) + " to " + (endRow + 1) + " this._forceLoad = " + this._forceLoad);
			this._loadDetails(startRow, endRow + 1);
		}
	}
});

/**
 * @class deadline.gui.stories.StoryList
 * @extends behaviour.gui.tree.ScrollLoadTree
 */
deadline.gui.stories.StoryList = new Class.create(behaviour.gui.tree.ScrollLoadTree, {
	initialize: function($super, options) {
		options = {
			noEntitiesText: Language.get("deadline.gui.stories.StoryList.nostories"),
			rowHeight: 21,
			createEntity: function(data, index) {
				if(typeof(data) != "undefined") {
					var type = data["type"];
					delete data["type"];
					
					if(type == "story") {
						return currentPage.getEntity(data, "stories", "Story");
					} else if(type == "background") {
						return currentPage.getEntity(data, "sharedFolders", "SharedFolder");
					} else if(type == "assignment") {
						return currentPage.getEntity(data, "assignments", "Assignment");
					}
					
					Log.warn("Unknown entity type for StoryList - " + type);
				}
				
				return false;
			}.bind(this),
			url: "/backend/stories/load",
			startSorted: {
				column: 0,
				direction: "DESC"
			}
		};
		
		$super(options);
		
		this.addClass("StoryList");
		
		this.addLevel({
			text: function(story) {
				return story.getPropertyDisplay({property: "title"});
			}, 
			onclick: function(story) {
				if(!EditWatcher.changesOutstanding()) {
					document.location = "#showStory/" + story.getId();
					return true;
				}
				
				return false;
			}, 
			collapsible: true
		});
		
		this.addLevel({
			propertyName: "assignments", 
			text: function(assignment) {
				return assignment.getPropertyDisplay({property: "title"});
			},
			className: function(assignment) {
				if(assignment instanceof deadline.entities.SharedFolder) {
					return "SharedFolder";
				}
			},
			onclick: function(assignment) {
				if(!EditWatcher.changesOutstanding()) {
					if(assignment instanceof deadline.entities.SharedFolder) {
						document.location = "#showSharedFolder/" + assignment.getId();
					} else {
						document.location = "#showAssignment/" + assignment.getId();
					}
					
					return true;
				}
				
				return false;
			}
		});
	}
});


/**
 * @class deadline.gui.chat.ChatWindow 
 * @extends behaviour.gui.FloatingWindow
 */
deadline.gui.chat.ChatWindow = Class.create(behaviour.gui.FloatingWindow, {
	
	_chatMovie: null,
	_participantDisplay: null,
	_participantList: null,
	_inviterDisplay: null,
	_inviterList: null,
	_chatActionButton: null,
	_chatButtons: null,
	_showChattersButton: null,
	_showInviterButton: null,
	_showingInviterPanel: null,
	_staffChatTokens: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		if(!options.width) {
			options.width = 400;
		}
		
		options.height = 375;
		
		$super(options);
		
		for(var i = 0; i < this.options.participants.length; i++) {
			this.options.participants[i] = {
				staff: this.options.participants[i],
				status: 0
			};
		}
		
		this._staffChatTokens = new Hash();
		this.addClass("ChatWindow");
	},
	
	/**
	 * Render
	 */
	render: function() {
		DOMUtil.emptyNode(this._contentDiv);
		
		var inviterArea = this._getParticipantInviter();
		DOMUtil.addClass(inviterArea, "InviterArea");
		DOMUtil.append(inviterArea, this._contentDiv);
		
		var chatArea = this._getChatArea();
		DOMUtil.addClass(chatArea, "ChatArea");
		DOMUtil.append(chatArea, this._contentDiv);
		
		this._chatButtons = new behaviour.gui.button.ButtonHolder({attributes: {className: "ChatButtons"}});
		this._showChattersButton = this._chatButtons.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.chat.ChatWindow.showchattingwith"), onclick: this._toggleParticipants.bind(this), attributes: {className: "ShowChattingWithButton"}}));
		this._showInviterButton = this._chatButtons.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.chat.ChatWindow.showinvitetochat"), onclick: this._toggleInviter.bind(this), attributes: {className: "ShowChatInviteButton"}}));
		
		this._chatActionButton = this._getChatActionButton("ChatActionButton");
		this._chatActionButton.addClass();
		
		this._chatButtons.addButton(this._chatActionButton);
		this._chatButtons.appendTo(chatArea);
		
		var participantsArea = this._getChatParticpants();
		DOMUtil.addClass(participantsArea, "ParticipantsArea");
		DOMUtil.append(participantsArea, this._contentDiv);
		
		setTimeout(function() {
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_CHAT_ALWAYSSHOWCHATTERS)) {
			this._toggleParticipants();
		}}.bind(this), 100);
	},
	
	_getChatActionButton: function() {
		
	},
	
	joinedChat: function(chatId) {
		this.options.chatId = chatId;
	},
	
	_getChatArea: function() {
		return DOMUtil.createElement("div");
	},
	
	_getChatParticpants: function() {
		this._participantList = DOMUtil.createElement("div");
		
		var listHolder = new behaviour.gui.panel.ScrollableHolder({attributes: {className: "ParticipantList"}});
		listHolder.appendChild(this._participantList);
		
		this._participantDisplay = DOMUtil.createElement("div", {style: {display: "none"}});
		this._participantDisplay.appendChild(DOMUtil.createTextElement("p",  Language.get("deadline.gui.chat.ChatWindow.invitetochat"), {className: "PanelHeader"}));
		listHolder.appendTo(this._participantDisplay);
		
		return this._participantDisplay;
	},
	
	_getParticipantInviter: function() {
		this._inviterDisplay = DOMUtil.createElement("div", {style: {display: "none"}});
		this._inviterDisplay.appendChild(DOMUtil.createTextElement("p",  Language.get("deadline.gui.chat.ChatWindow.invitetochat"), {className: "PanelHeader"}));
		
		var typeTabs = new deadline.gui.button.Tabs({attributes: {id: "headerButtons"}});
		typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.chat.ChatWindow.staff"), rememberDownState: true, startDown: true, onclick: this._changeInviterType.bind(this, "staff")}));
		typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.chat.ChatWindow.desks"), rememberDownState: true, onclick: this._changeInviterType.bind(this, "desks")}));
		typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.chat.ChatWindow.stories"), rememberDownState: true, onclick: this._changeInviterType.bind(this, "stories")}));
		typeTabs.appendTo(this._inviterDisplay);
		
		this._inviterList = new behaviour.gui.panel.ScrollableHolder({attributes: {className: "InviterList"}});
		this._inviterList.appendTo(this._inviterDisplay);
			
		this._changeInviterType("staff");
		
		return this._inviterDisplay;
	},
	
	_changeInviterType: function(type) {
		if(type == "staff") {
			this._showStaff();
		} else if(type == "desks") {
			this._showDesks();
		} else if(type == "stories") {
			this._showStories();
		}
		
		this._showingInviterPanel = type;
	},
	
	_showStaff: function() {
		DOMUtil.emptyNode(this._inviterList);
		
		var notification = new behaviour.gui.LoadingNotification();
		notification.appendTo(this._inviterList);
		
		var callbackID = FlashBridge.registerFunction(this._showStaffList.bind(this));
		
		Broadcaster.callFlashFunction("getOnlineClients", {callbackID: callbackID});
	},
	
	_showStaffList: function(clients) {
		DOMUtil.emptyNode(this._inviterList);
		
		if(clients.length == 0) {
			this._inviterList.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.chat.ChatWindow.noolinestaff"), {className: "notice"}));
			return;
		}
		
		var staff = [];
		
		clients.each(function(id){
			// do not include the current user
			if(id == User.getId()) {
				return;
			}
			
			// do not include users already in this chat
			for(var i = 0; i < this.options.participants.length; i++) {
				if(id == this.options.participants[i].staff.getId()) {
					return
				}
			}
			
			staff.push(currentPage.getEntity(id, "staff", "Staff"));
		}.bind(this));
		
		if(staff.length == 0) {
			this._inviterList.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.chat.ChatWindow.emptychatstaff"), {className: "notice"}));
			return;
		}
		
		var table = new behaviour.gui.table.SortableTable({
			entities: staff,
			headerRows: [Language.get("deadline.gui.chat.ChatWindow.invite"), Language.get("deadline.gui.chat.ChatWindow.name")],
			columnData: [{
					text: function(staff) {
						return new behaviour.gui.button.AddButton({onclick: function() {
							this.options.participants.push({
								staff: staff,
								status: 0
							});
							this._chatMovie.callFlashFunction("inviteParticipant", [staff.getId()]);
							this._showStaff();
						}.bind(this)});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(staff) {
						return staff.getPropertyDisplay({property: "fullname"});
					}
				}
			]
		});
		
		table.appendTo(this._inviterList);
	},
	
	_showDesks: function() {
		DOMUtil.emptyNode(this._inviterList);
		
		var table = new behaviour.gui.table.SortableTable({
			entities: User.getDesks(),
			headerRows: [Language.get("deadline.gui.chat.ChatWindow.invite"), Language.get("deadline.gui.chat.ChatWindow.title")],
			columnData: [{
					text: function(desk) {
						return new behaviour.gui.button.AddButton({onclick: this._inviteDesk.bind(this, desk)});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(desk) {
						return desk.getPropertyDisplay({property: "title"});
					}
				}
			]
		});
		
		table.appendTo(this._inviterList);
	},
	
	_inviteDesk: function(desk) {
		new behaviour.ajax.JSONRequest({
			url: "/backend/desks/getAllStaff", 
			args: {
				desk: desk.getId()
			}, 
			onSuccess: this._inviteStaff.bind(this)
		});
	},
	
	_showStories: function() {
		DOMUtil.emptyNode(this._inviterList);
		try {
		Log.info("showing stories");
		var list = new behaviour.gui.tree.ScrollLoadTree({
			noEntitiesText: Language.get("deadline.gui.chat.ChatWindow.nostories"),
			rowHeight: 21,
			createEntity: function(data, index) {
				if(typeof(data) != "undefined") {
					var type = data["type"];
					delete data["type"];
					
					if(type == "story") {
						return currentPage.getEntity(data, "stories", "Story");
					} else if(type == "assignment") {
						return currentPage.getEntity(data, "assignments", "Assignment");
					}
					
					Log.warn("Unknown entity type for ChatWindow - " + type);
				}
				
				return false;
			}.bind(this),
			url: "/backend/stories/load",
			startSorted: {
				column: 0,
				direction: "DESC"
			},
			args: {
				omitSharedFolders: true
			}
		});
		list.addClass("StoryList");
		
		list.addLevel({
			text: function(story) {
				return DOMUtil.createTextElement("span", [
					new behaviour.gui.button.AddButton({onclick: this._inviteStory.bind(this, story)}),
					story.getPropertyDisplay({property: "title"})
				]);
			}.bind(this), 
			collapsible: true
		});
		
		list.addLevel({
			propertyName: "assignments", 
			text: function(assignment) {
				return DOMUtil.createTextElement("span", [
					new behaviour.gui.button.AddButton({onclick: this._inviteAssignment.bind(this, assignment)}),
					assignment.getPropertyDisplay({property: "title"})
				]);
			}.bind(this)
		});
		
		this._inviterList.appendChild(list);
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_inviteStory: function(story) {
		new behaviour.ajax.JSONRequest({
			url: "/backend/stories/getAllStaff", 
			args: {
				story: story.getId()
			}, 
			onSuccess: this._inviteStaff.bind(this)
		});
	},
	
	_inviteAssignment: function(assignment) {
		new behaviour.ajax.JSONRequest({
			url: "/backend/assignments/getAllStaff", 
			args: {
				assignment: assignment.getId()
			}, 
			onSuccess: this._inviteStaff.bind(this)
		});
	},
	
	_inviteStaff: function(serverResponse, json) {
		json.each(function(staff){
			// don't invite the current user or users who are already in the chat
			if(staff.id != User.getId() && !this._staffChatTokens.get(staff.id)) {
				this._chatMovie.callFlashFunction("inviteParticipant", [staff.id]);
			}
		}.bind(this));
	},
	
	_toggleParticipants: function() {
		this._togglePanel(this._participantDisplay, this._showChattersButton, Language.get("deadline.gui.chat.ChatWindow.hidechatters"), Language.get("deadline.gui.chat.ChatWindow.showchattingwith"));
	},
	
	_toggleInviter: function() {
		this._togglePanel(this._inviterDisplay, this._showInviterButton, Language.get("deadline.gui.chat.ChatWindow.hideinvitetochat"), Language.get("deadline.gui.chat.ChatWindow.showinvitetochat"));
	},
	
	_togglePanel: function(panel, button, hideText, showText) {
		this._chatButtons.setDisabled(true);
		
		var dims = Element.getDimensions(this.getRootNode());
		
		if(panel.style.display == "none") {
			this.registerOneTimeListener("onAfterWindowResize", function() {
				this._chatButtons.setDisabled(false);
				panel.style.display = "block";
				button.setText(hideText);
			}.bind(this));
		
			this.setWindowSize(dims.width + (Element.getWidth(panel) + 8), this.options.height);
		} else {
			panel.style.display = "none";
			
			this.registerOneTimeListener("onAfterWindowResize", function() {
				this._chatButtons.setDisabled(false);
				
				button.setText(showText);
			}.bind(this));
			
			this.setWindowSize(dims.width - (Element.getWidth(panel) + 12), this.options.height);
		}
	},
	
	_renderParticpants: function() {
		DOMUtil.emptyNode(this._participantList);
		
		if(this.options.participants.length == 0) {
			this._participantList.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.chat.ChatWindow.emptychat"), {className: "notice"}));
		} else {
			this.options.participants.each(function(participant) {
				var token = new deadline.gui.token.StaffChatToken({staff: participant.staff, status: participant.status});
				token.appendTo(this._participantList);
				
				this._staffChatTokens.set(participant.staff.getId(), token);
			}.bind(this));
		}
	},
	
	getParticipants: function() {
		var staffIds = [];
		
		this.options.participants.each(function(participant) {
			staffIds.push(participant.staff.getId());
		});
		
		return staffIds;
	},
	
	updateParticipants: function(list) {
		this.options.participants = [];
		this._staffChatTokens = new Hash();
		
		list.each(function(participant) {
			if(participant.id != User.getId()) {
				this.options.participants.push({
					staff: currentPage.getEntity(participant.id, "staff", "Staff"),
					status: participant.status
				});
			}
		}.bind(this));
		
		this._renderParticpants();
		
		if(this._showingInviterPanel == "staff") {
			this._showStaff();
		}
	},
	
	receivedStatus: function(chatter, status) {
		var token = this._staffChatTokens.get(chatter);
		
		if(token) {
			token.setStatus(status);
		}
	},
	
	_sendChat: function() {
		if(this.options.participants.length == 0) {
			this._showNoParticipantsMessage();
			return;
		}
		
		var haveChatters = false;
		
		this.options.participants.each(function(participant) {
			if(participant.status != 0) {
				haveChatters = true;
			}
		});
		
		if(!haveChatters) {
			this._showNoParticipantsAcceptedMessage();
		}
	},
	
	_showNoParticipantsMessage: function() {
		
	},
	
	_showNoParticipantsAcceptedMessage: function() {
		
	}
});

/**
 * @class deadline.gui.chat.ChatMovie
 * @extends behaviour.web.FlashEmbed
 */
deadline.gui.chat.ChatMovie = new Class.create(behaviour.web.FlashEmbed, {
	
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options.transparent = true;
		
		if(options.chatId) {
			options.swf.flashVars = {
				chatId: options.chatId
			};
			
			delete options.chatId;
		}
		
		$super(options);
	},
	
	// called by flash
	getParticipants: function() {
		return this.options.chat.getParticipants();
	},
	
	// called by flash
	joinedChat: function(chatId) {
		return this.options.chat.joinedChat(chatId);
	},
	
	// called by flash
	inviteParticipants: function(chatId) {
		this.options.chat.inviteParticipants(chatId);
	},
	
	// called by flash
	inviteParticipant: function(chatId, staffId) {
		this.options.chat.inviteParticipant(chatId, staffId);
	},
	
	// called by flash
	updateParticipants: function(map) {
		this.options.chat.updateParticipants(map);
	},
	
	// called by flash
	chatterJoined: function(staffId) {
		this.options.chat.chatterJoined(staffId);
	},
	
	// called by flash
	chatterLeft: function(staffId) {
		this.options.chat.chatterLeft(staffId);
	},
	
	receivedStatus: function(chatter, status) {
		this.options.chat.receivedStatus(chatter, status);
	}
});

/**
 * @class deadline.gui.chat.VideoChatMovie
 * @extends deadline.gui.chat.ChatMovie
 */
deadline.gui.chat.VideoChatMovie = new Class.create(deadline.gui.chat.ChatMovie, {
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options.swf = {
			path: "/swf/PushToTalk.swf",
			width: 400,
			height: 300
		};
		options.server = ServerConfig.pushtotalk_server;
			
		$super(options);
	},
	
	enableChatButton: function() {
		this.options.chat.enableChatButton();
	},
	
	disableChatButton: function() {
		this.options.chat.disableChatButton();
	},
	
	forwardKeypress: function(which) {
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			//this.options.videoChat.startChat();
		} else {
			if(which == "down") {
				this.options.chat.startChat();
			} else {
				this.options.chat.stopChat();
			}
		}
	},
	
	forwardClick: function() {
		this.options.chat.bringToFront();
	},
	
	forwardMouseUp: function() {
		this.options.chat.onMouseUp();
	}
});

/**
 * @class deadline.gui.chat.VideoChat 
 * @extends deadline.gui.chat.ChatWindow
 */
deadline.gui.chat.VideoChat = Class.create(deadline.gui.chat.ChatWindow, {
	
	_chatting: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		options.title = "Video chat";
		options.width = 422;
		
		$super(options);
		
		this.addClass("VideoChat");
		
		var lastEvent;
		
		var spaceBarWatcher = function(event) {
			if(!this.isFrontMostWindow()) {
				return;
			}
			
			// check each text input on the page to see if it has focus.  tedious.
			// N.B. this will only work on UpdateableTextField, UpdateableTextArea and their extending classes
			var inputs = document.getElementsByTagName("input");
			
			for(var i = 0; i < inputs.length; i++) {
				if(inputs[i].hasFocus) {
					return;
				}
			}
			
			var inputs = document.getElementsByTagName("textarea");
			
			for(var i = 0; i < inputs.length; i++) {
				if(inputs[i].hasFocus) {
					return;
				}
			}
			
			if(this._chatActionButton.isDisabled()) {
				return;
			}
			
			// space bar
			if(event.which == 32) {
				// some browsers repeat keydown events while the user is holding a key down, so ignore repeated events
				if(event.type != lastEvent) {
					this._toggleChat();
					lastEvent = event.type;
				}
			}
		}.bindAsEventListener(this);
		
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			Event.observe(document, "keypress", spaceBarWatcher);
		} else {
			Event.observe(document, "keydown", spaceBarWatcher);
			Event.observe(document, "keyup", spaceBarWatcher);
		}
		
		// watches the mouse so if the user presses down on the button, then mouses off it and releases it, we'll stop the recording
		var mouseWatcher = this.onMouseUp.bind(this);
		Event.observe(document, "mouseup", mouseWatcher);
		
		this.registerListener("onWindowClosed", function() {
			if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
				Event.stopObserving(document, "keypress", spaceBarWatcher);
			} else {
				Event.stopObserving(document, "keydown", spaceBarWatcher);
				Event.stopObserving(document, "keyup", spaceBarWatcher);
			}
			
			Event.stopObserving(document, "mouseup", mouseWatcher);
		}.bind(this));
	},
	
	onMouseUp: function() {
		if(this._chatting) {
			this.stopChat();
		}
	},
	
	_getChatActionButton: function() {
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			return new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.chat.VideoChat.pushtochat"), onclick: this._toggleChat.bind(this), startDisabled: true});
		}
		
		return new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.chat.VideoChat.pushandholdtochat"), onmousedown: this.startChat.bind(this), onmouseup: this.stopChat.bind(this), startDisabled: true});
	},
	
	_getChatArea: function() {
		var div = DOMUtil.createElement("div");
		
		// this transparent div sits over the flash movie to ensure we catch mouse up events
		div.appendChild(DOMUtil.createElement("div", {className: "VideoMovieObscurer"}));
		
		this._chatMovie = new deadline.gui.chat.VideoChatMovie({chat: this, chatId: this.options.chatId});
		this._chatMovie.appendTo(div);
		
		return div;
	},
	
	enableChatButton: function() {
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.pushtochat"));
		} else {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.pushandholdtochat"));
		}
		
		this._chatActionButton.setDisabled(false);
	},
	
	disableChatButton: function() {
		this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.waitforchat"));
		
		this._chatActionButton.setDisabled(true);
	},
	
	_toggleChat: function() {
		if(this._chatActionButton.isDisabled()) {
			return;
		}
		
		if(this._chatting) {
			this.stopChat();
		} else {
			this.startChat();
		}
	},
	
	startChat: function() {
		deadline.gui.chat.ChatWindow.prototype._sendChat.call(this);
		
		if(this._chatting || this._chatActionButton.isDisabled()) {
			return;
		}
		
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.pushagaintostopchat"));
		} else {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.releasetostopchat"));
		}
		
		this._chatMovie.callFlashFunction("startRecording");
		this._chatting = true;
	},
	
	stopChat: function() {
		if(!this._chatting || this._chatActionButton.isDisabled()) {
			return;
		}
		
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_VIDEOCHAT_USETOGGLE)) {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.pushtochat"));
		} else {
			this._chatActionButton.setText(Language.get("deadline.gui.chat.VideoChat.pushandholdtochat"));
		}
		
		this._chatMovie.callFlashFunction("stopRecording");
		this._chatting = false;
	},
	
	inviteParticipants: function() {
		Broadcaster.callFlashFunction("callRemoteFunction", {staff: this.getParticipants(), functionName: "deadline.gui.chat.VideoChat.initiateChat", args: [User.getId(), this.options.chatId]});
	},
	
	inviteParticipant: function(staffId) {
		Broadcaster.callFlashFunction("callRemoteFunction", {staff: [staffId], functionName: "deadline.gui.chat.VideoChat.initiateChat", args: [User.getId(), this.options.chatId]});
	},
	
	chatterLeft: function(staffId) {
		Log.info("VideoChat#chatterLeft " + staffId);
		
		var staff = currentPage.getEntity(staffId, "staff", "Staff");
		
		staff.registerListener("onDataLoaded", function() {
			this._showNotification(Language.getFormatted("deadline.gui.chat.VideoChat.participantleftchat", {staffName: staff.getFullname()}));
		}.bind(this));
	},
	
	chatterJoined: function(staffId) {
		var staff = currentPage.getEntity(staffId, "staff", "Staff");
		
		staff.registerListener("onDataLoaded", function() {
			this._showNotification(Language.getFormatted("deadline.gui.chat.VideoChat.participantjoinedchat", {staffName: staff.getFullname()}));
		}.bind(this));
	},
	
	_showNotification: function(text) {
		this._chatMovie.callFlashFunction("showNotification", [text]);
	},
	
	_showNoParticipantsMessage: function() {
		this._showNotification(Language.get("deadline.gui.chat.VideoChat.noparticipantsinchat"));
	},
	
	_showNoParticipantsAcceptedMessage: function() {
		this._showNotification(Language.get("deadline.gui.chat.VideoChat.noparticipantsacceptedchat"));
	}
});

/**
 * Called remotely by other staff initiating a chat
 */
deadline.gui.chat.VideoChat.initiateChat = function(requestingStaffId, chatId) {
	var chat = new deadline.gui.chat.VideoChat({participants: [currentPage.getEntity(requestingStaffId, "staff", "Staff")], chatId: chatId});
	chat.appear();
	
	SoundBank.playStartChat();
}

/** 
 * 
 * NativeButton
 * 
 * This class is similar to the GUIButton class but uses a standard browser submit input button as its
 * base. It supports the following options:
 * 
 * {
 * 		buttonText: string,	// the text contatined in the anchor tag and tool tip
 * 		onclick: function,		// onclick callback
 * 		onmouseover:	function,	// onmouseover callback
 * 		onmouseout:	 function,	// onmouseout callback
 * 		callbackObject: object,	// an object passed as an argument to the above callback functions
 * 		rememberDownState: boolean,	// whether or not to add the class buttonDown after clicking
 * 		buttonID: string,			// Unique HTML ID for button
 * 		startDisabled: boolean			// whether or not this button should start off disabled
 * }
 * 
 * @class behaviour.gui.button.NativeButton
 * @extends behaviour.gui.button.GUIButton 
 */
behaviour.gui.button.NativeButton = Class.create(behaviour.gui.button.GUIButton, {
	/**
	 * Supports the same options as behaviour.gui.button.GUIButton
	 * @param {mixed} options
	 * @example 
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("li");
		this.addClass("NativeButton");
		
		this._anchor = DOMUtil.createSubmitInputNode((options.buttonText ? options.buttonText : " "), {onclick: function(){this.blur(); return false}});
		this.appendChild(this._anchor);
		
		if(options.startDisabled) {
			this.setDisabled(true);
		} else {
			this.setDisabled(false);
		}
		
		this._anchor.onclick = this.buttonClicked.bindAsEventListener(this);
		this._anchor.onmouseout = this.mouseOut.bindAsEventListener(this);
		this._anchor.onmouseover = this.mouseOver.bindAsEventListener(this);
		this._anchor.onmousedown = this.mouseDown.bindAsEventListener(this);
		this._anchor.onmouseup = this.mouseUp.bindAsEventListener(this);
	},
	
	/**
	 * @param {boolean} disabled
	 */
	setDisabled: function(disabled) {
		this.disabled = disabled;
		this._anchor.disabled = this.disabled;
	},
	
	/**
	 * Overridden as it's not really necessary with this type of button
	 */
	setDown: function() {
		
	},
	
	setText: function(text) {
		this._anchor.value = text;
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableField
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.updateables.UpdateableField = new Class.create(behaviour.gui.GUIWidget, {
	
	editMode: null,
	disabled: null,
	displayValue: null,
	currentValue: null,
	originalValue: null,
	shortenDisplayField: null,
	_changed: null,
	_entityDataLoadedCallbackKey: null,
	_entityDataUpdatedCallbackKey: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		initialValue:	mixed							// Some sort of value
	 * 		propertyDisplay: Object					// {key: String, entity: Object}  If passed, ignores initialValue and will use #getPropertyDisplay(key, formatter) on the passed object for display value instead 
	 * 		required:	boolean
	 * 		errorText: String								// thrown as an exception if the field has no value
	 * 		shortenDisplayField: boolean
	  * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("span");
		
		this.shortenDisplayField = this.options.shortenDisplayField;
		this.editMode = false;
		
		this._setInitialValues();
		
		this.disabled = false;
		this._changed = false
		this.addClass("UpdateableField");
		
		if(!Object.isUndefined(this.options.propertyDisplay)) {
			// set up property display watchers
			this.setPropertyDisplay(this.options.propertyDisplay.key, this.options.propertyDisplay.entity);
		}
		
		// flag this field as updated when value is changed
		this.registerListener("onValueChanged", function() {
			this._changed = true;
		}.bind(this));
	},
	
	setPropertyDisplay: function(key, entity) {
		if(Object.isUndefined(this.options.propertyDisplay)) {
			this.options.propertyDisplay = {};
		} else {
			if(this._entityDataLoadedCallbackKey) {
				// if we were already watching an object for updates, stop watching it
				this.options.propertyDisplay.entity.deRegisterListener("onDataLoaded", this._entityDataLoadedCallbackKey);
			}
			
			if(this._entityDataUpdatedCallbackKey) {
				// if we were already watching an object for updates, stop watching it
				this.options.propertyDisplay.entity.deRegisterListener("onUpdate", this._entityDataUpdatedCallbackKey);
			}
		}
		
		this.options.propertyDisplay.key = key;
		this.options.propertyDisplay.entity = entity;
		
		// register for repeat notifications to update display when entity is remotely updated
		this._entityDataLoadedCallbackKey = this.options.propertyDisplay.entity.registerListener("onDataLoaded", function() {
			this._updateInitialValues();
			this.render();
		}.bind(this));
		
		// register for repeat notifications to update display when entity is remotely updated
		this._entityDataUpdatedCallbackKey = this.options.propertyDisplay.entity.registerListener("onUpdate", function() {
			this._updateInitialValues();
			this.render();
		}.bind(this));
		
		if(entity.dataLoaded()) {
			this._updateInitialValues();
			this.render();
		}
	},
	
	_setInitialValues: function() {
		if(!Object.isUndefined(this.options.propertyDisplay)) {
			
		} else {
			if(Object.isUndefined(this.options.initialValue) || this.options.initialValue == null) {
				this.options.initialValue = "";
			}
			
			this._setCurrentValue(this.options.initialValue);
			this._setOriginalValue(this.options.initialValue);
			this._setDisplayValue(this.options.initialValue);
		}
	},
	
	_updateInitialValues: function() {
		this._setCurrentValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
		this._setOriginalValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
		this._setDisplayValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
	},
	
	/*
	 * resets the internal field value to that prior editing
	 */
	cancelEdit: function() {
		this._setCurrentValue(this.originalValue);
		this._setDisplayValue(this.originalValue);
	},
	
	createEditField: function() {
		Log.info("Non overridden createEditField() method called");
	},
	
	/*
	 * creates view field
	 */
	createViewField: function() {
		if(typeof(this.options.propertyDisplay) != "undefined") {
			return this._createViewFieldFromPropertyDisplay();
		}
		
		if(this._getDisplayValue() && this._getDisplayValue().length > 0) {
			return document.createTextNode(this._getTruncatedValue());
		}
		
		return document.createTextNode(" ");
	},
	
	_getCurrentValue: function() {
		if(typeof(this.options.propertyDisplay) != "undefined" && typeof(this.currentValue) == "undefined") {
			this.currentValue = this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key);
		}
		
		return this.currentValue;
	},
	
	_setCurrentValue: function(value) {
		this.currentValue = value;
	},
	
	_getOriginalValue: function() {
		if(typeof(this.options.propertyDisplay) != "undefined") {
			return this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key);
		}
		
		return this.originalValue;
	},
	
	_setOriginalValue: function(value) {
		this.originalValue = value;
	},
	
	_getDisplayValue: function() {
		if(typeof(this.options.propertyDisplay) != "undefined" && !this.displayValue) {
			this.displayValue = this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key);
		}
		
		return this.displayValue;
	},
	
	_setDisplayValue: function(value) {
		this.displayValue = value;
	},
	
	_createViewFieldFromPropertyDisplay: function() {
		return this.options.propertyDisplay.entity.getPropertyDisplay({property: this.options.propertyDisplay.key, formatter: this.options.propertyDisplay.formatter});
	},
	
	_getTruncatedValue: function() {
		if(this.shortenDisplayField && this._getDisplayValue().length && this._getDisplayValue().length > 20) {
			return  this._getDisplayValue().substr(0, 9) + "..." + this._getDisplayValue().substr((this._getDisplayValue().length - 8), 8);
		}
		
		return this._getDisplayValue();
	},
	
	/**
	 * @param {Object} value
	 */
	setValue: function(value) {
		this._setCurrentValue(value);
		this._setDisplayValue(value);
		this.render();
	},
	
	/**
	 * @param {boolean} supressErrorWarning
	 * @return Returns the current field value 
	 * @type {Object}
	 */
	getValue: function(supressErrorWarning) {
		if(!supressErrorWarning && !this.checkForRequired()) {
			this.triggerError();
		}
		
		return this._getCurrentValue();
	},
	
	triggerError: function() {
		this.setError(true);
		this.notifyListeners("onError");
		throw new behaviour.gui.updateables.InputException(this.options.errorText ? this.options.errorText : "field needs value");
	},
	
	/**
	 * draws the field either as a form for editing or text for display
	 */
	render: function() {
		this.empty();
		
		if(this.editMode) { // create edit node
			this.appendChild(this.createEditField());
			
			if(this.options.notes) {
				this.appendChild(DOMUtil.createTextElement("span", this.options.notes, {className: "UpdateableField_Notes"}));
			}
		} else { // create view node
			var view = this.createViewField();
			
			if(Object.isString(view)) {
				this.appendChild(document.createTextNode(view));
			} else {
				this.appendChild(view);
			}
		}
		
		if(this._getCurrentValue() != this._getOriginalValue()) {
			this.checkForRequired();
		}
	},
	
	/**
	 * saves the current field value internally
	 * 
	 */
	saveEdit: function() {
		this._setDisplayValue(this._getCurrentValue());
		this._setOriginalValue(this._getCurrentValue());
	},
	
	/**
	 * @param {boolean} disabled
	 */
	setDisabled: function(disabled) {
		if(this.disabled != disabled) {
			this.disabled = disabled;
			this.render();
		}
	},
	
	/**
	 * @param {integer} editMode
	 */
	setEditMode: function(editMode) {
		this.editMode = editMode;
		this.render();
	},
	
	getEditMode: function() {
		return this.editMode;
	},
	
	/**
	 * updates current value from input field
	 */
	updateLocalValue: function() {
		this._setCurrentValue(this.inputField.value);
		this.checkForRequired();
		this.notifyListeners("onValueChanged");
	},
	
	/**
	 * check if updateable field is required.  Returns false if we are required and do not have a value, true otherwise
	 */
	checkForRequired: function() {
		if(this.getEditMode()) {
			if(this.options.required && (!this._getCurrentValue() || (this._getCurrentValue().strip && this._getCurrentValue().strip() == ""))) {
				return false;
			}
		}
		
		return true;
	},
	
	/**
	 * @private
	 */
	_clearFocusWatcher: function() {
		FocusWatcher.setKeypressCallbackObject(this);
	},
	
	/**
	 * clears an error by removing the "error" class from the DOM
	 */
	clearError: function() {
		this.removeClass("error");
	},
	
	setError: function(error) {
		this.removeClass("error");
		
		if(error) {
			this.addClass("error");
		}
	},
	
	focus: function() {
		this.inputField.focus();
	},
	
	blur: function() {
		this.inputField.blur();
	},
	
	changed: function() {
		return this._changed;
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableFieldWithInstruction
 * @extends behaviour.gui.updateables.UpdateableField 
 */
behaviour.gui.updateables.UpdateableFieldWithInstruction = new Class.create(behaviour.gui.updateables.UpdateableField, {
	inputField: null,
	
	_showInstruction: function() {
		this.inputField.value = this.options.inlineInstruction;
		this.addClass("UpdateableFieldWithInstruction_DisplayingInstruction");
		this.addClass("UpdateableFieldWithInstruction_Blur");
	},
	
	focusInstructionField: function(event) {
		this.removeClass("UpdateableFieldWithInstruction_Blur");
		this.addClass("UpdateableFieldWithInstruction_Focus");
		
		if(this.inputField.value == this.options.inlineInstruction) {
			this.inputField.value = "";
			this.removeClass("UpdateableFieldWithInstruction_DisplayingInstruction");
		}
	},
	
	blurInstructionField: function(event) {
		this.removeClass("UpdateableFieldWithInstruction_Focus");
		
		if(this.inputField.value == "") {
			this._showInstruction();
		} else if(this.inputField.value != this.options.inlineInstruction) {
			this.removeClass("UpdateableFieldWithInstruction_DisplayingInstruction");
		}
	},
	
	/**
	 * Updates the local store of the field value and makes a fuss if we are required but don't have a value.
	 */
	updateLocalValue: function() {
		if(this.options.inlineInstruction && this.inputField.value == this.options.inlineInstruction) {
			this._setCurrentValue("");
		} else {
			this._setCurrentValue(this.inputField.value.strip());
		}
		
		this.notifyListeners("onValueChanged");
		this.checkForRequired();
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableTextArea
 * @extends behaviour.gui.updateables.UpdateableFieldWithInstruction
 */
behaviour.gui.updateables.UpdateableTextArea = new Class.create(behaviour.gui.updateables.UpdateableFieldWithInstruction, {
	
	/**
	 * @param {Object} options An options object
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("UpdateableTextArea");
	},
	
	/**
	 * Creates Edit field
	 */
	createEditField: function() {
		this.empty();
		
		this.inputField = DOMUtil.createTextElement("textarea", this._getCurrentValue(), {
			disabled: this.disabled, 
			onkeyup: this.updateLocalValue.bindAsEventListener(this),
			onfocus: this._clearFocusWatcher.bind(this)
		});
		
		if(this.options.inlineInstruction) {
			if(this.inputField.value == this.options.inlineInstruction || this.inputField.value == "") {
				this._showInstruction();
				Event.observe(this.inputField, "blur", this.blurInstructionField.bindAsEventListener(this));
				Event.observe(this.inputField, "focus", this.focusInstructionField.bindAsEventListener(this));
			}
		}
		
		Event.observe(this.inputField, "blur", this._processEventCallback.bindAsEventListener(this, "onblur"));
		Event.observe(this.inputField, "focus", this._processEventCallback.bindAsEventListener(this, "onfocus"));
		Event.observe(this.inputField, "change", this._processEventCallback.bindAsEventListener(this, "onchange"));
		Event.observe(this.inputField, "keydown", this._processEventCallback.bindAsEventListener(this, "onkeydown"));
		Event.observe(this.inputField, "keyup", this._processEventCallback.bindAsEventListener(this, "onkeyup"));
		Event.observe(this.inputField, "keypress", this._processEventCallback.bindAsEventListener(this, "onkeypress"));
		Event.observe(this.inputField, "click", this._processEventCallback.bindAsEventListener(this, "onclick"));
		
		Event.observe(this.inputField, "blur", function() {
			this.inputField.hasFocus = false;
		}.bind(this));
		Event.observe(this.inputField, "focus", function() {
			this.inputField.hasFocus = true;
		}.bind(this));
		
		return this.inputField;
	},
	
	_processEventCallback: function(event, type) {
		// Internet explorer does not get on with having the event object hanging around
		// in the timeout closure below so copy the event object's properties
		var eventObject = {};
		
		for(var key in event) {
			if(!Object.isFunction(event[key])) {
				eventObject[key] = event[key];
			}
		}
		
		setTimeout(function() {
			if(this.options[type] && this.options[type] instanceof Function) {
				this.options[type]();
			}
			
			this.notifyListeners(type, eventObject);
		}.bind(this), 100);
	},
	
	/**
	 * Creates view field
	 */
	createViewField: function($super) {
		if(typeof(this.options.propertyDisplay) != "undefined") {
			return $super();
		}
		
		this.empty();
		
		if(this.displayValue && this.displayValue.split) {
			var theText = this.displayValue.split("\n");
			var tLength = theText.length;
			for(var i = 0; i < tLength; i++) {
				this.appendChild(document.createTextNode(theText[i]));
				
				if(tLength > 1 && i != (tLength - 1)) {
					this.appendChild(document.createElement("br"));
				}
			}
		} else {
			this.appendChild(document.createTextNode(" "));
		}
	}
});

/**
 * @class deadline.gui.chat.TextChatMovie
 * @extends deadline.gui.chat.ChatMovie
 */
deadline.gui.chat.TextChatMovie = new Class.create(deadline.gui.chat.ChatMovie, {
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options.swf = {
			path: "/swf/TextChat.swf",
			width: 1,
			height: 1
		};
		options.server = ServerConfig.textchat_server;
		
		$super(options);
	},
	
	receivedMessage: function(chatter, message) {
		this.options.chat.receivedMessage(chatter, message);
	}
});

/**
 * @class deadline.gui.chat.TextChat 
 * @extends deadline.gui.chat.ChatWindow
 */
deadline.gui.chat.TextChat = Class.create(deadline.gui.chat.ChatWindow, {
	_chatDisplayHolder: null,
	_chatDisplay: null,
	_inputArea: null,
	_messages: null,
	_status: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Todo an example
	 */
	initialize: function(options) {
		options.title = "Text chat";
		options.width = 318;
		
		deadline.gui.chat.ChatWindow.prototype.initialize.call(this, options);
		
		this.addClass("TextChat");
		this._messages = [];
	},
	
	_getChatActionButton: function() {
		return new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.chat.TextChat.send"), onclick: this._sendChat.bind(this)});
	},
	
	_getChatArea: function() {
		this._chatDisplay = DOMUtil.createElement("div");
		this._chatDisplayHolder = DOMUtil.createTextElement("div", this._chatDisplay, {className: "TextChatDisplayHolder"});
		
		this._inputArea = new behaviour.gui.updateables.UpdateableTextArea({inlineInstruction: Language.get("deadline.gui.chat.TextChat.typesomething")});
		this._inputArea.setEditMode(true);
		this._inputArea.registerListener("onkeyup", this._keyWatcher.bind(this));
		
		this._chatMovie = new deadline.gui.chat.TextChatMovie({chat: this, chatId: this.options.chatId});
		
		return DOMUtil.createTextElement("div", [
			this._chatDisplayHolder,
			this._inputArea,
			this._chatMovie
		]);
	},
	
	inviteParticipants: function() {
		Broadcaster.callFlashFunction("callRemoteFunction", {staff: this.getParticipants(), functionName: "deadline.gui.chat.TextChat.initiateChat", args: [User.getId(), this.options.chatId]});
	},
	
	inviteParticipant: function(staffId) {
		Broadcaster.callFlashFunction("callRemoteFunction", {staff: [staffId], functionName: "deadline.gui.chat.TextChat.initiateChat", args: [User.getId(), this.options.chatId]});
	},
	
	_keyWatcher: function(textArea, event) {
		
		if(event.keyCode == Event.KEY_RETURN && !event.shiftKey) {
			this._sendChat();
			this._inputArea.inputField.focus();
			this.setStatus(1);
		} else {
			if(this._inputArea.getValue().strip() == "") {
				this.setStatus(1);
			} else {
				this.setStatus(2);
			}
		}
	},
	
	_sendChat: function() {
		deadline.gui.chat.ChatWindow.prototype._sendChat.call(this);
		
		var message = this._inputArea.getValue().strip();
		
		this._inputArea.setValue("");
		
		if(message == "") {
			return;
		}
		
		this._chatMovie.callFlashFunction("sendMessage", [escape(message)]);
		this.setStatus(1);
	},
	
	receivedMessage: function(chatter, message) {
		message = unescape(message);
		
		// store message
		this._messages.push({time: new Date(), chatter: chatter, message: message});
		
		var staff = currentPage.getEntity(chatter, "staff", "Staff");
		
		var messageDisplay = DOMUtil.createTextElement("div", [ 
			staff.getAvatarImage(true),
			DOMUtil.createTextElement("p", [
				staff.getFullname(),
				" ",
				DateFormatter.getFormattedDate({date: new Date()})
			], {className: "TextChatDateDisplay"}),
			BehaviourUtil.formatText(message)
		], {className: "TextChatMessage"});
		
		DOMUtil.addClass(messageDisplay, (this._messages.length % 2 == 0) ? "TextChatEvenMessage" : "TextChatOddMessage");
		
		if(chatter != User.getId()) {
			DOMUtil.addClass(messageDisplay, "TextChatRemoteMessage");
		}
		
		DOMUtil.append(messageDisplay, this._chatDisplay);
		
		this._scrollChatToBotton();
		
		if(!this.isFrontMostWindow()) {
			SoundBank.playChatMessageWhenInactive();
		}
	},
	
	_scrollChatToBotton: function() {
		// scroll to the bottom
		var height = Element.getHeight(this._chatDisplay);
		this._chatDisplayHolder.scrollTop = height;
	},
	
	chatterLeft: function(staffId) {
		var staff = currentPage.getEntity(staffId, "staff", "Staff");
		
		staff.registerListener("onDataLoaded", function() {
			this._showNotification(Language.getFormatted("deadline.gui.chat.TextChat.participantleftchat", {staffName: staff.getFullname()}));
		}.bind(this));
	},
	
	chatterJoined: function(staffId) {
		var staff = currentPage.getEntity(staffId, "staff", "Staff");
		
		staff.registerListener("onDataLoaded", function() {
			this._showNotification(Language.getFormatted("deadline.gui.chat.TextChat.participantjoinedchat", {staffName: staff.getFullname()}));
		}.bind(this));
	},
	
	setStatus: function(status) {
		if(this._status != status) {
			this._status = status;
			this._chatMovie.callFlashFunction("sendStatus", [this._status]);
		}
	},
	
	_showNotification: function(text) {
		var messageDisplay = DOMUtil.createTextElement("div", [ 
			DOMUtil.createTextElement("p", text)
		], {className: "TextChatNotification"});
		
		DOMUtil.append(messageDisplay, this._chatDisplay);
		
		this._scrollChatToBotton();
	},
	
	_showNoParticipantsMessage: function() {
		this._showNotification(Language.get("deadline.gui.chat.TextChat.noparticipantsinchat"));
	},
	
	_showNoParticipantsAcceptedMessage: function() {
		this._showNotification(Language.get("deadline.gui.chat.TextChat.noparticipantsacceptedchat"));
	}
});

/**
 * Called remotely by other staff initiating a chat
 */
deadline.gui.chat.TextChat.initiateChat = function(requestingStaffId, chatId) {
	Log.info("incoming chat invite for " + chatId + " from " + requestingStaffId);
	
	var chat = new deadline.gui.chat.TextChat({participants: [currentPage.getEntity(requestingStaffId, "staff", "Staff")], chatId: chatId});
	chat.appear();
	
	SoundBank.playStartChat();
}

/**
 * @class deadline.gui.button.WhosOnlineButton
 * @extends behaviour.gui.button.GUIButton 
 */
deadline.gui.button.WhosOnlineButton = Class.create(behaviour.gui.button.GUIButton, {
	
	_chooserWindow: null,
	_panels: null,
	_initialLoad: null,
	_showStaffButton: null,
	_showDesksButton: null,
	_showStoriesButton: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		options = {
			buttonText: "Online",
			onclick: this._toggleWindow.bind(this)
		};
		
		$super(options);
		
		this.addClass("WhosOnlineButton");
		
		this._initialLoad = true;
		this._chooserWindow = DOMUtil.createTextElement("div", [], {className: "WhosOnlineChooserWindow"});
		this._chooserWindow.style.display = "none";
		document.body.appendChild(this._chooserWindow);
		
		var typeTabs = new deadline.gui.button.Tabs({attributes: {id: "headerButtons"}});
		this._showStaffButton = typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.button.WhosOnlineButton.staff"), rememberDownState: true, startDown: true, onclick: this._changeType.bind(this, "staff")}));
		this._showDesksButton = typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.button.WhosOnlineButton.desks"), rememberDownState: true, onclick: this._changeType.bind(this, "desks")}));
		this._showStoriesButton = typeTabs.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.button.WhosOnlineButton.stories"), rememberDownState: true, onclick: this._changeType.bind(this, "stories")}));
		
		var tabPanel = new behaviour.gui.panel.Panel();
		tabPanel.appendChild(typeTabs);
		
		this._panels = new behaviour.gui.panel.DualPanel({direction: "vertical"});
		this._panels.setPanel1(tabPanel);
		this._panels.appendTo(this._chooserWindow);
		
		var toggleWindowOnClickFunction = function(event) {
			if(this._chooserWindow.style.display == "block" && !DOMUtil.elementWasClickedOn(event, this._chooserWindow)) {
				this._toggleWindow();
			}
		}.bind(this);
		
		Event.observe(document, "click", toggleWindowOnClickFunction);
	},
	
	_toggleWindow: function() {
		if(this._chooserWindow.style.display == "block") {
			this._chooserWindow.style.display = "none";
			this._initialLoad = true;
		} else {
			this._chooserWindow.style.display = "block";
			
			if(this._initialLoad) {
				this._initialLoad = false;
				this._showStaff();
			}
		}
	},
	
	_changeType: function(type) {
		if(type == "staff") {
			this._showStaff();
		} else if(type == "desks") {
			this._showDesks();
		} else if(type == "stories") {
			this._showStories();
		}
	},
	
	_showStaff: function() {
		var panel = new behaviour.gui.panel.ScrollableHolder();
		panel.appendChild(new behaviour.gui.LoadingNotification())
		
		this._panels.setPanel2(panel);
		this._panels.render();
		
		var callbackID = FlashBridge.registerFunction(this._showStaffList.bind(this));
		
		Broadcaster.callFlashFunction("getOnlineClients", {callbackID: callbackID});
	},
	
	_showStaffList: function(clients) {
		this._showStaffButton.setDown(true);
		
		var staff = [];
		
		clients.each(function(id){
			if(id != User.getId()) {
				staff.push(currentPage.getEntity(id, "staff", "Staff"));
			}
		});
		
		if(staff.length == 0) {
			this._panels.getPanel2().empty();
			this._panels.getPanel2().appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.button.WhosOnlineButton.noonlinestaff"), {className: "notice"}));
			return;
		}
		
		var table = new behaviour.gui.table.SortableTable({
			entities: staff,
			headerRows: [Language.get("deadline.gui.button.WhosOnlineButton.video"), Language.get("deadline.gui.button.WhosOnlineButton.text"), Language.get("deadline.gui.button.WhosOnlineButton.name")],
			columnData: [{
					text: function(staff) {
						return new deadline.gui.button.VideoChatIcon({onclick: this._startVideoChat.bind(this, staff, "staff")});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(staff) {
						return new deadline.gui.button.TextChatIcon({onclick: this._startTextChat.bind(this, staff, "staff")});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(staff) {
						return staff.getPropertyDisplay({property: "fullname"});
					}
				}
			]
		});
		
		this._panels.getPanel2().empty();
		this._panels.getPanel2().appendChild(table);
	},
	
	_showDesks: function() {
		this._showDesksButton.setDown(true);
		
		var table = new behaviour.gui.table.SortableTable({
			entities: User.getDesks(),
			headerRows: [Language.get("deadline.gui.button.WhosOnlineButton.video"), Language.get("deadline.gui.button.WhosOnlineButton.text"), Language.get("deadline.gui.button.WhosOnlineButton.title")],
			columnData: [{
					text: function(desk) {
						return new deadline.gui.button.VideoChatIcon({onclick: this._startVideoChat.bind(this, desk, "desk")});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(desk) {
						return new deadline.gui.button.TextChatIcon({onclick: this._startTextChat.bind(this, desk, "desk")});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(desk) {
						return desk.getPropertyDisplay({property: "title"});
					}
				}
			]
		});
		
		this._panels.getPanel2().empty();
		this._panels.getPanel2().appendChild(table);
	},
	
	_showStories: function() {
		this._showDesksButton.setDown(true);
		
		var list = new behaviour.gui.tree.ScrollLoadTree({
			noEntitiesText: Language.get("deadline.gui.button.WhosOnlineButton.nostories"),
			rowHeight: 21,
			createEntity: function(data, index) {
				if(typeof(data) != "undefined") {
					var type = data["type"];
					delete data["type"];
					
					if(type == "story") {
						return currentPage.getEntity(data, "stories", "Story");
					} else if(type == "assignment") {
						return currentPage.getEntity(data, "assignments", "Assignment");
					}
					
					Log.warn("Unknown entity type for WhosOnlineButton - " + type);
				}
				
				return false;
			}.bind(this),
			url: "/backend/stories/load",
			startSorted: {
				column: 0,
				direction: "DESC"
			},
			args: {
				omitSharedFolders: true
			}
		});
		list.addClass("StoryList");
		
		list.addLevel({
			text: function(story) {
				return DOMUtil.createTextElement("span", [
					new deadline.gui.button.VideoChatIcon({onclick: this._startVideoChat.bind(this, story, "story")}),
					new deadline.gui.button.TextChatIcon({onclick: this._startTextChat.bind(this, story, "story")}),
					story.getPropertyDisplay({property: "title"})
				]);
			}.bind(this), 
			collapsible: true
		});
		
		list.addLevel({
			propertyName: "assignments", 
			text: function(assignment) {
				return DOMUtil.createTextElement("span", [
					new deadline.gui.button.VideoChatIcon({onclick: this._startVideoChat.bind(this, assignment, "assignment")}),
					new deadline.gui.button.TextChatIcon({onclick: this._startTextChat.bind(this, assignment, "assignment")}),
					assignment.getPropertyDisplay({property: "title"})
				]);
			}.bind(this)
		});
		
		this._panels.getPanel2().empty();
		this._panels.getPanel2().appendChild(list);
	},
	
	_startVideoChat: function(entity, type) {
		this._startChat(deadline.gui.chat.VideoChat, type, entity);
	},
	
	_startTextChat: function(entity, type) {
		this._startChat(deadline.gui.chat.TextChat, type, entity);
	},
	
	_startChat: function(chatClass, type, entity) {
		if(type == "staff") {
			var chat = new chatClass({participants: [entity]});
			chat.appear();
		} else if(type == "desk") {
			new behaviour.ajax.JSONRequest({
				url: "/backend/desks/getAllStaff", 
				args: {
					desk: entity.getId()
				}, 
				onSuccess: function(serverResponse, json) {
					var participants = [];
					
					json.each(function(staff){
						if(staff.id != User.getId()) {
							participants.push(currentPage.getEntity(staff, "staff", "Staff"));
						}
					});
					
					var chat = new chatClass({participants: participants});
					chat.appear();
				}
			});
		} else if(type == "story") {
			new behaviour.ajax.JSONRequest({
				url: "/backend/stories/getAllStaff", 
				args: {
					story: entity.getId()
				}, 
				onSuccess: function(serverResponse, json) {
					var participants = [];
					
					json.each(function(staff){
						if(staff.id != User.getId()) {
							participants.push(currentPage.getEntity(staff, "staff", "Staff"));
						}
					});
					
					var chat = new chatClass({participants: participants});
					chat.appear();
				}
			});
		} else if(type == "assignment") {
			new behaviour.ajax.JSONRequest({
				url: "/backend/assignments/getAllStaff", 
				args: {
					assignment: entity.getId()
				}, 
				onSuccess: function(serverResponse, json) {
					var participants = [];
					
					json.each(function(staff){
						if(staff.id != User.getId()) {
							participants.push(currentPage.getEntity(staff, "staff", "Staff"));
						}
					});
					
					var chat = new chatClass({participants: participants});
					chat.appear();
				}
			});
		}
	}
});

/**
 * @class deadline.gui.button.PersonaliseLogOut 
 * @extends behaviour.gui.button.ButtonHolder 
 */
deadline.gui.button.PersonaliseLogOut = Class.create(behaviour.gui.button.ButtonHolder, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("PersonaliseLogOut");
		
		this.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.gui.button.PersonaliseLogOut.logout"), onclick: this.logOut.bind(this), attributes: {className: "signout"}}));
		
		if(!this.options.noOnlineButton) {
			this.addButton(new deadline.gui.button.WhosOnlineButton());
		}
	},
	
	logOut: function() {
		new behaviour.ajax.JSONRequest({url: "/backend/signOut", onSuccess: this.options.afterSignout ? this.options.afterSignout : function() {
				document.location = "/";
			}
		});
	}
});
/**
 * @class deadline.web.SoundBank 
 */
deadline.web.SoundBank = new Class.create({
	/**
	 * Constructor
	 */
	initialize: function() {
		behaviour.lang.Watchable.registerGlobalListener("onError", this.playError.bind(this));
	},
	
	_playSound: function(file) {
		if(!User.getPreference(deadline.constants.DEADLINE_PREFERENCES_NOAUDIO)) {
			Sound.play("/audio/" + file + ".mp3", {replace: true});
		}
	},
	
	playError: function() {
		this._playSound("error");
	},
	
	playMessageSent: function() {
		this._playSound("messagesent");
	},
	
	playStartChat: function() {
		this._playSound("startchat");
	},
	
	playChatMessageWhenInactive: function() {
		this._playSound("chatmessagewheninactive");
	}
});

/**
 * @class deadline.gui.button.Tabs 
 * @extends behaviour.gui.button.ButtonHolder 
 */
deadline.gui.button.Tabs = Class.create(behaviour.gui.button.ButtonHolder, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("Tabs");
			this.options.fixedHeight = true;
		}
});

/**
 * @class deadline.gui.button.NavigationTabs
 * @extends deadline.gui.button.Tabs
 */
deadline.gui.button.NavigationTabs = new Class.create(deadline.gui.button.Tabs, {
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("NavigationTabs");
		this.options.fixedHeight = true;
	}
});

/**
 * @class deadline.page.Page
 * @extends behaviour.page.Page
 */
deadline.page.Page = new Class.create(behaviour.page.Page, {
	
	/** used to restrict which portions of the langauge file are loaded */
	languageSection: null,
	
	/** needed by Internet Explorer for the back button to work */
	backButtonFixer: null,
	
	/** feed reader display */
	_feedReader: null,
	
	/** which url fragment to use */
	_entityDisplayURL: null,
	
	/**
	 * Constructor!
	 */
	initialize: function($super, args) {
		$super(args);
		
		NotificationArea = new deadline.gui.notificationArea.NotificationArea();
		NotificationArea.appendTo(document.body);
		Language.load({section: this.languageSection, postLoad: this._languageLoaded.bind(this)});
	},
	
	/**
	 * @private
	 * Language has loaded, get server config data
	 */
	_languageLoaded: function() {
		try {
			new behaviour.ajax.JSONRequest({url: "/backend/getConfigData", onSuccess: this._gotConfig.bind(this)});
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 * Got server config data, get user details
	 */
	_gotConfig: function(serverResponse, json) {
		ServerConfig = json;
		
		try {
			new behaviour.ajax.JSONRequest({url: "/backend/user/get", onSuccess: this._gotUser.bind(this)});
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 * Got user details, call post-constructor on concrete subclass
	 */
	_gotUser: function(serverResponse, json) {
		try {
			// add data wrapper to staff
			if(json.desks) {
				currentPage.addEntities(json.desks, "desks", "Desk");
			}
			
			if(json.roles) {
				currentPage.addEntities(json.roles, "roles", "Role");
			}
			
			User = new deadline.entities.User({data: json.user});
			Organisation = new deadline.entities.Organisation({data: json.organisation});
			
			// add the broadcaster to the page
			Broadcaster = new deadline.web.Broadcaster();
			Broadcaster.appendTo(document.body);
			
			// create sound bank
			SoundBank = new deadline.web.SoundBank();
			
			if(this.staff && json.staff) {
				this.staff.addElement(new deadline.entities.Staff({data: json.staff}));
			}
			
			// set date format
			if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_DATEFORMAT) != null) {
				var format = User.getPreference(deadline.constants.DEADLINE_PREFERENCES_DATEFORMAT);
			} else {
				var format = Organisation.getDateformat();
			}
			
			DateFormatter.setDateFormatter(new behaviour.date["DateFormat" + format]({date: new Date()}));
			
			this._getTabs().each(function(tabs) {
				tabs.appendTo($("header"));
			});
			
			// add personalise/sign out buttons to page
			var buttonHolder = new deadline.gui.button.PersonaliseLogOut();
			buttonHolder.render();
			$("header").insertBefore(buttonHolder.getRootNode(), $("header").getElementsByTagName("h1")[0]);
					
			this.init();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_getTabs: function() {
		var tabs = [
			new deadline.gui.button.NavigationTabs({ignoreKeyPresses: true}),
			new deadline.gui.button.NavigationTabs({ignoreKeyPresses: true, attributes: {className: "secondary_tabs"}})
		];
		
		tabs[0].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.home"), anchor: "/home/", rememberDownState: true, startDown: this.languageSection == "home"}));
		tabs[0].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.personalise"), anchor: "/personalise/", rememberDownState: true, startDown: this.languageSection == "personalise"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.write"), anchor: "/write/", rememberDownState: true, startDown: this.languageSection == "write"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.messages"), anchor: "/messages/", rememberDownState: true, startDown: this.languageSection == "messages"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.events"), anchor: "/events/", rememberDownState: true, startDown: this.languageSection == "events"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.stories"), anchor: "/stories/", rememberDownState: true, startDown: this.languageSection == "stories"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.staff"), anchor: "/staff/", rememberDownState: true, startDown: this.languageSection == "staff"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.contacts"), anchor: "/contacts/", rememberDownState: true, startDown: this.languageSection == "contacts"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.assets"), anchor: "/assets/", rememberDownState: true, startDown: this.languageSection == "assets"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.interviews"), anchor: "/interviews/", rememberDownState: true, startDown: this.languageSection == "interviews"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.packages"), anchor: "/packages/", rememberDownState: true, startDown: this.languageSection == "packages"}));
		tabs[1].addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.page.Page.reports"), anchor: "/reports/", rememberDownState: true, startDown: this.languageSection == "reports"}));
		
		return tabs;
	},
	
	/**
	 * Add entities to the page
	 * @param {Array} entityArray
	 * @param {behaviour.lang.DataHolder} dataHolder
	 * @param {Object} entityType
	 * @return {Array} output
	 */
	addEntities: function(entityArray, dataHolder, entityType) {
		var output = [];
		
		if(!deadline.entities[entityType]) {
			Log.warn("Unknown data type - deadline.entities." + entityType);
		}
		
		if(!this[dataHolder]) {
			this[dataHolder] = new behaviour.lang.DataHolder();
		}
		
		if(entityArray) {
			if(entityArray instanceof Array) {
				entityArray.each(function(entityData){
					output.push(this.addEntity(entityData, dataHolder, entityType));
				}.bind(this));
			} else {
				output.push(this.addEntity(entityArray, dataHolder, entityType));
			}
		}
		
		return output;
	},
	
	/**
	 * Returns new entity
	 * @param {Object} entityData
	 * @param {behaviour.lang.DataHolder} dataHolder
	 * @param {Object} entityType
	 * @return {Object} newEntity
	 */
	addEntity: function(entityData, dataHolder, entityType) {
		if(typeof(deadline.entities[entityType]) == "undefined") {
			Log.warn("deadline.entities." + entityType + " undefined - has it been imported?");
		}
		
		var newEntity = new deadline.entities[entityType]({data: entityData});
		
		if(typeof(this[dataHolder]) == "undefined" || typeof(this[dataHolder].addElement) == "undefined") {
			Log.warn("No data holder for entity type " + dataHolder);
		}
		
		this[dataHolder].addElement(newEntity);
		return newEntity;
	},
	
	/**
	 * Getter for Entities
	 * @param {Array} entityArray
	 * @param {behaviour.lang.DataHolder} dataHolder
	 */
	getEntities: function(entityArray, dataHolder) {
		if(this[dataHolder] && entityArray) {
			for(var i = 0; i < entityArray.length; i++) {
				var entity = this[dataHolder].getElement(entityArray[i]);
				
				if(entity) {
					entityArray[i] = entity;
				}
			}
		}
	},
	
	/**
	 * Getter for a single Entity
	 * @param {String} entityID A GUID or an object
	 * @param {behaviour.lang.DataHolder} dataHolder
	 * @param {Object} oldValue
	 */
	getEntity: function(entityID, dataHolder, className) {
		try {
			if(!this[dataHolder]) {
				this[dataHolder] = new behaviour.lang.DataHolder();
			}
			
			if(!deadline.entities[className]) {
				throw "Cannot instantiate deadline.entities." + className;
			}
			
			var entity;
	
			if(entityID == null || Object.isUndefined(entityID)) {
				entity = new deadline.entities[className]();
			} else {
				if(BehaviourUtil.isGUID(entityID)) {
					entity = this[dataHolder].getElement(entityID);
				} else if(entityID.id) {
					entity = this[dataHolder].getElement(entityID.id);
				}
			}
			
			if(!entity) {
				if(BehaviourUtil.isGUID(entityID)) {
					entity = new deadline.entities[className]({data: {id: entityID}});
				} else {
					entity = new deadline.entities[className]({data: entityID});
				}
				
				this[dataHolder].addElement(entity);
			}
			
			return entity;
		} catch(e) {
			Log.dumpException(e);
			Log.error(entityID + " " + dataHolder + " " + className);
		}
	},
	
	/**
	 * Needs to be overriden in child classes
	 */
	createDefaultTree: function() {
		Log.warn("Non-overriden call to deadline.page.Page#createDefaultTree");
	},
	
	/**
	 * Reloads the tree
	 */
	reloadTreeList: function() {
		if(this._treeList) {
			this._treeList.reloadEntities();
		}
	},
	
	/**
	 * @param {Object} entity
	 */
	setEntityDown: function(entity) {
		if(!this._treeList) {
				this.createDefaultTree();
		}
		
		if(!this._treeList.dataLoaded()) {
			this._treeList.registerOneTimeListener("onEntitiesLoaded", this._treeList.setDown.bind(this._treeList, entity));
		} else {
			this._treeList.setDown(entity);
		}
	},
	
	/**
	 * @private
	 */
	_showTab: function(url) {
		if(!EditWatcher.changesOutstanding()) {
			document.location = url;
			return true;
		}
		
		return false;
	},
	
	/**
	 * @private
	 */
	_showEntity: function(entity, panel, overrideID) {
		if(!entity.equals(this._currentEntity)) {
			if(!this._treeList) {
				this.createDefaultTree();
			}
			
			if(entity.isNew()) {
				this._treeList.clearDown();
			} else {
				this.setEntityDown(overrideID ? overrideID : entity);
			}
			
			this._currentEntity = entity;
			this._panels.setPanel2(new panel({entity: this._currentEntity, doNotShowFirstPanel: overrideID ? true : false}));
			this._panels.getPanel2().render();
			LayoutManager.resizePanels();
		}
	},
	
	/**
	 * Shows the first entity from the tree list
	 */
	showFirstEntity: function() {
		if(this._treeList.getFirstEntity() && BehaviourUtil.getKey(this._treeList.getFirstEntity())) {
			window.location = "#" + this._entityDisplayURL + "/" + BehaviourUtil.getKey(this._treeList.getFirstEntity());
		} else {
			this.showHelp();
		}
	},
	
	/**
	 * Shows a help panel
	 */
	showHelp: function() {
		if(this._treeList) {
			this._treeList.clearDown();
		}
		
		this._currentEntity = null;
		this._panels.setPanel2(this._getHelpPanel());
		this._panels.resize();
	},
	
	/**
	 * @private
	 * 
	 * Should return a help panel
	 */
	_getHelpPanel: function() {
		Log.warn("Non-overriden call to deadline.page.Page#_getHelpPanel");
	}
});

/**
 * @class deadline.gui.button.NextButton 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.NextButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("NextButton");
	}
});

/**
 * @class deadline.gui.button.PreviousButton 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.PreviousButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("PreviousButton");
	}
});

/**
 * @class deadline.gui.FeedReader
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.FeedReader = new Class.create(behaviour.gui.GUIWidget, {
	
	_items: null,
	_itemDisplay: null,
	_currentItemIndex: null,
	_nextItemTimeout: null,
	_nextItemButton: null,
	_previousItemButton: null,
	
	/**
	 * Constructor!  
	 * Supports the following options: 
	 * options: {
	 * 		url: String		// where to load the feed items from
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("FeedReader");
	},
	
	/**
	 * Overrided {behaviour.gui.GUIWidget} appendTo() method
	 */
	appendTo: function($super, node) {
		$super(node);
		
		this.loadItems();
	},
	
	/**
	 * Render
	 */
	render: function() {
		this.empty();
		
		this._nextItemButton = new deadline.gui.button.NextButton({onclick: this._showNextItem.bind(this)});
		this.appendChild(this._nextItemButton);
		
		this._previousItemButton = new deadline.gui.button.PreviousButton({onclick: this._showPreviousItem.bind(this)});
		this.appendChild(this._previousItemButton);
		
		this._itemDisplay = DOMUtil.createElement("div", {className: "FeedReader_feedItemDisplayArea"});
		
		var itemDisplayHolder = DOMUtil.createElement("div", {className: "FeedReader_feedItemDisplayHolder"});
		itemDisplayHolder.appendChild(this._itemDisplay);
		this.appendChild(itemDisplayHolder);
	},
	
	/**
	 * @private
	 */
	loadItems: function() {
		this._nextItemButton.setDisabled(true);
		this._previousItemButton.setDisabled(true);
		
		DOMUtil.emptyNode(this._itemDisplay);
		new behaviour.gui.LoadingNotification({text: Language.get("deadline.gui.FeedReader.loadingitems")}).appendTo(this._itemDisplay);
		
		new behaviour.ajax.JSONRequest({
			url: this.options.url, 
			onSuccess: this._loadedItems.bind(this), 
			method: "post"
		});
	},
	
	/**
	 * @private
	 */
	_loadedItems: function(serverResponse, json) {
		this._items = json.items;
		
		if(this._items.length > 0) {
			this._nextItemButton.setDisabled(false);
			this._previousItemButton.setDisabled(false);
		}
		
		this._currentItemIndex = -1;
		this._showNextItem();
	},
	
	/**
	 * @private
	 */
	_showNextItem: function() {
		this._clearInterval();
		
		if(this._currentItemIndex < (this._items.length - 1)) {
			this._showItem(this._currentItemIndex + 1);
		} else {
			this._showItem(0);
		}
		
		this._nextItemTimeout = setInterval(this._showNextItem.bind(this), 5000);
	},
	
	/**
	 * @private 
	 */
	_showPreviousItem: function() {
		this._clearInterval();
		
		if(this._currentItemIndex > 0) {
			this._showItem(this._currentItemIndex - 1);
		} else {
			this._showItem(this._items.length - 1);
		}
		
		this._nextItemTimeout = setInterval(this._showPreviousItem.bind(this), 5000);
	},
	
	/**
	 * @private
	 */
	_showItem: function(index) {
		this._currentItemIndex = index;
		
		Effect.Fade(this._itemDisplay, {duration: 0.2, afterFinish: function(){
			DOMUtil.emptyNode(this._itemDisplay);
		
			if(this._items.length > 0) {
				var item = this._items[this._currentItemIndex];
				this._itemDisplay.appendChild(DOMUtil.createTextElement("p", DOMUtil.createTextElement("a", [DOMUtil.createTextElement("span", item.channelTitle), ' - ' + item.title], {href: item.link, target: "_new"})));
			} else {
				this._itemDisplay.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.FeedReader.noitems")));
				this._clearInterval();
			}
			
			Effect.Appear(this._itemDisplay);
		}.bind(this)});
	},
	
	/**
	 * @private
	 */
	_clearInterval: function() {
		if(this._nextItemTimeout) {
			clearInterval(this._nextItemTimeout);
		}
	}
});

/**
 * @class deadline.gui.panel.HeaderPanel
 * @extends behaviour.gui.panel.DualPanel
 */
deadline.gui.panel.HeaderPanel = new Class.create(behaviour.gui.panel.DualPanel, {
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.options.fixedHeight = true;
		
		this.addClass("HeaderPanel");
		
		if(this.options.headerLeft) {
			this.setHeaderLeft(this.options.headerLeft);
		}
		
		if(this.options.headerRight) {
			this.setHeaderRight(this.options.headerRight);
		}
	},
	
	/**
	 * Adds node to the Panel2
	 */
	setHeaderLeft: function(node) {
		if(!node) {
			this.setPanel2();
			return;
		}
		
		if(Object.isString(node) || Object.isArray(node)) {
			node = DOMUtil.createTextElement("h2", node);
		}
		
		DOMUtil.addClass(node, "HeaderPanelHeaderLeft");
		return this.setPanel2(node);
	},
	
	/**
	 * Adds node to the Panel1
	 */
	setHeaderRight: function(node) {
		if(!node) {
			this.setPanel1();
			return;
		}
		
		if(Object.isString(node) || Object.isArray(node)) {
			node = DOMUtil.createTextElement("h3", node);
		}
		
		DOMUtil.addClass(node, "HeaderPanelHeaderRight");
		return this.setPanel1(node);
	},
	
	/**
	 * @private
	 */
	_createHeader: function(node, type) {
		return DOMUtil.createTextElement(type, node);
	}
});
/**
 * @class deadline.gui.layout.LayoutManager
 * 
 */
deadline.gui.layout.LayoutManager = new Class.create({
	
	options: null,
	_feedReader: null,
	_availableSize: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function(options) {
		this._feedReader = options.feedReader;
		this.options = options;
	},
	
	/**
	 * Sizes a scrollable in the context of it's containing node.  E.g. will get the height of a header, subtract it from the available height,
	 * and make the scrollable the height of the remainder.
	 * @private
	 */
	_sizeScrollable: function(scrollable, dim, maxSize) {
		if(scrollable) {
			var nodeList = $A(scrollable.parentNode.childNodes);
			
			nodeList.each(function(node){
				if(node && node != scrollable) {
					var dims = Element.getDimensions(node);
					maxSize = maxSize - dims[dim];
				}
			});
		
			scrollable.style[dim] = maxSize + "px";
			
			if(scrollable.owner) {
				Log.info("triggering onresize");
				scrollable.owner().triggerEvent("onResize");
			}
		}
	},
	
	/**
	 * @private
	 */
	_sizeResizeable: function(holder, panel1, panel2, resizer, dim) {
		if(typeof(holder) != "undefined" && typeof(panel1) != "undefined" && typeof(panel2) != "undefined" && typeof(resizer) != "undefined") {
			var holderDims = Element.getDimensions(holder);
			var panel1Dims = Element.getDimensions(panel1);
			
			if(dim == "horizontal") {
				if(panel2.childNodes && panel2.childNodes[1] && panel2.childNodes[1].minimised) {
					var panel2Dims = Element.getDimensions(panel2);
					panel1Dims.width = (holderDims.width - panel2Dims.width - 22);
					panel1.style.width = panel1Dims.width + "px";
				} else {
					panel2.style.width = (holderDims.width - panel1Dims.width - 22) + "px";
				}
	
				resizer.style.left = panel1Dims.width + "px";
				resizer.style.width = "22px";
				resizer.style.height = holderDims.height + "px";
				
				panel2.style.left = panel1Dims.width + 22 + "px";
				panel2.style.height = holderDims.height + "px";
			} else {
				if(panel2.childNodes && panel2.childNodes[1] && panel2.childNodes[1].minimised) {
					var panel2Dims = Element.getDimensions(panel2);
					panel1Dims.height = (holderDims.height - panel2Dims.height - 22);
					panel1.style.height = panel1Dims.height + "px";
				} else if(panel1.childNodes && panel1.childNodes[1] && panel1.childNodes[1].minimised) {
					panel1Dims.height = 34;
					panel1.style.height = panel1Dims.height + "px";
					panel2.style.height = (holderDims.height - panel1Dims.height - 22) + "px";
				} else {
					panel2.style.height = (holderDims.height - panel1Dims.height - 22) + "px";
				}
				
				resizer.style.top = panel1Dims.height + "px";
				resizer.style.width = holderDims.width + "px";
				resizer.style.height = "22px";
				
				panel2.style.top = panel1Dims.height + 22 + "px";
				panel2.style.width = holderDims.width + "px";
			}
	
			panel1.owner().triggerEvent("onResize");
			panel2.owner().triggerEvent("onResize");
		}
	},
	
	/**
	 * Resize panels
	 */
	resizePanels: function() {
		var rootNode = this.options.panel.getRootNode();
		
		if(rootNode && rootNode.parentNode) {
			var dims = Element.getDimensions(rootNode.parentNode);
			
			this.options.panel.setStyle("height", dims.height + "px");
			this.options.panel.setStyle("width", dims.width + "px");
			this.options.panel.resize();
		}
	}
});

/**
 * @class deadline.gui.layout.OnePanelLayoutManager
 * @extends deadline.gui.layout.LayoutManager
 */
deadline.gui.layout.PageLayoutManager = new Class.create(deadline.gui.layout.LayoutManager, {
	
	/**
	 * Resize panels accordingly
	 */
	resizePanels: function() {
		 try { 
			this.resizeMainPanel();
			this.options.panel.resize();
		} catch(e) { 
			Log.dumpException(e); 
		}
	},
	
	resizeMainPanel: function() {
		if(!this.options.panel.getRootNode().parentNode) {
			return;
		}
		
		if(this._feedReader && this.options.panel) {
			this.options.panel.setStyle("position", "absolute");
			this.options.panel.setStyle("top", "47px");
		}
		
		var screenSize = BehaviourUtil.getWindowSize();
		screenSize = Element.getDimensions(this.options.panel.getRootNode().parentNode);
		
		if(this.options.feedReader) {
			this.options.panel.setStyle("height", Math.abs(screenSize.height - 48) + "px");
		} else {
			this.options.panel.setStyle("height", (screenSize.height) + "px");
		}
		
		this.options.panel.setStyle("width", (screenSize.width) + "px");
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableTextField A single line HTML text input field.
 * @extends behaviour.gui.updateables.UpdateableFieldWithInstruction 
 */
behaviour.gui.updateables.UpdateableTextField = new Class.create(behaviour.gui.updateables.UpdateableFieldWithInstruction, {
	
	inputField: null,
	
	/**
	 * @param {Object} options 
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		searchBox: boolean				// if true will render a mac like search box on Safari
	 * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("UpdateableTextField");
	},
	
	/**
	 * Creates an editable representation of this field
	 */
	createEditField: function() {
		this.inputField = this._createEditField();
		
		if(this.options.inlineInstruction) {
			if(this.inputField.value == this.options.inlineInstruction || this.inputField.value == "") {
				this._showInstruction();
				Event.observe(this.inputField, "blur", this.blurInstructionField.bindAsEventListener(this));
				Event.observe(this.inputField, "focus", this.focusInstructionField.bindAsEventListener(this));
			}
		}
		
		Event.observe(this.inputField, "blur", this._processEventCallback.bindAsEventListener(this, "onblur"));
		Event.observe(this.inputField, "focus", this._processEventCallback.bindAsEventListener(this, "onfocus"));
		Event.observe(this.inputField, "change", this._processEventCallback.bindAsEventListener(this, "onchange"));
		Event.observe(this.inputField, "keydown", this._processEventCallback.bindAsEventListener(this, "onkeydown"));
		Event.observe(this.inputField, "keyup", this._processEventCallback.bindAsEventListener(this, "onkeyup"));
		Event.observe(this.inputField, "keypress", this._processEventCallback.bindAsEventListener(this, "onkeypress"));
		Event.observe(this.inputField, "click", this._processEventCallback.bindAsEventListener(this, "onclick"));
		
		Event.observe(this.inputField, "blur", function() {
			this.inputField.hasFocus = false;
		}.bind(this));
		Event.observe(this.inputField, "focus", function() {
			this.inputField.hasFocus = true;
		}.bind(this));
		
		return this.inputField;
	},
	
	_processEventCallback: function(event, type) {
		setTimeout(function() {
			if(this.options[type] && this.options[type] instanceof Function) {
				this.options[type]();
			}
			
			this.notifyListeners(type, event);
		}.bind(this), 100);
	},
	
	/**
	 * Sets a timeout to call updateLocalValue - necessary as Internet Explorer is stupid
	 * 
	 */
	preUpdateLocalValue: function(event) {
		setTimeout(this.updateLocalValue.bind(this), 10);
	},
	
	/**
	 * @private
	 */
	_createEditField: function() {
		return DOMUtil.createElement("input", {
			type: (this.options.searchBox && Browser.Safari ? "search" : "text"),
			value: this._getDisplayValue(),
			onchange: this.updateLocalValue.bindAsEventListener(this),
			onkeydown: this.preUpdateLocalValue.bindAsEventListener(this),
			onfocus: this._clearFocusWatcher.bind(this),
			disabled: this.disabled,
			autocomplete: "off",
			oncomplete: "off"
		});		
	}
});

/**
 * @class deadline.gui.SearchBox
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.SearchBox = new Class.create(behaviour.gui.GUIWidget, {
	
	_searchBox: null,
	_searchButton: null,
	_oldSearchText: null,
	_searchTimeout: null,
	_searching: null,
	_active: null,
	_callbackKeys: null,
	
	/**
	 * Constructor
	 * Supports the following options:
	 * options: {
	 * 		doSearch: Function
	 * 		clearSearch: Function
	 * }
	 * @param {Object} options 
	 */
	initialize: function($super, options) {
		$super(options);
			
		this.setRootNode("div");
		this.addClass("WonderBarSearchPanel");
		
		this._active = false;
		
		this._callbackKeys = {};
		
		this._oldSearchText = false;
		this._searchBox = new behaviour.gui.updateables.UpdateableTextField({inlineInstruction: Language.get("deadline.gui.SearchBox.search"), searchBox: true});
		this._searchBox.setEditMode(true);
		this._searchBox.registerListener("onkeyup", this._doSearch.bind(this));
		this._searchButton = DOMUtil.createElement("input", {type: "submit", value: Language.get("deadline.gui.SearchBox.clear"), className: "searchSubmit", onclick: this._clearSearch.bind(this, false), disabled: true})
		this.appendChild(this._searchBox);
		
		if(!Browser.Safari) {
			this.appendChild(this._searchButton);
		} else {
			this._searchBox.registerListener("onclick", function() {
				if(this._oldSearchText && this._searchBox.getValue() == "") {
					this._clearSearch(true);
				}
			}.bind(this));
		}
		
		if(this.options.searchOutput) {
			this.setOutputField(this.options.searchOutput);
		}
		
		if(!this.options.searchOutput && !this.options.doSearch) {
			this.setDisabled(true);
		}
	},
	
	setOutputField: function(outputField) {
		if(this.options.searchOutput) {
			this.options.searchOutput.deRegisterListener("onEntitiesLoaded", this._callbackKeys["onEntitiesLoaded"]);
			this.options.searchOutput.deRegisterListener("onEmptyList", this._callbackKeys["onEmptyList"]);
			this.options.searchOutput.deRegisterListener("onEntitiesLoad", this._callbackKeys["onEntitiesLoad"]);
		}
		
		this.options.searchOutput = outputField;
		
		if(this.options.searchOutput) {
			this._callbackKeys["onEntitiesLoaded"] = this.options.searchOutput.registerListener("onEntitiesLoaded", this.doneSearch.bind(this));
			this._callbackKeys["onEmptyList"] = this.options.searchOutput.registerListener("onEmptyList", this._noEntities.bind(this));
			this._callbackKeys["onEntitiesLoad"] = this.options.searchOutput.registerListener("onEntitiesLoad", this._beginSearch.bind(this));
			this.setDisabled(false);
		} else {
			this.setDisabled(true);
		}
	},
	
	/**
	 * Render
	 */
	render: function() {
		
	},
	
	/**
	 * @private
	 */
	_clearSearch: function(noBlur) {
		try {
			if(!noBlur) {
				this._searchBox.setValue("");
				this._searchBox.blurInstructionField();
			}
			
			this._searchBox.removeClass("SearchBoxSearching");
			this._searchButton.disabled = true;
			this._searching = false;
			this._active = false;
			
			if(this.options.searchOutput) {
				delete this.options.searchOutput.options.args.searchTerm;
				this.options.searchOutput.reloadEntities();
				this.options.searchOutput.getScrollableHolder().removeClass("SearchOutputSearching");
			}
			
			this._oldSearchText = "";
			
			this.notifyListeners("onClearSearch");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_doSearch: function() {
		if(this._searchTimeout) {
			clearTimeout(this._searchTimeout);
		}
		
		this._searchTimeout = setTimeout(function() {
			try {
				var searchText = this._searchBox.getValue().strip();
				
				if(searchText != "") {
					if(searchText != this._oldSearchText) { // make sure that the search string has changed - eg. do not re-search on arrow key presses, etc 
						this._searchButton.disabled = false;
						this._searchBox.addClass("SearchBoxSearching");
						this._searching = true;
						this._active = true;
						
						if(this.options.doSearch) {
							this.options.doSearch(searchText);
						} else if(this.options.searchOutput) {
							this.options.searchOutput.options.args.searchTerm = searchText;
							this.options.searchOutput.reloadEntities();
							
							if(this.options.searchOutput) {
								this.options.searchOutput.getScrollableHolder().addClass("SearchOutputSearching");
							}
						}
						
						this._oldSearchText = searchText;
						
						this.notifyListeners("onDoneSearch");
					}
				} else {
					this._clearSearch(true);
				}
			} catch(e) {
				Log.dumpException(e);
			}
		}.bind(this), 250);
	},
	
	/**
	 * Removes "SearchBoxSearching" class from the DOM tree when searching is done.
	 */
	doneSearch: function() {
		if(this._searching) {
			this._searchBox.removeClass("SearchBoxSearching");
			this._searching = false;
		}
		
		this.setDisabled(false);
	},
	
	_noEntities: function() {
		if(!this._searching && !this._active) {
			this.setDisabled(true);
		}
	},
	
	_beginSearch: function() {
		if(!this._searching && this.options.searchOutput) {
			//this.options.searchOutput.getScrollableHolder().removeClass("SearchOutputSearching");
		}
	},
	
	setDisabled: function(disabled) {
		this._searchBox.setDisabled(disabled);
	},
	
	isSearching: function() {
		return this._active;
	}
});

/**
 * @class deadline.gui.ImageBrowser
 * @extends behaviour.gui.table.ScrollLoadGUIWidget
 */
deadline.gui.ImageBrowser = new Class.create(behaviour.gui.ScrollLoadGUIWidget, {
	
	_lastNumEntities: null,
	
	/**
	 * Constructor
	 * @param {mixed} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("ImageBrowser");
	},
	
	/**
	 * @private
	 */
	_workOutMovement: function() {	
		if(this._scrollingTimeout) {
			clearTimeout(this._scrollingTimeout);
		}
		
		var scrollableDimensions = Element.getDimensions(this._scrollableHolder.getRootNode());
		
		if(scrollableDimensions.height == 0) {
			return;
		}
		
		// calculate number of images in row
		var offset = this._scrollableHolder.getRootNode().scrollTop;
		var numImagesInRow = Math.floor((scrollableDimensions.width - 4)/(this.options.boxWidth + 7));
		
		if(numImagesInRow == 0) {
			numImagesInRow = 1;
		}
		
		// calculate number of visible rows
		var visibleHeight = scrollableDimensions.height;
		var rowHeight = this.options.boxHeight + 4
		var startRow = Math.floor(offset > 0 ? (offset/rowHeight) : 1);
		var endRow = Math.ceil((offset + visibleHeight)/rowHeight);
		
		// calculate number of visible images
		var startImage = (startRow * numImagesInRow) - numImagesInRow;
		var endImage = (endRow * numImagesInRow);
		
		if(this._lastRange.start != startImage || this._lastRange.end != endImage || this._initialLoad === true) {
			this._lastRange.start = startImage;
			this._lastRange.end = endImage;
			
			// load missing details
			this._loadDetails(startImage, endImage);
		}
	},
	
	/**
	 * Render
	 */
	render: function() {	
		
		var scrollTop = 0;
		
		if(this._scrollableHolder) {
			scrollTop = this._scrollableHolder.getScrollTop();
		}
		
		this.empty();
		
		if(this._initialLoad == true) {
			this.appendChild(new behaviour.gui.LoadingNotification({text: this.options.loadingText}));
		} else if(this._entities.getElements().length == 0) {
			this.appendChild(DOMUtil.createTextElement("p", this.options.noEntitiesText, {className: "ScrollLoadTableEmptyList"}));
		} else {
			try {	
				this._entities.getElements().each(function(entity, index) {
					if(entity) {
						this.appendChild(this.options.createImageView(entity, index));
					} else {
						this.appendChild(this._renderInvalidItem(index));
					}
				}.bind(this));
				
				this._lastNumEntities = this._entities.length;
			} catch(e) {
				Log.dumpException(e);
			}
		}
		
		if(this._scrollableHolder) {
			this._scrollableHolder.setScrollTop(scrollTop);
		}
	},
	
	/**
	 * @private
	 */
	_renderInvalidItem: function(index) {
		return DOMUtil.createTextElement("div", new behaviour.gui.LoadingNotification(), {
			className: "ImageBox", style: {height: this.options.boxHeight + "px", width: this.options.boxWidth+ "px"}, invalid: true
		});
	}	
});

/**
 * @class deadline.entities.File 
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.File = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/files/create",
	_retrieveURL: "/backend/files/get",
	_updateURL: "/backend/files/update",
	_deleteURL: "/backend/files/delete",
	
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates a default object.
	 * @private
	 */
	_getDefaultObject: function() {
		return Object.extend({
			uploaded: false,
			filename: "",
			filesize: "",
			archived: 0,
			credit: "",
			keywords: [],
			mimetype: 0,
			canedit: true
		}, deadline.entities.CreatedEntity.prototype._getDefaultObject.call(this));
	},
	
	/**
	 * Triggers the downloading of this asset if a file has been submitted (e.g. getFiletype() returns > 0).
	 * 
	 * @return {void}
	 */
	download: function() {
		var body = document.getElementsByTagName("body")[0];
		var form = DOMUtil.createTextElement("form", DOMUtil.createElement("input", {type: "hidden", name: "file", value: this.getId()}), {method: "post", action: "/backend/files/download"});
		body.appendChild(form);
		form.submit();
		body.removeChild(form);
	}
});

/**
 * @class behaviour.gui.button.ViewButton 
 * @extends behaviour.gui.button.IconButton 
 */
behaviour.gui.button.ViewButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("ViewButton");
	}
});

/**
 * @class deadline.gui.button.AvatarNewMessageButton 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.AvatarNewMessageButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("AvatarNewMessageButton");
	}
});

/**
 * @class deadline.messages.RecipientChooser
 * @extends behaviour.gui.GUIWidget
 */
deadline.messages.RecipientChooser = Class.create(behaviour.gui.FloatingWindow, {
	
	_recipientTable: null,
	_searchBox: null,
	_windowHeader: null,
	_typeCheckboxes: null,
	
	/**
	 * Constructor!
	 * Supports the following options:
	 * options: {
	 * 		recipientChosen: Function(recipient),
	 * 		currentRecpients: Array									// and array of recipient objects
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options.width = 300;
		options.height = 430;
		
		$super(options);
		
		this.addClass("RecipientChooser");
		
		this._typeCheckboxes = [
			DOMUtil.createElement("input", {type: "checkbox", checked: User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTAFF) ? true : false, onclick: this._changeVisibleTypes.bindAsEventListener(this)}),
			DOMUtil.createElement("input", {type: "checkbox", checked: User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTORIES) ? true : false, onclick: this._changeVisibleTypes.bindAsEventListener(this)}),
			DOMUtil.createElement("input", {type: "checkbox", checked: User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWASSIGNMENTS) ? true : false, onclick: this._changeVisibleTypes.bindAsEventListener(this)})
		];
		
		this._recipientTable = new behaviour.gui.table.ScrollLoadTable({
			numToLoad: 20,
			rowHeight: 21,
			createEntity: function(data, index) {
				if(typeof(data) != "undefined") {
					return data;
				}
				return false;
			}.bind(this),
			url: "/backend/messages/getRecipients",
			args: {
				currentRecipients: this.options.messageComposer.getRecipientIDs(),
				showTypes: this._typeCheckboxes.pluck("checked")
			},
			startSorted: {
				column: 2,
				direction: "DESC"
			},
			headerRows: [
				Language.get("deadline.shared.add"),
				Language.get("deadline.shared.type"),
				Language.get("deadline.shared.name")
			],
			columnData: [{
				text: function(recipient){
						return new behaviour.gui.button.AddButton({onclick: this._selectRecipient.bind(this, recipient)});
					}.bind(this),
					iconColumn: true
				}, {
					text: function(recipient) {
						return DOMUtil.createTextElement("a", " ", {className: "recipientTypeIcon recipientTypeIcon" + recipient.type, href: ".", onclick: this._selectRecipient.bind(this, recipient)});
					}.bind(this),
					sortField: true,
					iconColumn: true
				}, {
					text: function(recipient) {
						return recipient.title.truncate(25);
					}.bind(this),
					onclick: this._selectRecipient.bind(this),
					sortField: true
				}
			]
		});
		
		this._searchBox = new deadline.gui.SearchBox({searchOutput: this._recipientTable});
	},
	
	/**
	 * Render
	 */
	render: function() {
		DOMUtil.emptyNode(this._contentDiv);
		
		this._windowHeader = DOMUtil.createTextElement("h4", "Choose recipients for \"" + this.options.messageComposer.getMessageTitle() + "\"");
		this._contentDiv.appendChild(this._windowHeader);
		
		
		this._searchBox.appendTo(this._contentDiv);
		
		this._contentDiv.appendChild(DOMUtil.createTextElement("div", [
			"Show: ",
			DOMUtil.createTextElement("label", "Staff"),
			this._typeCheckboxes[0],
			DOMUtil.createTextElement("label", "Stories"),
			this._typeCheckboxes[1],
			DOMUtil.createTextElement("label", "Assignments"),
			this._typeCheckboxes[2]
		], {className: "ShowTypes"}));
		
		// IE will not check boxes that are not part of the DOM tree so we need to do this here
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTAFF)) {
			this._typeCheckboxes[0].checked = true;
		}
		
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTORIES)) {
			this._typeCheckboxes[1].checked = true;
		}
		
		if(User.getPreference(deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWASSIGNMENTS)) {
			this._typeCheckboxes[2].checked = true;
		}
		
		var tableHolder = new behaviour.gui.panel.ScrollableHolder({attributes: {className: "recipientChooserTableHolder"}});
		tableHolder.appendChild(this._recipientTable);
		tableHolder.appendTo(this._contentDiv);
		
		this.setWindowTitle(this.options.messageComposer.getMessageTitle());
	},
	
	/**
	 * Updates window title to a given one
	 * @param {String} title
	 */
	updateWindowTitle: function(title) {
		DOMUtil.emptyNode(this._windowHeader);
		this._windowHeader.appendChild(document.createTextNode("Choose recipients for \"" + title.strip().truncate(20) + "\""));
		this.setWindowTitle(title);
	},
	
	/**
	 * @private
	 */
	_selectRecipient: function(recipient) {
		try {
			this._removeFromArray(this._recipientTable.options.args.currentRecipients, recipient);
			this._recipientTable.options.args.currentRecipients.push(recipient.id);
			
			if(this.options.messageComposer) {
				this.options.messageComposer.addRecipient(recipient);
			}
			
			this._recipientTable.reloadEntities();
		} catch(e) {
			Log.dumpException(e);
		}
		
		return false;
	},
	
	/**
	 * Adds recipient
	 * @param {Object} recipient
	 */
	putRecipientBack: function(recipient) {
		try {
			this._removeFromArray(this._recipientTable.options.args.currentRecipients, recipient);
			this._recipientTable.reloadEntities();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_removeFromArray: function(array, recipient) {
		for(var i = 0; i < array.length; i++) {
			if(array[i] == recipient.id) {
				array.splice(i, 1);
				i--;
			}
		}
	},
	
	_changeVisibleTypes: function(event) {
		this._recipientTable.options.args.showTypes = this._typeCheckboxes.pluck("checked");
		this._recipientTable.reloadEntities();
		
		var preferences = [
			deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTAFF, 
			deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWSTORIES,
			deadline.constants.DEADLINE_PREFERENCES_MESSAGECOMPOSER_SHOWASSIGNMENTS];
		
		this._typeCheckboxes.each(function(checkbox, index) {
			if(Event.element(event) == checkbox) {
				User.setPreference(preferences[index], checkbox.checked);
			}
		});
	}
});

/**
 * @class	deadline.gui.token.StoryToken
 * @extends	behaviour.gui.token.TextToken
 */
deadline.gui.token.StoryToken = new Class.create(behaviour.gui.token.TextToken, {
	/**
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("StoryToken");
	}
});

/**
 * @class deadline.gui.token.AssignmentToken
 * @extends behaviour.gui.token.TextToken 
 */
deadline.gui.token.AssignmentToken = new Class.create(behaviour.gui.token.TextToken, {
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("AssignmentToken");
	}
});

/**
 * @class deadline.messages.VideoMessageComposer
 * @extends behaviour.web.FlashEmbed
 */
deadline.messages.VideoMessageComposer = new Class.create(behaviour.web.FlashEmbed, {
	
	_streamName: null,
	
	initialize: function($super, options) {
		options = {
			swf: {
				path: "/swf/MessageRecorder.swf",
				id: "MessageRecorder",
				width: 400,
				height: 300
			},
			server: ServerConfig.video_message_server
		};
		
		$super(options);
	},
	
	// called by flash
	gotStreamName: function(streamName) {
		this._streamName = streamName;
	},
	
	getStreamName: function() {
		return this._streamName;
	},
	
	getRecorded: function() {
		return this.callFlashFunction("hasContent");
	}
});

/**
 * @class deadline.messages.MessageComposer
 * @extends behaviour.gui.GUIWidget
 */
deadline.messages.MessageComposer = Class.create(behaviour.gui.FloatingWindow, {
	
	_recipients: null,
	_recipientChooser: null,
	_recipientDisplay: null,
	_subjectBox: null,
	_messageArea: null,
	_textMessage: null,
	_videoMessage: null,
	_messageType: null,
	_compositionWindow: null,
	_messageRecorded: null,
	_typeRadioButtons: null,
	_intialContent: null,
	_sendingMessage: null,
	_messageSent: null,
	
	/**
	 * Constructor!
	 * Supports the following options: 
	 * options: {
	 * 		recipients: Array												// pre-filled recipients with the form {title: String, type: int, id: String}
	 * 		inReplyTo: deadline.messages.Message		// the message this is a reply to
	 * }
	 * 
	 * Supports the following callbacks:
	 * 
	 * onMessageSent
	 * onWindowClosed
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		options.width = 412;
		options.height= 540;
		options.shouldCloseWindow = this.shouldCloseWindow.bind(this);
		
		$super(options);
		
		this.addClass("MessageComposer");
		
		var initialSubject = "";
		
		if(typeof(this.options.inReplyTo) != "undefined") {
			initialSubject = Language.getFormatted("deadline.messages.MessageComposer.replysubject", {subject: this.options.inReplyTo.getSubject().replace(/Re:\s/, "")});
			
			if(this.options.inReplyTo.getType() == deadline.constants.DEADLINE_MESSAGE_TEXT) {
				this._intialContent = "\r\n" + this._formatReply(this.options.inReplyTo);
			}
		}
		
		this._recipientDisplay = DOMUtil.createElement("div", {className: "MessageComposer RecipientDisplay", onclick: this._openAddRecipientWindow.bindAsEventListener(this)});
		this._subjectBox = new behaviour.gui.updateables.UpdateableTextField({initialValue: initialSubject, required: true, onkeyup: this._updateMessageTitle.bind(this)});
		this._subjectBox.setEditMode(true);
		this._messageArea = DOMUtil.createElement("div");
		this._messageType = deadline.constants.DEADLINE_MESSAGE_TEXT;
		this._recipients = this.options.recipients instanceof Array ? this.options.recipients : [];
		
		EditWatcher.registerEditor(this, function() {
			if(this._messageType == deadline.constants.DEADLINE_MESSAGE_VIDEO) {
				return this._videoMessage.getRecorded();
			}
			
			return this._textMessage.getValue(true) ? true : false;
		}.bind(this), Language.get("deadline.messages.MessageComposer.unfinishedmessage"));
		
		currentPage.addModalLayer(this);
	},
	
	_formatReply: function(message) {
		var senderName = currentPage.getEntity(message.getSender(), "staff", "Staff").getProperty("fullname");
		
		var output = Language.getFormatted("deadline.messages.MessageComposer.replyquotetitle", {date: DateFormatter.getFormattedDate({date: message.getDate(), withStrings: true}), sender: senderName});
		var paragraphs = message.getContent().split(/\n[\n]*/);
		
		for(var i = 0; i < paragraphs.length; i++) {
			var paragraph = paragraphs[i].strip();
			
			if(paragraph == "") {
				continue;
			}
			
			output += this._formatReplyParagraph(paragraph);
			
			var quotedText = false;
			
			if(paragraph.substring(0, 2) == "> ") {
				quotedText = true;
			}
			
			if(!quotedText && i < paragraphs.length - 1) {
				output += "\n>";
			}
		}
		
		return output;
	},
	
	_formatReplyParagraph: function(text) {
		if(text.strip() == ">") {
			return "";
		}
		
		var lineLength = 60;
		var line = "";
		var output = "";
		var words = text.split(" ");
		
		for(var i = 0; i < words.length; i++) {
			if(line == "" && words[i] == ">") {
				continue;
			}
			
			if((line + " " + words[i]).length < lineLength) {
				line += words[i] + " ";
			} else {
				output += "\n> " + line.strip();
				line = words[i] + " ";
			}
		}
		
		output += "\n> " + line.strip();
		
		return output;
	},
	
	/**
	 * Renders
	 */
	render: function() {
		DOMUtil.emptyNode(this._contentDiv);
		
		if(this._sendingMessage) {
			var sendingNotification = new behaviour.gui.LoadingNotification({text: Language.get("deadline.messages.MessageComposer.sendingmessage")});
			sendingNotification.appendTo(this._contentDiv);
			
			return;
		}
		
		var messageButtons = new behaviour.gui.button.ButtonHolder({ignoreKeyPresses: true, attributes: {className: "messageComposerButtons"}});
		messageButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.messages.MessageComposer.sendmessage"), attributes: {id: "sendMessageButton"}, onclick: this._sendMessage.bind(this)}));
		
		var addRecipientButtons = new behaviour.gui.button.ButtonHolder({ignoreKeyPresses: true, attributes: {id: "addRecipientButtons"}});
		addRecipientButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.messages.MessageComposer.addrecipients"), attributes: {id: "addRecipientsButton"}, onclick: this._openAddRecipientWindow.bindAsEventListener(this)}));
		
		var headerPanel = new deadline.gui.panel.HeaderPanel();
		headerPanel.setHeaderRight(addRecipientButtons);
		headerPanel.setHeaderLeft(messageButtons);
		headerPanel.appendTo(this._contentDiv);
		
		this._contentDiv.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.messages.MessageComposer.recipients")));
		this._contentDiv.appendChild(this._recipientDisplay);
		this._contentDiv.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.messages.MessageComposer.subject")));
		this._subjectBox.appendTo(this._contentDiv);
		
		if(ServerConfig.rtmp_server != "none" && Broadcaster.callFlashFunction("hasCamera") && Broadcaster.isConnected()) {
			this._typeRadioButtons = [];
			this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_TEXT] = DOMUtil.createElement("input", {type: "radio", "name": "messageType", value: deadline.constants.DEADLINE_MESSAGE_TEXT, checked: (this._messageType == deadline.constants.DEADLINE_MESSAGE_TEXT), onclick: this._changeMessageType.bindAsEventListener(this)}); 
			this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_VIDEO] = DOMUtil.createElement("input", {type: "radio", "name": "messageType", value: deadline.constants.DEADLINE_MESSAGE_VIDEO, checked: (this._messageType == deadline.constants.DEADLINE_MESSAGE_VIDEO), onclick: this._changeMessageType.bindAsEventListener(this)}); 
			
			this._contentDiv.appendChild(DOMUtil.createTextElement("div", [
				DOMUtil.createTextElement("strong", Language.get("deadline.messages.MessageComposer.messagetype")), 
				this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_TEXT], 
				DOMUtil.createTextElement("label", Language.get("deadline.messages.MessageComposer.text"), {className: "MessageComposerTextMessageButton"}), 
				this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_VIDEO], 
				DOMUtil.createTextElement("label", Language.get("deadline.messages.MessageComposer.video"), {className: "MessageComposerVideoMessageButton"})
			], {className: "MessageTypeChooser"}));
		} else {
			this._contentDiv.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.messages.MessageComposer.message")));
		}
		
		this._contentDiv.appendChild(this._messageArea);
		
		this._renderRecipients();
		this._renderMessageDisplay();
		this._updateMessageTitle();
	},
	
	/**
	 * @private
	 */
	_renderRecipients: function() {
		DOMUtil.emptyNode(this._recipientDisplay);
		
		this._recipients.each(function(recipient) {
			var recipientToken = false;
			
			if(recipient.type == deadline.constants.DEADLINE_MESSAGE_RECIPIENT_STORY) {
				recipientToken = new deadline.gui.token.StoryToken({propertyDisplay: {entity: currentPage.getEntity(recipient.id, "stories", "Story"), property: "title"}, deleteCallback: this._removeRecipient.bind(this, recipient)});
			} else if(recipient.type == deadline.constants.DEADLINE_MESSAGE_RECIPIENT_ASSIGNMENT) {
				recipientToken = new deadline.gui.token.AssignmentToken({propertyDisplay: {entity: currentPage.getEntity(recipient.id, "assignments", "Assignment"), property: "title"}, deleteCallback: this._removeRecipient.bind(this, recipient)});
			} else if(recipient.type == deadline.constants.DEADLINE_MESSAGE_RECIPIENT_STAFF) {
				recipientToken = new deadline.gui.token.StaffToken({propertyDisplay: {entity: currentPage.getEntity(recipient.id, "staff", "Staff"), property: "fullname"}, deleteCallback: this._removeRecipient.bind(this, recipient)});
			}
			
			if(recipientToken) {
				recipientToken.setEditMode(true);
				recipientToken.appendTo(this._recipientDisplay);
			}
		}.bind(this));
	},
	
	/**
	 * @private
	 */
	_renderMessageDisplay: function() {
		if(this._videoMessage) {
			this._videoMessage.callFlashFunction("cleanUp");
		}
		
		DOMUtil.emptyNode(this._messageArea);
		
		if(this._messageType == deadline.constants.DEADLINE_MESSAGE_TEXT) {
			this._textMessage = new behaviour.gui.updateables.UpdateableTextArea({required: true, initialValue: this._intialContent});
			this._textMessage.setEditMode(true);
			this._textMessage.appendTo(this._messageArea);
					
			this._videoMessage = false;
		} else {
			this._videoMessage = new deadline.messages.VideoMessageComposer();
			this._videoMessage.appendTo(this._messageArea);
			this._textMessage = false;
		}
		
		this.resize();
		
		if(Browser.InternetExplorer && this._typeRadioButtons) {
			// IE will only set the checked state of buttons once they are in the DOM
			setTimeout(function() {
				if(this._messageType == deadline.constants.DEADLINE_MESSAGE_TEXT) {
					this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_TEXT].checked = true;
					this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_VIDEO].checked = false;
				} else {
					this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_TEXT].checked = false;
					this._typeRadioButtons[deadline.constants.DEADLINE_MESSAGE_VIDEO].checked = true;
				}
			}.bind(this), 100);
		}
	},
	
	/**
	 * @private
	 */
	_openAddRecipientWindow: function(event) {
		try {
			if(!this._recipientChooser) {
				
				this._recipientChooser = new deadline.messages.RecipientChooser({messageComposer: this});
				this._recipientChooser.registerListener("onWindowClosed", this._recipientChooserWindowClosed.bind(this));
				this._recipientChooser.appear();
			} else {
				setTimeout(function(){
					this._recipientChooser.bringToFront();
				}.bind(this), 100);
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_recipientChooserWindowClosed: function() {
		this._recipientChooser = false;
	},
	
	getRecipientIDs: function() {
		return this._recipients.pluck("id")
	},
	
	/**
	 * @private
	 */
	_updateMessageTitle: function() {
		setTimeout(function() {
			this.setWindowTitle(this.getMessageTitle());
			
			if(this._recipientChooser) {
				this._recipientChooser.updateWindowTitle(this.getMessageTitle());
			}
		}.bind(this), 50);
	},
	
	getMessageTitle: function() {
		var messageTitle = this._subjectBox.getValue(true).strip().truncate(50);
		return (messageTitle != "" ? messageTitle : Language.get("deadline.messages.MessageComposer.newmessage"));
	},
	
	/**
	 * @private
	 */
	_sendMessage: function() {
		try {
			DOMUtil.removeClass(this._recipientDisplay, "error");
			
			if(this._recipients.length == 0) {
				this.notifyListeners("onError");
				DOMUtil.addClass(this._recipientDisplay, "error");
				throw "need recipients";
			}
			
			if(this._messageType == deadline.constants.DEADLINE_MESSAGE_VIDEO) {
				if(this._videoMessage.getRecorded()) {
					this._messageRecorded = true;
				} else {
					this.notifyListeners("onError");
					throw "need video";
				}
			}
			
			new behaviour.ajax.JSONRequest({
				url: "/backend/messages/create", 
				args: {
					recipients: this._recipients,
					subject: this._subjectBox.getValue(),
					type: this._messageType,
					message: (this._messageType == deadline.constants.DEADLINE_MESSAGE_TEXT ? this._textMessage.getValue() : this._videoMessage.getStreamName())
				},
				onSuccess: this._sentMessage.bind(this)
			});
			
			this._sendingMessage = true;
			this.render();
			this.setWindowSize(300, 200, 0.5);
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_sentMessage: function(serverResponse, json) {
		this._messageSent = true;
		EditWatcher.deRegisterEditor(this);
		this.closeWindow();
		this.notifyListeners("onMessageSent");
		
		SoundBank.playMessageSent();
	},
	
	/**
	 * @private
	 */
	addRecipient: function(recipient) {
		for(var i = 0; i < this._recipients.length; i++) {
			if(this._recipients[i].id == recipient.id) {
				return;
			}
		}
		
		this._recipients.push(recipient);
		this._renderRecipients();
		DOMUtil.removeClass(this._recipientDisplay, "error");
	},
	
	/**
	 * @private
	 */
	_removeRecipient: function(recipient) {
		var recipientToRemove = false;
		
		for(var i = 0; i < this._recipients.length; i++) {
			if(this._recipients[i].id == recipient.id) {
				recipientToRemove = this._recipients[i];
				this._recipients.splice(i, 1);
				i--;
			}
		}
		
		this._renderRecipients();
		
		if(this._recipientChooser && recipientToRemove) {
			this._recipientChooser.putRecipientBack(recipientToRemove);
		}
		
		return false;
	},
	
	/**
	 * @private
	 */
	_changeMessageType: function(event) {
		var element = BehaviourUtil.clearFocus(event);
		
		var hasValue = false;
		
		if(this._messageType == deadline.constants.DEADLINE_MESSAGE_TEXT) {
			try {
				this._textMessage.getValue(true);
				hasValue = true;
			} catch(e) {
				
			}
		} else {
			hasValue = this._videoMessage.getRecorded();
		}
		
		if(!hasValue || (hasValue && !EditWatcher.changesOutstanding(this, Language.get("deadline.messages.MessageComposer.switchingmessagetypewarning")))) {
			this._cleanUpVideoMessage(true);
			this._messageType = element.value;
			this._renderMessageDisplay();
			this._messageRecorded = false;
		}
		
		this._typeRadioButtons[this._messageType].checked = true;
	},
	
	/**
	 * Checks if message composer should close its window
	 * @return {boolean}
	 */
	shouldCloseWindow: function() {
		if(this._messageSent || !EditWatcher.changesOutstanding(this)) {
			EditWatcher.deRegisterEditor(this);
			
			this._cleanUpVideoMessage(!this._messageRecorded);
			return true;
		}
		
		return false;
	},
	
	/**
	 * Notifies listeners when message window is closed
	 */
	windowClosed: function() {
		
	},
	
	_cleanUpVideoMessage: function(cancelled) {
		if(this._messageType == deadline.constants.DEADLINE_MESSAGE_VIDEO) {
			new behaviour.ajax.JSONRequest({
				url: "/backend/messages/cleanUpVideoMessage", 
				args: {
					messageFile: this._videoMessage.getStreamName(),
					messageAborted: cancelled
				}
			});
		}
	},
	
	disappear: function() {
		if(this._recipientChooser) {
			this._recipientChooser.closeWindow();
		}
		
		if(this._videoMessage) {
			this._videoMessage.callFlashFunction("cleanUp");
			DOMUtil.emptyNode(this._messageArea);
		}
		
		Effect.Fade(this.rootNode, { duration: 0.25 });
		this.notifyListeners("onDisppear");
	}
});

/**
 * @class deadline.gui.staff.Avatar
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.staff.Avatar = new Class.create(behaviour.gui.GUIWidget, {
	
	_online: null,
	_commsDiv: null,
	_id: null,
	_viewbutton: null,
	_messageButton: null,
	_textChatButton: null,
	_videoChatButton: null,
	
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff,
	 * 		simple: boolean						// if true will not display messaging/online icons
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("Avatar");
		
		this._id = BehaviourUtil.generateGUID();
		
		if(!this.options.simple) {
			this.getRootNode().onmouseover = function(event) {
				DOMUtil.setStyle(this._commsDiv, "display", "block");
			}.bindAsEventListener(this);
			
			this.getRootNode().onmouseout = function(event) {
				DOMUtil.setStyle(this._commsDiv, "display", "none");
			}.bindAsEventListener(this);
			
			this._messageButton = new deadline.gui.button.AvatarNewMessageButton({onclick: function() {
				try {
					var composer = new deadline.messages.MessageComposer({recipients: [{type: deadline.constants.DEADLINE_MESSAGE_RECIPIENT_STAFF, id: options.staff.getId()}]});
					composer.appear();
				} catch(e) {
					Log.dumpException(e);
				}
			}});
			
			this._viewbutton = new behaviour.gui.button.ViewButton({onclick: function() {
				document.location = "/staff/#showStaff/" + options.staff.getID();
			}});
			
			this._textChatButton = new deadline.gui.button.TextChatIcon({onclick: function() {
				var chat = new deadline.gui.chat.TextChat({participants: [options.staff]});
				chat.appear();
			}});
			
			this._videoChatButton = new deadline.gui.button.VideoChatIcon({onclick: function() {
				var chat = new deadline.gui.chat.VideoChat({participants: [options.staff]});
				chat.appear();
			}});
			
			this._commsDiv = DOMUtil.createElement("div", {className: "AvatarCommunicationsArea", style: {display: "none"}});
				
			var func = function() {
				this._online = this.options.staff.getOnline();
				this.render();
			}.bind(this);
			
			func._id = this._id;
			
			this.options.staff.registerListener("onlineStatusChanged", func);
		}
		
		this.options.staff.registerOneTimeListener("onDataLoaded", function() {
			this.setAttribute("title", this.options.staff.getFullname());
		}.bind(this));
		
		if(!this.options.simple) {
			Broadcaster.registerListener("onConnectSuccess", this.render.bind(this));
			Broadcaster.registerListener("onConnectionClosed", this.render.bind(this));
		}
	},
	
	render: function() {
		this.empty();
		
		this.options.staff.registerOneTimeListener("onDataLoaded", function() {
			if(this.options.staff.getAvatar()) {
				this.setStyle("backgroundImage", "url(/backend/staff/getAvatar?id=" + this.options.staff.getID() + ")");
			}
		}.bind(this));
		
		if(!this.options.simple) {
			var onlineStatus = "";
			
			DOMUtil.emptyNode(this._commsDiv);
			
			if(Broadcaster.callFlashFunction("getServerStatus") == deadline.constants.DEADLINE_BROADCASTERSTATUS_CONNECTED) {
				if(this._online) {
					onlineStatus = " AvatarOnlineStatus_Online";
					
					if(!User.equals(this.options.staff)) {
						onlineStatus += " AvatarOnlineStatus_OnlineWithChatButtons";
						this._videoChatButton.appendTo(this._commsDiv);
						this._textChatButton.appendTo(this._commsDiv);
					}
				} else {
					onlineStatus = " AvatarOnlineStatus_Offline";
				}
				
				this._messageButton.appendTo(this._commsDiv);
				this._viewbutton.appendTo(this._commsDiv);
			}
			
			this.appendChild(DOMUtil.createTextElement("div", this._commsDiv, {className: "AvatarOnlineStatus " + onlineStatus}));
		}
	},
	
	setOnline: function(online) {
		if(!this.options.simple) {
			this._online = online;
			this.render();
		}
	}
});

/**
 * @class deadline.entities.Staff
 * @extends deadline.entities.CreatedEntity 
 */
deadline.entities.Staff = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/staff/create",
	_retrieveURL: "/backend/staff/get",
	_updateURL: "/backend/staff/update",
	_deleteURL: "/backend/staff/delete",
	_online: null,
	_onlineCallPending: null,
	
	/**
	 * Constructor
	 * @param	{Object} options An options object
	 * @example
	 * Todo an example
	 * 
	 * Supports the following events: 
	 * 
	 * onlineStatusChanged
	 */
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates appropriate getters and setters on data passed.
	 * @param {Object} data A tuple from the database
	 */
	processData: function($super, data) {
		$super(data);
		
		if(BehaviourUtil.isGUID(this._data.role)) {
			this._data.role = currentPage.getEntity(this._data.role, "roles", "Role");
		}
	},
	
	/**
	 * @private 
	 * Returns empty default object
	 */
	_getDefaultObject: function() {
		return {
			id: false,
			username: "",
			password: "",
			title: "",
			fullname: "",
			firstname: "",
			lastname: "",
			contactnumbers: [],
			postaladdresses: [],
			emailaddresses: [],
			picture: false,
			avatar: false,
			canedit: true,
			notes: "",
			shareprivatedata: false,
			role: null,
			numAssignments: 0,
			permissions: {},
			archived: false
		};
	},
	
	/**
	 * @return {Node} div containing an avatar image
	 */
	getAvatarImage: function(simple) {
		var avatar = new deadline.gui.staff.Avatar({staff: this, simple: simple});
		
		if(!simple) {
			if(this._online == null) {
				if(!Broadcaster.loaded()) {
					Broadcaster.registerListener("onLoad", this._checkOnlineStatus.bind(this));
				} else {
					this._checkOnlineStatus();
				}
			} else {
				avatar.setOnline(this.getOnline(), true);
			}
		}
		
		return avatar;
	},
	
	_checkOnlineStatus: function() {
		if(User.equals(this)) {
			this.setOnline(true);
		} else {
			if(!this._onlineCallPending) {
				this._onlineCallPending = true;
				Broadcaster.callFlashFunction("isOnline", {staffID: this.getID(), callbackID: FlashBridge.registerFunction(this.setOnline.bind(this))});
			}
		}
	},
	
	getOnline: function() {
		return this._online ? true : false;
	},
	
	setOnline: function(online) {
		this._online = online;
		this.notifyListeners("onlineStatusChanged");
	},
	
	/**
	 * @return {String}
	 */
	getFriendlyName: function() {
		if(this.getId() == User.getId()) {
			return Language.get("deadline.entities.Staff.me");
		}
		
		return this.getProperty("fullname");
	},
	
	_getPermissionsFor: function(entity) {
		var entityKey =  BehaviourUtil.getKey(entity);
		
		if(!(this.getPermissions()[entityKey] instanceof Array)) {
			this.getPermissions()[entityKey] = [];
		}
		
		return this.getPermissions()[entityKey];
	},
	
	hasPermission: function(key, entity) {
		for(var i = 0; i < this._getPermissionsFor(entity).length; i++) {
			if(this._getPermissionsFor(entity)[i] == key) {
				return true;
			}
		}
		
		return false;
	},
	
	updatePermission: function(key, entity, set) {
		if(set) {
			if(!this.hasPermission(key, entity)) {
				this._getPermissionsFor(entity).push(key);
			}
		} else {
			for(var i = 0; i < this._getPermissionsFor(entity).length; i++) {
				if(this._getPermissionsFor(entity)[i] == key) {
					this._getPermissionsFor(entity).splice(i, 1);
					i--;
				}
			}
		}
	}
});

/**
 * @class deadline.gui.button.SaveCancel
 * @extends behaviour.gui.button.ButtonHolder
 * 
 */
deadline.gui.button.SaveCancel = Class.create(behaviour.gui.button.ButtonHolder, {
	_editMode: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		changedCallback: Function		// should return true if the object has been edited
	 * 		editCallback: Function
	 * 		saveCallback: Function
	 * 		cancelCallback: Function,
	 * 		editText: String,
	 * 		saveText: String,
	 * 		cancelText: String,
	 * 		nativeButtons: true
	  * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("SaveCancel");
		
		this.options.editText = this.options.editText ? this.options.editText : Language.get("deadline.gui.button.SaveCancel.edit");
		this.options.saveText = this.options.saveText ? this.options.saveText : Language.get("deadline.gui.button.SaveCancel.save");
		this.options.cancelText = this.options.cancelText ? this.options.cancelText : Language.get("deadline.gui.button.SaveCancel.cancel");
		
		this.setEditMode(false);
	},
	
	/**
	 * Sets edit mode
	 * @param {boolean} mode
	 */
	setEditMode: function(mode) {
		this._editMode = mode;
		this.childWidgets = [];
		
		if(mode) {
			this.addButton(new behaviour.gui.button[(this.options.nativeButtons ? "Native" : "GUI") + "Button"]({buttonText: this.options.saveText, onclick: this.saveEdit.bind(this), attributes: {className: "saveButton"}}));
			this.addButton(new behaviour.gui.button[(this.options.nativeButtons ? "Native" : "GUI") + "Button"]({buttonText: this.options.cancelText, onclick: this.cancelEdit.bind(this), attributes: {className: "cancelButton"}}));
			
			if(this.options.changedCallback) {
				EditWatcher.registerEditor(this, this.options.changedCallback, this.options.changeWarning ? this.options.changeWarning : false);
			}
		} else {
			this.addButton(new behaviour.gui.button[(this.options.nativeButtons ? "Native" : "GUI") + "Button"]({buttonText: this.options.editText, onclick: this.startEdit.bind(this), attributes: {className: "editButton"}}));
			
			if(this.options.changedCallback) {
				EditWatcher.deRegisterAllEditors();
			}
		}
		
		this.render();
	},
	
	/**
	 * @return {boolean} 
	 */
	getEditMode: function() {
		return this._editMode;
	},
	
	/**
	 * Starts edit process
	 */
	startEdit: function() {
		try {
			if(this.options.changedCallback && EditWatcher.changesOutstanding(this)) {
				return;
			}
			
			this.setEditMode(true);
			this._callCallback("editCallback");
			this.notifyListeners("startedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Saves edit fields
	 */
	saveEdit: function() {
		try {
			this.setEditMode(false);
			
			this._callCallback("saveCallback");
			this.notifyListeners("savedEdit");
			this.notifyListeners("stoppedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Cancels edit process
	 */
	cancelEdit: function() {
		try {
			this.setEditMode(false);
			this._callCallback("cancelCallback");
			this.notifyListeners("cancelledEdit");
			this.notifyListeners("stoppedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 * @param {Function} callbackName
	 */
	_callCallback: function(callbackName) {
		if(this.options[callbackName] instanceof Function) {
			this.options[callbackName]();
		}
	},
	
	/**
	 * Render
	 */
	render: function() {
		this.empty();
		
		this.childWidgets.each(function(button) {
			button.appendTo(this);
		}.bind(this));
	}
});

/**
 * @class deadline.gui.panel.HelpPanel
 * @extends behaviour.gui.panel.Panel
 */
deadline.gui.panel.HelpPanel = new Class.create(behaviour.gui.panel.Panel, {
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.options.fixedHeight = true;
		this.addClass("HelpPanel");
		
		if(this.options.helpText) {
			this.appendChild(DOMUtil.createTextElement("p", this.options.helpText, {className: "notice"}));
		}
	}
});

/**
 * @class deadline.gui.selectors.EntitySelector
 */
deadline.gui.selectors.EntitySelector = new Class.create(behaviour.gui.panel.Panel, {
	
	_searchBox: null,
	_entityTable: null,
	_tableHolder: null,
	_headerRows: null,
	_columnData: null,
	_loadingText: null,
	_emptyListText: null,
	_createEntity: null,
	_headerHolder: null,
	_entityListHolder: null,
	_startSorted: null,
	_headerText: null,
	
	/**
	 * Constructor
	 *
	 * Supports the following options:
	 * 
	 * options: {
	 * 		url: String																// where to load the people from
	 * 		args: Object															// key/value pairs to pass along with the request
	 * 		nameField: String													// defaults to "fullname"
	 * 		headerText: String												// displayed at the top of the box
	 * 		panel: behaviour.gui.panel.DualPanel				// the panel that this object should append itself to
	 * }
	 * 
	 * Supports the following notifications:
	 * 
	 * onSelectedEntity
	 * 
	 * @param {Object} options
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("EntitySelector");
		
		this.options.nameField = this.options.nameField ? this.options.nameField : "fullname";
		this.options.args = this.options.args ? this.options.args : {};
		
		this._searchBox = new deadline.gui.SearchBox();
		
		this._startSorted = {
			column: 1,
			direction: "DESC"
		}
	},
	
	/**
	 * Render
	 */
	render: function() {
		this.empty();
		
		this.addPanel({panel: new deadline.gui.panel.HeaderPanel({headerLeft: this._headerText, headerRight: this.options.headerRight}), withName: "actualHeaderPanel"});
		this.addPanel({panel: this._getHeader(), withName: "headerPanel"});
		this.addPanel({panel: this._getList(), withName: "listPanel"});
	},
	
	/**
	 * @private
	 * @return	{Node}
	 */
	_renderHeader: function() {
		return null;
	},
	
	/**
	 * @private
	 * @return {Node}
	 */
	_getHeader: function() {
		var headerPanel = new behaviour.gui.panel.Panel({fixedHeight: true, attributes: {className: "EntitySelector_HeaderPanel"}});
		
		if(this.options.notice) {
			headerPanel.appendChild(new deadline.gui.panel.HelpPanel({helpText: this.options.notice}));
			headerPanel.addClass("EntitySelector_HeaderPanelWithHelp");
		}
		
		var headerContents = this._renderHeader();
		
		if(headerContents) {
			headerPanel.appendChild(headerContents);
		} else {
			headerPanel.addClass("EntitySelector_HeaderPanelNoContents");
		}
			
		headerPanel.appendChild(this._searchBox);
			
		return headerPanel;
	},
	
	/**
	 * @private
	 */
	_getList: function() {
		this._entityTable = this._getEntityTable();
		this._searchBox.setOutputField(this._entityTable);
		
		this._entityListHolder = new behaviour.gui.panel.ScrollableHolder();
		this._entityListHolder.appendChild(this._entityTable);
		
		return this._entityListHolder;
	},
	
	/**
	 * @private
	 */
	_getEntityTable: function() {
		var table = new behaviour.gui.table.ScrollLoadTable({
			noEntitiesText: this._emptyListText,
			rowHeight: 23,
			createEntity: this._createEntity,
			url: this.options.url,
			args: this.options.args,
			startSorted: this._startSorted,
			headerRows: this._headerRows,
			columnData: this._columnData
		});
		
		return table;
	},
	
	/**
	 * @private
	 */
	_addedEntity: function(entity) {
		this.notifyListeners("onSelectedEntity", entity);
	},
	
	/**
	 * @private
	 */
	_selectedEntity: function() {
		return true;
	},
	
	/**
	 * @private
	 */
	_loadAllEntities: function(event) {
		this._loadEntities(event, true);
	},
	
	/**
	 * @private
	 */
	_loadMyEntities: function(event) {
		this._loadEntities(event, false);
	},
	
	/**
	 * @private
	 */
	_loadEntities: function(event, all) {
		BehaviourUtil.clearFocus(event);
		this.options.args.all = all;
		this._entityTable.reloadEntities();
	},
	
	/**
	 * Loads entities again
	 */
	loadEntities: function() {
		this._entityTable.reloadEntities();
	}
});

/**
 * @class deadline.gui.selectors.AssignmentSelector
 * @extends deadline.gui.selectors.EntitySelector
 */
deadline.gui.selectors.AssignmentSelector = new Class.create(deadline.gui.selectors.EntitySelector, {
	
	storyID: null,
	args: null,
	url: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this._headerText = Language.get("deadline.gui.selectors.AssignmentSelector.header");
		this._loadingText = Language.get("deadline.gui.selectors.AssignmentSelector.loading");
		this._emptyListText = Language.get("deadline.gui.selectors.AssignmentSelector.emptylist");
		
		this._headerRows = [
			Language.get("deadline.shared.add"),
			Language.get("deadline.shared.story"),
			Language.get("deadline.shared.title")
		];
		
		this._columnData = [{
				text: function(assignment) {
					return new behaviour.gui.button.AddButton({onclick: this._addedEntity.bind(this, assignment)});
				}.bind(this), 
				iconColumn: true, 
				ignoreDownState: true
			},{
				text: function(assignment) {
					return assignment.getPropertyDisplay({property: "story.title"});
				}.bind(this),
				onclick: this._selectedEntity.bind(this),
				sortField: true,
				ignoreDownState: true
			},{
				text: function(assignment) {
					return assignment.getPropertyDisplay({property: "title"});
				}.bind(this),
				onclick: this._selectedEntity.bind(this),
				sortField: true,
				ignoreDownState: true
			}];
		
		this._createEntity = function(data, index) {
			if(typeof(data) != "undefined") {
				return currentPage.getEntity(data, "assignments", "Assignment");
			}
			
			return false;
		}.bind(this);
	}
});

/**
 * @class deadline.entities.Package
 * @extends deadline.entities.CreatedEntity
 */
deadline.entities.Package = new Class.create(deadline.entities.CreatedEntity, {
	_createURL: "/backend/packages/create",
	_retrieveURL: "/backend/packages/get",
	_updateURL: "/backend/packages/update",
	_deleteURL: "/backend/packages/delete",
	
	initialize: function($super, options) {
		$super(options);
	},
	
	/**
	 * Creates a default Intefview object.
	 * @private
	 * @return {Object} 
	 */
	_getDefaultObject: function() {
		return {
			id: false,
			lastmodifiedby: null,
			lastmodifieddate: 0,
			createdBy: User.getId(),
			canedit: true,
			title: Language.get("deadline.entities.Package.defaulttitle"),
			description: null,
			numAssets: 0,
			status: deadline.constants.DEADLINE_PACKAGESTATUS_OPEN,
			invitationSent: false,
			archived: false,
			password: "",
			recipients: []
		};
	},
	
	deleteEntity: function(mode) {
		new behaviour.ajax.JSONRequest({
			url: this._deleteURL, 
			args: {"id": this.id}, 
			onSuccess: function() {
				currentPage.showPackages();
			},
			method: "post"
		});
	}
});

/**
 * @class deadline.gui.selectors.PackageSelector
 * @extends deadline.gui.selectors.EntitySelector
 */
deadline.gui.selectors.PackageSelector = new Class.create(deadline.gui.selectors.EntitySelector, {
	storyID: null,
	args: null,
	url: null,
	
	/**
	 * Constructor
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this._headerText = Language.get("deadline.gui.selectors.PackageSelector.header");
		this._loadingText = Language.get("deadline.gui.selectors.PackageSelector.loading");
		this._emptyListText = Language.get("deadline.gui.selectors.PackageSelector.emptylist");
		
		this._headerRows = [
			Language.get("deadline.shared.add"),
			Language.get("deadline.shared.title"),
			Language.get("deadline.shared.status")
		];
		
		this._columnData = [{
				text: function(thePackage) {
					return new behaviour.gui.button.AddButton({onclick: this._addedEntity.bind(this, thePackage)});
				}.bind(this), 
				iconColumn: true, 
				ignoreDownState: true
			},{
				text: function(thePackage) {
					return thePackage.getPropertyDisplay({property: "title"});
				}.bind(this),
				onclick: this._selectedEntity.bindAsEventListener(this),
				sortField: true,
				ignoreDownState: true
			},{
				text: function(thePackage) {
					return thePackage.getPropertyDisplay({property: "status", formatter: function(status){return Language.get("deadline.shared.packagestatus" + status);}});
				}.bind(this),
				onclick: this._selectedEntity.bindAsEventListener(this),
				sortField: true,
				ignoreDownState: true
			}];
		
		this._createEntity = function(data, index) {
			if(typeof(data) != "undefined") {
				return currentPage.getEntity(data, "packages", "Package");
			}
			
			return false;
		}.bind(this);
	}
});

/**
 * @class deadline.gui.button.StatusIcon 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.StatusIcon = Class.create(behaviour.gui.button.IconButton, {
	_statusText: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("StatusIcon");
		this.addClass("StatusIcon_Status" + this.options.status);
		
		if(this._statusText instanceof Array && this._statusText[this.options.status]) {
			this.appendChild(this._statusText[this.options.status]);
			this.setAttribute("title", this._statusText[this.options.status]);
		}
	}
});

/**
 * @class deadline.gui.button.AssignmentStatusIcon
 * @extends deadline.gui.button.StatusIcon
 */
deadline.gui.button.AssignmentStatusIcon = Class.create(deadline.gui.button.StatusIcon, {
	initialize: function($super, options) {
		this._statusText = Language.getArray("deadline.gui.button.AssignmentStatusIcon.assignmentstatus");
		$super(options);
		this.addClass("AssignmentStatusIcon");
	}
});

/**
 * @class deadline.gui.panel.EditPanel
 * @extends behaviour.gui.panel.DualPanel
 */
deadline.gui.panel.EditPanel = new Class.create(behaviour.gui.panel.DualPanel, {
	
	_saveCancel: null,
	_fieldHolders: null,
	_data: null,
	_editMode: null,
	
	
	/**
	 * Supports the following options
	 * 
	 * options: {
	 * 		entity: Object
	 * 		confirmDeleteText: String
	 * }
	 * 
	 * Supports the following events
	 * 
	 * onDelete
	 * onStartedEdit
	 * onStoppedEdit
	 * onSavedEdit
	 * onCancelledEdit
	  */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("EditPanel");
		this._getSaveCancel();
		this._fieldHolders = [];
		this._data = new Hash();
		this._editMode = false;
		
		if(this.options.entity.dataLoaded()) {
			this._createFields();
		} else {
			this.options.entity.registerOneTimeListener("onDataLoaded", function() {
				this._createFields();
			}.bind(this));
		}
	},
	
	/**
	 * @param {String} key
	 * @param {Object} value
	 */
	addField: function(key, value) {
		this._data.set(key, value);
	},
	
	/**
	 * Renders
	 */
	render: function() {
		behaviour.gui.panel.DualPanel.prototype.render.call(this);
		
		if(this.options.entity.isNew()) {
			this._saveCancel.setEditMode(true);
			this._startEdit();
		}
	},
	
	/**
	 * Should involve one or more calls to deadline.gui.panel.detail.EntityDetailPanel#_addFieldHolder(holder)
	 */
	_createFields: function() {
		
	},
	
	/**
	 * @private
	 */
	_addFieldHolder: function(holder) {
		if(Object.isArray(holder)) {
			holder.each(function(holder) {
				this._addFieldHolder(holder);
			}.bind(this));
		} else {
			this._fieldHolders.push(holder);
		}
	},
	
	/**
	 * @private
	 */
	_getSaveCancel: function() {
		if(this.options.entity.canEdit()) {
			
			if(this._saveCancel == null) {
				this._saveCancel = new deadline.gui.button.SaveCancel({
					editCallback: this._startEdit.bind(this),
					saveCallback: this._saveEdit.bind(this),
					cancelCallback: this._cancelEdit.bind(this), 
					nativeButtons: true, 
					ignoreKeyPresses: true,
					changeWarning: this.options.changeWarning,
					changedCallback: this._fieldsChanged.bind(this)
				});
			}
			
			return this._saveCancel;
		}
	},
	
	/**
	 * @private
	 */
	_fieldsChanged: function() {
		var changed = false;
		
		this._fieldHolders.each(function(holder) {
			if(holder.changed()) {
				changed = true;
			}
		});
			
		return changed;
	},
	
	/**
	 * @private
	 */
	_startEdit: function() {
		this._editMode = true;
		this._fieldHolders.invoke("setEditMode", true);
		this.notifyListeners("onStartedEdit");
	},
	
	/**
	 * @private
	 */
	_saveEdit: function() {
		try {
			var data = new Hash();
			data.set("id", this.options.entity.getId());
			
			this._fieldHolders.each(function(holder) {
				data = data.merge(holder.getValues());
			});
			
			data = data.merge(this._data);
			
			// if we have not changed, don't send data to the server
			if(!this._fieldsChanged() && !this.options.entity.isNew()) {
				this._noChangeAfterEdit();
				return;
			}
			
			this.options.entity.registerOneTimeListener(this.options.entity.isNew() ? "onCreate" : "onUpdate", this._savedEdit.bind(this));
			this._fieldHolders.invoke("setDisabled", true);
			this.options.entity.saveData(data);
		} catch(e) {
			if(e instanceof behaviour.gui.updateables.InputException) {
				NotificationArea.setError("Error", e.message);
				this._saveCancel.setEditMode(true);
			} else {
				Log.dumpException(e);
				throw e;
			}
		}
	},
	
	/**
	 * @private
	 */
	_noChangeAfterEdit: function() {
		try {
			this._editMode = false;
			
			this._fieldHolders.each(function(holder) {
				holder.saveEdit();
				holder.setDisabled(false);
				holder.setEditMode(false);
			});
			
			NotificationArea.setMessage(Language.get("deadline.gui.panel.EditPanel.cancel.header"), Language.get("deadline.gui.panel.EditPanel.cancel.message"), "info");
			this.notifyListeners("onNoChangeAfterEdit");
			this.notifyListeners("onStoppedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_savedEdit: function() {
		try {
			this._editMode = false;
			
			this._fieldHolders.each(function(holder) {
				holder.saveEdit();
				holder.setDisabled(false);
				holder.setEditMode(false);
			});
			
			NotificationArea.setMessage(Language.get("deadline.gui.panel.EditPanel.save.header"), Language.get("deadline.gui.panel.EditPanel.save.message"), "info");
			this.notifyListeners("onSavedEdit");
			this.notifyListeners("onStoppedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_cancelEdit: function() {
		try {
			this._editMode = false;
			
			this._fieldHolders.each(function(holder) {
				holder.cancelEdit();
				holder.setEditMode(false);
			});
			
			NotificationArea.setMessage(Language.get("deadline.gui.panel.EditPanel.noedit.header"), Language.get("deadline.gui.panel.EditPanel.noedit.message"), "info");
			this.notifyListeners("onCancelledEdit");
			this.notifyListeners("onStoppedEdit");
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	getEditMode: function() {
		return this._editMode;
	}
});

/**
 * @class deadline.gui.button.HelpButton 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.HelpButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("HelpButton");
	}
});

/**
 * @class deadline.gui.panel.detail.EntityDetailPanel
 * @extends deadline.gui.panel.EditPanel
 */
deadline.gui.panel.detail.EntityDetailPanel  = new Class.create(deadline.gui.panel.EditPanel, {
	
	_detailPanel: null,
	
	/**
	 * Supports the following options:
	 * 
	 * options: {
	 * 		entity: Object				// The object that this panel represents
	 * 		omitHeader: true		// if true, header will be omitted
	 * }
	 * 
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.direction = "vertical"; 
		options.panel1 = new deadline.gui.panel.HeaderPanel();
		options.panel2 = new behaviour.gui.panel.ScrollableHolder();
		
		// call parent method
		$super(options);
		
		this.addClass("EntityDetailPanel");
		this._createPanels();
	},
	
	_createPanels: function() {
		if(this.options.entity.dataLoaded()) {
			this._createBody();
			this._createHeader();
		} else {
			// entity data is not loaded, waiting a bit
			this.options.entity.registerOneTimeListener("onDataLoaded", this._createPanels.bind(this));
			this.options.entity.loadData();
		}
	},
	
	/**
	 * @private
	 */
	_createFields: function() {
		this._addFieldHolder(this.getEditTable());
	},
	
	/**
	 * @private
	 */
	_createHeader: function() {
		this.getPanel1().setHeaderLeft(this.options.headerText);
		
		var rightHeader = [];
		
		var helpButton = new deadline.gui.button.HelpButton({onclick: function() {
			this.options.detailArea.showHelp();
		}.bind(this)});
		
		if(this.options.entity.canEdit()) {
			var saveCancel = this._getSaveCancel();
			
			if(saveCancel) {
				saveCancel.registerListener("startedEdit", function() {
					helpButton.setStyle("display", "none");
				});
				saveCancel.registerListener("stoppedEdit", function() {
					helpButton.setStyle("display", "block");
				});
				
				rightHeader.push(saveCancel);
			}
		}
		
		if(this.options.entity.isNew()) {
			helpButton.setStyle("display", "none");
		}
		
		rightHeader.push(helpButton);
		
		this.getPanel1().setHeaderRight(rightHeader);
		this.getPanel1().render();
	},
	
	/**
	 * @private
	 */
	_createBody: function() {
		this._fieldHolders.each(function(fieldHolder) {
			this.getPanel2().appendChild(fieldHolder);
		}.bind(this));
	},
	
	/**
	 * Overridden by child classes
	 */
	getEditTable: function() {
		Log.info('getEditTable() has not been overwriten');
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableFieldGroup
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.updateables.UpdateableFieldGroup = new Class.create(behaviour.gui.GUIWidget, {
	_fields: null,
	_fieldOptions: null,
	_editMode: null,
	_preSubmitFilters: null,
	
	/**
	 * Constructor
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		namespace: String		//  If passed all field values will be prefixed by namespace:  - eg. pass "person" for "person:name", etc.  Allow us to sanely submit two entities data in one go
	 * }
	 * 
	 * @param {Object} options
	  */
	initialize: function($super, options) {
		$super(options);
		
		this._fields = [];
		this._fieldOptions = [];
		this._preSubmitFilters = [];
	},
	
	/**
	 * 	Supports the following options:
	 * 
	 * options: {
	 * 		name: String				// The name of the variable this field represents
	 * 		label: String				// The text to be displayed next to the field
	 * 		ignoreValue: boolean	//  If true the field will not be queried for a value when getValues is called
	 * 		nonEditable: boolean	//  If true the field will not be put into edit mode
	 * 	}
	 * 
	 * @param {behaviour.gui.updateables.UpdateableField} field
	 * @param {Object} options
	 */
	addField: function(field, options) {
		this._fields.push(field);
		this._fieldOptions.push(options);
		
		return field;
	},
	
	removeField: function(fieldName) {
		for(var i = 0; i < this._fieldOptions.length; i++) {
			if(this._fieldOptions[i].name == fieldName) {
				var needRender = false;
				
				// only need update if we are removing a visible field
				if(!(this._fields[i] instanceof behaviour.gui.updateables.UpdateableInvisibleField)) {
					needRender = true;
				}
				
				// remove the field and it's options
				this._fields.splice(i, 1);
				this._fieldOptions.splice(i, 1);
				
				// update if needed
				if(needRender && this.getRootNode() && this.getRootNode().parentNode) {
					this.render();
				}
			}
		}
	},
	
	addPreSubmitFilter: function(filter) {
		this._preSubmitFilters.push(filter);
	},
	
	/**
	 * @param {boolean} editMode
	 */
	setEditMode: function(editMode) {
		this._editMode = editMode;
		
		this.render();
		
		for(var i = 0, iCount = this._fields.length; i < iCount; i++) {
			if(this._fields[i] && !this._fieldOptions[i].nonEditable) {
				this._fields[i].setEditMode(editMode);
			}
		}
		
		if(editMode) {
			this.addClass("UpdateableFieldGroup_EditMode");
		} else {
			this.removeClass("UpdateableFieldGroup_EditMode");
		}
	},
	
	/**
	 * @return {boolean}
	 */
	getEditMode: function() {
		return this._editMode;
	},
	
	/**
	 * @param {boolean} disabled
	 */
	setDisabled: function(disabled) {
		for(var i = 0, iCount = this._fields.length; i < iCount; i++) {
			if(this._fields[i] && !this._fieldOptions[i].nonEditable) {
				this._fields[i].setDisabled(disabled);
			}
		}
	},
	
	/**
	 * saves edited fields
	 */
	saveEdit: function() {
		for(var i = 0, iCount = this._fields.length; i < iCount; i++) {
			if(this._fields[i] && !this._fieldOptions[i].nonEditable) {
				this._fields[i].saveEdit();
			}
		}
	},
	
	/**
	 * cancel edit process and revert to previous state
	 */
	cancelEdit: function() {
		for(var i = 0, iCount = this._fields.length; i < iCount; i++) {
			if(this._fields[i] && !this._fieldOptions[i].nonEditable) {
				this._fields[i].cancelEdit();
			}
		}
	},
	
	/**
	 * @return {Object} output
	 */
	getValues: function() {
		var output = {};
		
		for(var i = 0; i < this._fields.length; i++) {
			if(this._fields[i] && !this._fieldOptions[i].ignoreValue) {
				this._fields[i].clearError();
				
				output[(this.options.namespace ? this.options.namespace + ":" : "") + this._fieldOptions[i]["name"]] = this._fields[i].getValue();
			}
		}
		
		this._preSubmitFilters.each(function(filter) {
			var errorField = filter(output);
			
			if(errorField) {
				for(var i = 0; i < this._fields.length; i++) {
					if((this.options.namespace ? this.options.namespace + ":" : "") + this._fieldOptions[i]["name"] == errorField) {
						this._fields[i].triggerError();
					}
				}
			}
		}.bind(this));
		
		return output;
	},
	
	/**
	 * @return {string} output
	 */
	getValuesAsString: function() {
		var output = "";
		var values = this.getValues();
		
		for(var key in values) {
			output += this.parseValues(key, values[key]);
		}
		
		return output;
	},
	
	/**
	 * @param {string} key
	 * @param {mixed} value
	 * @return {string} output
	 */
	parseValues: function(key, value) {
		if(value instanceof Array) {
			for(var i = 0, iCount=value.length; i < iCount; i++) {
				output += this.parseValues(key + "[]", value[i]) + "&";
			}
		} else if(key) {
			output = key + "=" + encodeURIComponent(value) + "&";
		}
		
		return output;
	},
	
	/**
	 * @param {string} key
	 * @return Returns fields values
	 * @type {mixed}
	 */
	getValue: function(key) {
		for(var i = 0, iCount=this._fieldOptions.length; i < iCount; i++) {
			if(this._fieldOptions[i].name == key && !this._fieldOptions[i].ignoreValue) {
				return this._fields[i].getValue();
			}
		}
	},
	
	/**
	 * @return fields
	 * @type {mixed}
	 */
	getFields: function() {
		return this._fields
	},
	
	changed: function() {
		var changed = false;
		
		this._fields.each(function(field, index) {
			
			if(this._fieldOptions[index] && this._fieldOptions[index].ignoreValue) {
				return;
			}
			
			if(field && field.changed) {
				if(field.changed()) {
					changed = true;
				}
			}
		}.bind(this));
		
		return changed;
	},
	
	/**
	 * b0rk b0rk b0rk.  Because of no support for DOMNodeRemoved events in IEx, we must manually tell our child updateables to clean up after themselves.
	 */
	deregisterChildListeners: function() {
		this._fields.each(function(field) {
			if(field && field.deregisterChildListeners) {
				field.deregisterChildListeners();
			}
		}.bind(this));
	}
});

/**
 * @class behaviour.gui.updateables.NonUpdateableField
 * @extends behaviour.gui.updateables.UpdateableField  
 */
behaviour.gui.updateables.NonUpdateableField = new Class.create(behaviour.gui.updateables.UpdateableField, {
	createEditField: function() {
		
	},
	
	setEditMode: function() {
		
	},
	
	/**
	 * @return	{string}
	 */
	getValue: function() {
		return "";
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableInvisibleField
 * @extends behaviour.gui.updateables.UpdateableField
 */
behaviour.gui.updateables.UpdateableInvisibleField = new Class.create(behaviour.gui.updateables.UpdateableField, {
	createEditField: function() {
		this.rootNode = document.createDocumentFragment();
	},
	
	addClass: function() {
		
	},
	
	removeClass: function() {
		
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableTableView
 * @extends	behaviour.gui.updateables.UpdateableFieldGroup
 */
behaviour.gui.updateables.UpdateableTableView = new Class.create(behaviour.gui.updateables.UpdateableFieldGroup, {
	
	_icon: null,
	_tableBody: null,
	
	/**
	 * Supports the folloiwng options
	 * 
	 * options: {
	 * 		withStyledFirstRow: boolean			// if true the first tr tag in the table body will have the class name "first"
	 * 		hideEmptyFields: boolean				// if true fields returning null values or empty arrays will not be visible when the table is not in edit mode
	 * 		saveURL: string									// Where to POST the contents of this table to
	 * }
	 * 
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("table");
		this.addClass("UpdateableTableView");
		this._tableBody = DOMUtil.createElement("tbody");
		this.appendChild(this._tableBody);
	},
	
	/**
	 * Adds a row to the table.
	 * 
	 * Supports the following options:
	 * 
	 * options: {
	 * 		invisible: boolean			//  If true the field will not be visible
	 * 		expanding: boolean		//  If true the field is treated as a field that is cabable of adding multiple instances of itself to the table
	 * 		icon: boolean				//  If true the field will be added to the right of the table and have extra blank rows added to pad the table to an appropriate height
	 * 		hideOnEdit: booelan	//  If true the field will not be shown in edit mode
	 * 		hideIf: function				//  If the passed function returns true, the field will not be shown in edit mode
	 * }
	 * 
	 * See behaviour.gui.updateables.UpdatableFieldGroup#addField for more options
	 * 
	 * @param {behaviour.gui.updateables.UpdateableField} fieldData The field
	 * @param {Object} options The field options.  See above for more details.
	 */
	addField: function($super, field, options) {
		$super(field, options);
		
		if(options.icon) {
			this.setIcon(field);
		}
		
		return field;
	},
	
	/**
	 * Sends the contents of the table to the url passed to the constructor as part of the options object
	 * 
	 * @param {Function} callback
	 */
	sendValues: function(callback) {
		new behaviour.ajax.JSONRequest({
			url: this.options.saveURL, 
			args: this.getValues(), 
			onSuccess: callback, 
			method: "post"
		});
	},
	
	/**
	 * @param {behaviour.gui.updateables.UpdatableField} field The icon field
	 */
	setIcon: function(field) {
		this._icon = field;
	},
	
	render: function() {
		DOMUtil.emptyNode(this._tableBody);
		
		var rowCount = 0;
		var iconRowCount = -1;
		
		for(var i = 0, iCount=this._fields.length; i < iCount; i++) {
			//Log.info("name = " + this.fieldNames[i] + " title = " + this.fieldTitles[i] + " invisible = " + this.invisibleFields[i]);
			
			if(!this.getEditMode() && this._fieldOptions[i].hideOnView) {
				continue;
			}
			
			if(this._fields[i] instanceof behaviour.gui.updateables.UpdateableInvisibleField || this._fields[i] == this._icon || (this.getEditMode() && this._fieldOptions[i].hideOnEdit)) {
				continue;
			}
			
			// ignore empty fields
			if(this.options.hideEmptyFields && this._fields[i] && !this.getEditMode() && !(this._fields[i] instanceof behaviour.gui.updateables.NonUpdateableField)) {
				var value = this._fields[i].getValue(true);
				
				if(value == null || (value instanceof Array && value.length == 0) || value == "[]") {
					continue;
				}
			}
			
			if(this._fieldOptions[i].hideIf && this._fieldOptions[i].hideIf()) {
				continue;
			}
			
			var row = document.createElement("tr");
			
			this._stripe(rowCount, row);
			
			var cell = document.createElement("td");
			
			if(!this._fieldOptions[i].spanColumns) {
				var header = document.createElement("th");
				header.appendChild(document.createTextNode(this._fieldOptions[i].label ? this._fieldOptions[i].label : " "));
				row.appendChild(header);
			} else {
				cell.colSpan = "2";
			}
			
			if(this._fields[i]) {
				this._fields[i].appendTo(cell);
			}
			
			row.appendChild(cell);
			
			this._tableBody.appendChild(row);
			
			var iconCell;
			
			// test for icon
			if(this._icon) {
				if(iconRowCount == -1) {
					iconCell = document.createElement("td");
					DOMUtil.addClass(iconCell, "iconCell");
					this._icon.appendTo(iconCell);			
					iconCell.rowSpan = "6";
					
					iconCell.width = (this._icon.width ? this._icon.width : 120);
					iconCell.style.width = (this._icon.width ? this._icon.width : 120) + "px";
					iconCell.vAlign = "top";
					row.appendChild(iconCell);
					
					iconRowCount = 0;
				}
				
				if(iconRowCount >= 6) {
					cell.colSpan = "2";
				}
				
				iconRowCount++;
			}
			
			rowCount++;
		}
		
		if(this._icon) {
			iconCell.rowSpan = iconRowCount;
			
			/*while(iconRowCount < 6) { // pad table with extra rows so is valid
				var row = document.createElement("tr");
				this._stripe(rowCount, row);
				row.appendChild(document.createElement("td"));
				row.appendChild(document.createElement("td"));
				this._tableBody.appendChild(row);
				rowCount++;
				iconRowCount++;
			}*/
		}
	},
	
	/**
	 * @param {integer} rowCount
	 * @param {mixed} row
	 */
	_stripe: function(rowCount, row) {
		if(this.options.withStyledFirstRow) {
			if(rowCount == 0) {
				DOMUtil.addClass(row, "first");
			} else if(rowCount % 2 == 0) {
				DOMUtil.addClass(row, "even");
			}
		} else if(rowCount % 2 == 1) {
			DOMUtil.addClass(row, "even");
		}
	}
});

/**
 * @class behaviour.gui.ProgressBar 
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.ProgressBar = new Class.create(behaviour.gui.GUIWidget, {
	_bar: null,
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("ProgressBar");
		
		if(Object.isUndefined(this.options.size)) {
			this.options.size = 100;
		}
		
		if(Object.isUndefined(this.options.barText)) {
			this.options.barText = "";
		}
		
		this._bar = DOMUtil.createTextElement("span", DOMUtil.createTextElement("em", this.options.barText));
		DOMUtil.setStyle(this._bar, "width", this.options.size + "px");
		
		this.appendChild(this._bar);
	},
	
	setBarSize: function(size) {
		if(Object.isUndefined(size)) {
			size = 100;
		}
		
		DOMUtil.setStyle(this._bar, "width", size+"px");
	},
	
	setBarText: function(text) {
		if(Object.isUndefined(text)) {
			text = "";
		}
		
		this.empty();
		this._bar = DOMUtil.createTextElement("span", DOMUtil.createTextElement("em", text));
		this.appendChild(this._bar );
	},
	
	setBarTextAndSize: function(text, size) {
		this.setBarText(text);
		this.setBarSize(size);
		this.render();
	}
});

/**
 * @class deadline.gui.web.FileUploader
 * @extends behaviour.web.FlashEmbed
 */
deadline.web.FileUploader = new Class.create(behaviour.web.FlashEmbed, {
	
	_bytesSent: null,
	_bytesTotal: null,
	_fileName: null,
	_data: null,
	_description: null,
	_extensions: null,
	_browse: null,
	
	/**
	 * Constructor
	 * Supports the following options: 
	 * options: {
	 * 		staff: deadline.entities.Staff
	 * }
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		
		if(Object.isUndefined(options)) {
			options = {
				
			};
		}
		
		if(Object.isUndefined(options.extensions)) {
			options.extensions = ["*"];
		}
		
		if(Object.isUndefined(options.description)) {
			options.description = "All file types";
		}
		
		for(var i = 0; i < options.extensions.length; i++) {
			options.extensions[i] = options.extensions[i].toLowerCase();
		}
		
		options.swf =  {
			path: "/swf/Uploader.swf",
			id: "FileUploader" + BehaviourUtil.generateGUID(),
			width: 80,
			height: 25,
			flashVars: {
				uploadLocation: "/backend/uploads/uploadFile",
				uploadLimit: ServerConfig.uploadlimit,
				invalidFileCallback: FlashBridge.registerFunction(this.invalidFileCallback.bind(this)),
				uploadProgressCallback: FlashBridge.registerFunction(this.uploadProgressCallback.bind(this)),
				uploadErrorCallback: FlashBridge.registerFunction(this.uploadErrorCallback.bind(this)),
				uploadCompleteCallback: FlashBridge.registerFunction(this.uploadCompleteCallback.bind(this)),
				selectFileCallback: FlashBridge.registerFunction(this.selectFileCallback.bind(this)),
				uploadCancelCallback: FlashBridge.registerFunction(this.uploadCancelCallback.bind(this)),
				mouseClickCallback: FlashBridge.registerFunction(this.mouseClickCallback.bind(this)),
				uploadName: "assetFile",
				description: options.description,
				extensions: options.extensions,
				sessionIdName: "DeadlineAPISessionID",
				sessionIdValue: Cookie.get("DeadlineAPISessionID")
			}
		}
		
		if(Object.isUndefined(options.transpartent)) {
				options.transparent = true;
		}
		
		this._browse = true;
		
		$super(options);
	},
	
	selectFileCallback: function(fileName, fileSize) {
		this._fileName = fileName;
		this._bytesTotal = fileSize;
		
		this.notifyListeners("onFileSelected");
	},
	
	invalidFileCallback: function() {
		this.notifyListeners("onInvalidFile");
	},
	
	uploadProgressCallback: function(bytesSent, bytesTotal) {
		this._bytesSent = bytesSent;
		this._bytesTotal = bytesTotal;
		
		this.notifyListeners("onUploadProgress");
	},
	
	uploadErrorCallback: function() {
		this.notifyListeners("onUploadError");
	},
	
	uploadCompleteCallback: function(data) {
		this._data = data;
		this.notifyListeners("onUploadComplete");
	},
	
	uploadCancelCallback: function() {
		this.notifyListeners("onUploadCancelled");
	},
	
	mouseClickCallback: function() {
		
	},
	
	getBytesSent: function() {
		return this._bytesSent;
	},
	
	getBytesTotal: function() {
		return this._bytesTotal;
	},
	
	getFileName: function() {
		return this._fileName;
	},
	
	getData: function() {
		return this._data;
	},
	
	setUploadFileTypes: function(description, extensions) {
		this.callFlashFunction("setUploadFileTypes", [description, extensions]);
	},
	
	chooseFile: function() {
		this.callFlashFunction("chooseFile");
	},
	
	startUpload: function() {
		if(this.options.extensions.indexOf("*") == -1) {
			var extension = this.getFileName().split(".").pop().toLowerCase();
			
			if(this.options.extensions.indexOf(extension) == -1) {
				this.notifyListeners("onInvalidFileExtension");
				Log.info("Invalid file extensions");
				return;
			}
		}
				
		this.callFlashFunction("startUpload");
	},
	
	cancelUpload: function() {
		this.callFlashFunction("cancelUpload");
	},
	
	setButtonText: function(text) {
		this.callFlashFunction("setButtonText", text);
	},
	
	hideButton: function() {
		this.callFlashFunction("hideButton");
	},
	
	setBrowse: function(browse) {
		this._browse = browse;
	},
	
	getBrowse: function() {
		return this._browse;
	}
});

/**
 * @class behaviour.gui.SWFUploadBox
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.SWFUploadBox = new Class.create(behaviour.gui.GUIWidget, {
	
	_fileUploader: null,
	_progressBar: null,
	_percentage: null,
	
	_uploadButton: null,
	_deleteButton: null,
	
	_uploadData: null,
	_fileName: null,
	_fileSize: null,
	
	/**
	 * Supoprts the following options:
	 * 
	 * options: {
	 * 		extensions: Array		// Optional - an array of allowed file extensions: ["csv", "tsv", "txt"] 
	 * 		description: String		// Optional - file extensions description: "Contacts, *.csv, *.tsv, *.txt"
	 * 		uploadButton: Boolean		// Optional - restricts creation of upload button, 
	 *  	uploadTo: String		// Required - Upload path		
	 * }
	 * 
	 * Supports the following callbacks:
	 * 
	 * onFileSelected
	 * onUploadCancel
	 * onUploadProgress
	 * onUploadComplete
	 * onUploadError
	 * onInvalidFileExtension
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("ul");
		this.addClass("SWFUploadBox");
		
		this._fileName = null;
		this._fileSize = null;
		
		this._fileUploader = new deadline.web.FileUploader({transparent: true, description: this.options.description, extensions: this.options.extensions});	
		this._progressBar = new behaviour.gui.ProgressBar({barText: Language.get("bbq.gui.SWFUploadBox.choosefile")});
		this._percentage = new behaviour.gui.updateables.UpdateableField({initialValue: "0%"});
		
		if(Object.isUndefined(this.options.uploadButton)) {
			this._uploadButton = false;
		} else {
			this._uploadButton = this.options.uploadButton;
		}
		
		this.appendChild(DOMUtil.createTextElement("li", this._progressBar));
		this.appendChild(DOMUtil.createTextElement("li", this._percentage, {className:"Percentage"}));
		this.appendChild(DOMUtil.createTextElement("li", this._fileUploader));
		
		this._fileUploader.registerListener("onLoad", function() {
			this._fileUploader.setButtonText(Language.get("bbq.gui.SWFUploadBox.browse"));
		}.bind(this));
		
		this._fileUploader.registerListener("onFileSelected", function() {
			this.notifyListeners("onFileChosen");
			
			this._fileName = this._fileUploader.getFileName();
			this._fileSize = this._fileUploader.getBytesTotal();
			
			this._progressBar.setBarTextAndSize(this._getFileName(this._fileName) +" "+ BehaviourUtil.formatFileSize(this._fileSize), 0);
			
			if(this._uploadButton) {
				this._uploadButton.setDisabled(false);
			}else{
				this.beginUpload();
			}
		}.bind(this));
		
		this._fileUploader.registerListener("onUploadCancel", function() {
			Log.info("onUploadCancel");
			this.notifyListeners("onUploadCancel");
			
			if(this._uploadButton) {
				this._uploadButton.setDisabled(true);
			}
			
			this._fileName = Language.get("bbq.gui.SWFUploadBox.choosefile");
			
			this._percentage.setValue("0%");
			this._progressBar.setBarTextAndSize(this._getFileName(this._fileName), 0);
			
			this._fileUploader.setButtonText(Language.get("bbq.gui.SWFUploadBox.browse"));
			this._fileUploader.setBrowse(true);
		}.bind(this));
		
		this._fileUploader.registerListener("onUploadComplete", function() {
			this._percentage.setValue("100%");
			this._progressBar.setBarSize(200);
			this._progressBar.render();
			this._getUploadData();
			
			this.notifyListeners("onUploadComplete");
			if(this._uploadButton) {
				this._uploadButton.setDisabled(true);
			}
		}.bind(this));
		
		this._fileUploader.registerListener("onUploadError", function() {
			this.notifyListeners("onUploadError");
			if(this._uploadButton) {
				this._uploadButton.setDisabled(true);
			}
		}.bind(this));
		
		this._fileUploader.registerListener("onUploadProgress", function() {
			this.notifyListeners("onUploadProgress");
			
			if(this._uploadButton) {
				this._uploadButton.setDisabled(true);
			}
			
			var completed = Math.round((this._fileUploader.getBytesSent()/this._fileSize)*100);
			this._percentage.setValue(completed+"%");
			this._progressBar.setBarSize(Math.round(completed*2));
			this._progressBar.render();
		}.bind(this));
	},
	
	appendBefore: function(parentNode, beforeNode) {
		parentNode.insertBefore(this.getRootNode(), beforeNode);
	},
	
	beginUpload: function() {
		if(this._fileName) {
			var extension = this._fileName.split(".").pop().toLowerCase();
			if(this.options.extensions instanceof Array && this.options.extensions.indexOf(extension) == -1) {
				this.notifyListeners("onInvalidFileExtension");
				Log.info("Invalid file extensions");
				return;
			}
			
			this._fileUploader.setBrowse(false);
			this._fileUploader.setButtonText(Language.get("bbq.gui.SWFUploadBox.cancel"));
			this._fileUploader.startUpload();
		}
	},
	
	cancelUpload: function() {
		this._fileUploader.cancelUpload();
	},
	
	_getUploadData: function() {		
		this._uploadData = this._fileUploader.getData();
	},
	
	getUploadData: function() {
		return this._uploadData;
	},
	
	getUploadError: function() {
		return this._uploadData;
	},
	
	/**
	 * @private
	 */
	_getFileName: function(fileName) {
		return (fileName.length > 19 ? fileName.substr(0, 8) + "..." + fileName.substr(fileName.length - 8, 8) : fileName);
	},
	
	getFileName: function() {
		return this._fileName;
	},
	
	getFileSize: function() {
		return this._fileSize;
	},
	
	getFileTransferID: function() {
		var data = this.getUploadData();
		Log.dumpObject(data);
		return data["filetransferid"];
	}	
});

/**
 * @class behaviour.gui.FileUploaderFlash
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.FileUploaderFlash = new Class.create(behaviour.gui.GUIWidget, {
	_numFilesDisplay: null,
	
	// where the SWFUploadBox live
	_filesToUploadDiv: null,
	_uploadTable: null,
	
	// where the thumbnails live
	_filesUploadedDiv: null,
	
	// the button that starts the upload process
	_uploadButton: null,
	
	_thumbnailDisplayMaximised: null,
	
	// holds data on files currently being uploaded
	_uploadingFileData: null,
	
	// data describing files that have been uploaded
	_uploadedFiles: null,
	
	_escapeKeyObserver: null,
	
	/**
	 * @param {object} options 
	 * 
	 * Supports the following options:
	 * options: {
	 * 		owner: Object,					// the object that will recieve the files
	 * 		multiple: boolean				// whether to accept multiple files
	 * 		sendFilesTo: String			// where to POST the files to
	 * 		language: {
	 * 
	 * 		}
	 * 		acceptedFileExtensions: Array
	 * }
	 * 
	 * Supports the following events:
	 * 
	 * onFilesUploaded
	 */
	initialize: function($super, options) {
		$super(options);
		
		this._uploadedFiles = [];
		this._uploadingFileData = [];
		this._thumbnailDisplayMaximised = false;
		this._uploads = 0;
		
		this.setRootNode("div");
		this.addClass("FileUploader");
		
		if(this.options.multiple) {
			this.addClass("MultipleFileUploader");
		} else {
			this.addClass("SingleFileUploader");
		}
		
		this._escapeKeyObserver = function(event) {
			if(event.keyCode == Event.KEY_ESC) {
				this._cancelUpload();
			}
		}.bind(this);
		
		this._formatUploadTo();
		Log.info(this.options.uploadTo);
		
		Event.observe(document, "keypress", this._escapeKeyObserver);
	},
	
	/**
	 * Renders
	 */
	render: function() {
		this.empty();
		
		var saveCancel = new deadline.gui.button.SaveCancel({
			saveText: "Done",
			saveCallback: this._saveUpload.bindAsEventListener(this), 
			cancelCallback: this._cancelUpload.bindAsEventListener(this),
			nativeButtons: true
		});
		saveCancel.setEditMode(true);
		
		var header = new deadline.gui.panel.HeaderPanel();
		header.setHeaderLeft(Language.get("bbq.gui.FileUploaderFlash.title"));
		header.setHeaderRight(saveCancel);
		
		this.appendChild(header);
		
		this._filesToUploadDiv = this.appendChild(DOMUtil.createTextElement("div", DOMUtil.createTextElement("h3",	[
			DOMUtil.createTextElement("span", Language.getFormatted("behaviour.gui.FileUploaderFlash.maxsize", {fileSize: BehaviourUtil.formatFileSize(ServerConfig["uploadlimit"])})),
			Language.get("bbq.gui.FileUploaderFlash.choosefile")
		]), {className: "FilesToUpload"}));
		
		this._uploadTable = DOMUtil.createTextElement("table", DOMUtil.createElement("tbody"));
		this._filesToUploadDiv.appendChild(this._uploadTable);
		
		this._uploadButton = new behaviour.gui.button.ButtonHolder({ignoreKeyPresses: true});
		this._uploadButton.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("bbq.gui.FileUploaderFlash.upload"), onclick: this._uploadFiles.bindAsEventListener(this), startDisabled: true}));
		
		var header = new deadline.gui.panel.HeaderPanel();
		
		if(this.options.multiple) {
			this._addAnother = DOMUtil.createTextElement("p", [
				new behaviour.gui.button.AddButton({onclick: this._addFile.bind(this)}),
				Language.get("bbq.gui.FileUploaderFlash.addasset")
			]);
			
			header.setHeaderLeft(this._addAnother);
		}
		
		this.appendChild(header);
		
		this._filesUploadedDiv = this.appendChild(DOMUtil.createElement("div", {className:  "FilesUploaded"}));
		
		this._addFile();
	},
	
	/**
	 * @private
	 */
	_addFile: function() {
		if(!this.options.multiple && this._uploadedFiles.length != 0) {
			return;
		}
		
		$A(this._filesToUploadDiv.childNodes).each(function(node) {
			if(node.tagName.toLowerCase() == "h3") {
				node.style.display = "block";
			}
		});
		
		this._minimiseThumbnailArea();
	
		var fileUploader = new behaviour.gui.SWFUploadBox({uploadButton:this._uploadButton, uploadTo: this.options.uploadTo, extensions: this.options.extensions, description: this.options.description});	
		var row = DOMUtil.createTextElement("tr", DOMUtil.createTextElement("td", fileUploader));
		
		row.appendChild(DOMUtil.createTextElement("td", this._uploadButton));
		
		this._uploadTable.getElementsByTagName("tbody")[0].appendChild(row);
		
		// store data
		this._uploadingFileData.push({
			fileUploading: false,
			row: row,
			fileUploader: fileUploader
		});
	},
	
	/**
	 * @private
	 */
	_uploadFiles: function() {
		//var hasValidFiles = false;
		
		// loop through upload boxes and get file data
		for(var i = 0; i < this._uploadingFileData.length; i++) {
			var fileData = this._uploadingFileData[i];
			
			if(!fileData.fileUploading) {
				
				if(fileData.fileUploader) {
					if(fileData.fileUploader.getFileSize() == null){
						if(this._uploadingFileData.length > 1) {
							// no file has been chosen, remove frame
							this._uploadTable.getElementsByTagName("tbody")[0].removeChild(fileData.row);
							this._uploadingFileData.splice(i, 1);
							i--;
						}
						continue;
					}
					
					var div = DOMUtil.createTextElement("div", DOMUtil.createTextElement("p", Language.get("bbq.gui.FileUploaderFlash.uploading")), {className: "fileUploadWaitBox emptyfileUploadWaitBox"});
					this._filesUploadedDiv.appendChild(div);
					
					fileData.fileUploading = true;
					fileData.div = div;
					fileData.fileName = this._getFileName(fileData.fileUploader.getFileName());
					
					fileData.fileUploader.registerListener("onUploadComplete", function(fileData){
						this._getUploadedData(fileData);
						
						if(!this._addAnother) {
							this._uploadButton.setDisabled(true);
						}
						
						var headers = this._filesToUploadDiv.getElementsByTagName("h3");
						
						for(var i = 0, iCount=headers.length; i < iCount; i++) {
							headers[i].style.display = "none";
						}
						
						DOMUtil.setStyle(fileData.fileUploader, "height", "0px");
								
						if(this._uploadingFileData.length == this._uploadedFiles.length) {
							this._maximiseThumbnailArea();
						}
						
					}.bind(this, fileData));
					
					fileData.fileUploader.registerListener("onUploadError", function(fileData) {
						this._fileUploadError(fileData.fileName, fileData.div);
					}.bind(this, fileData));
					
					fileData.fileUploader.registerListener("onUploadCancel", function(fileData, i) {
						this._uploadTable.getElementsByTagName("tbody")[0].removeChild(fileData.row);
						this._filesUploadedDiv.removeChild(fileData.div);
						this._uploadingFileData.splice(i, 1);
					}.bind(this, fileData, i));
					
					fileData.fileUploader.beginUpload();
				}
			}
		}
	},
	
	/**
	 * @private
	 */
	_getFileName: function(fileName) {
		return (fileName.length > 19 ? fileName.substr(0, 8) + "..." + fileName.substr(fileName.length - 8, 8) : fileName);
	},
	
	/**
	 * @private
	 */
	_minimiseThumbnailArea: function() {
		if(this._thumbnailDisplayMaximised) {
			this._thumbnailDisplayMaximised = false;
			this._uploadButton.setDisabled(false);
			Effect.BlindDown(this._filesToUploadDiv, {duration: 0.5, afterUpdate: this._resizeUploadedFilesArea.bind(this)});
		}
	},
	
	/**
	 * @private
	 */
	_formatUploadTo: function() {
		// ensure uploadTo is properly formatted, otherwise form.submit won't work
		if(this.options.uploadTo.substring(0, 4) != "http") {
			this.options.uploadTo = window.location.protocol + "//" + window.location.host + (this.options.uploadTo.substring(0, 1) == "/" ? "" : "/") + this.options.uploadTo;
		}
	},
	
	/**
	 * @private
	 */
	_maximiseThumbnailArea: function() {
		if(!this._thumbnailDisplayMaximised) {
			this._thumbnailDisplayMaximised = true;
			this._uploadButton.setDisabled(true);
			Effect.BlindUp(this._filesToUploadDiv, {duration: 0.5, afterUpdate: this._resizeUploadedFilesArea.bind(this)});
		}
	},
	
	/**
	 * @private
	 */
	_resizeUploadedFilesArea: function() {
		var newHeight = (this.options.multiple ? 358 : 298) - (this._filesToUploadDiv.style.height.replace("px", ""));
		this._filesUploadedDiv.style.height = newHeight + "px";
	},
	
	/**
	 * @private
	 */
	_updateNumFilesDisplay: function() {
		if(this._numFilesDisplay) {
			DOMUtil.emptyNode(this._numFilesDisplay);
			this._numFilesDisplay.appendChild(
					document.createTextNode(
						Language.getFormatted(this._uploadedFiles.length == 1 ? "behaviour.gui.FileUploaderFlash.singleassetcount" : "behaviour.gui.FileUploaderFlash.multipleassetcount", {
							count: this._uploadedFiles.length
						}
					)
				)
			);
		}
	},
	
	/**
	 * Interrogates iFrames for uploaded file data.  Called via an onload event fired on the iFrame after form submission.
	 */
	_getUploadedData: function(fileData) {
		if(fileData.fileUploading) {
			this._fileUploaded(fileData, fileData.fileUploader.getUploadData());
		} else {
			Log.dumpObject(fileData);
		}
	},
	
	_FileUploaderFlashror: function(fileName, outputDiv) {
		DOMUtil.emptyNode(outputDiv);
		DOMUtil.addClass(outputDiv, "uploadError");
		
		var deleteLink = new behaviour.gui.button.DeleteButton({onclick: this._removeErrorFile.bind(this, outputDiv)});
		deleteLink.appendTo(outputDiv);
		
		outputDiv.appendChild(DOMUtil.createTextElement("p", "Error uploading " + fileName));
	},
	
	_removeErrorFile: function(element) {
		Effect.Fade(element, {duration: 0.25});
		
		if(this._uploadedFiles.length == 0) {
			this._addFile();
			this._minimiseThumbnailArea();
		}
	},
	
	/**
	 * @private
	 */
	_fileUploaded: function(fileData, passedData) {
		// remove old file name so that we can upload the same file twice
		var iFrameIndex = 0;
		
		Log.dumpObject(passedData);
		
		DOMUtil.emptyNode(fileData.div);
		
		fileData.div.id = BehaviourUtil.generateGUID() + "_" + passedData.filetransferid;
		
		//this._filesToUploadDiv.removeChild(fileData.iframe);
		this._uploadTable.getElementsByTagName("tbody")[0].removeChild(fileData.row);
		
		var image = DOMUtil.createElement("img", {
			src: "/backend/uploads/getTemporaryThumbnail?id=" + passedData.filetransferid,
			style: {
				display: "none"
			}
		});
		
		fileData.div.appendChild(image);
		DOMUtil.removeClass(fileData.div, "emptyfileUploadWaitBox");
		
		var deleteLink = new behaviour.gui.button.DeleteButton({onclick: this._removeUploadedFile.bind(this, fileData.div)});
		deleteLink.appendTo(fileData.div);
				
		fileData.div.appendChild(DOMUtil.createTextElement("p", [
			passedData.filesize,
			DOMUtil.createElement("br"),
			fileData.fileName
		]));
		
		image.onload = function() {
			if(image.width < 128) {
				image.style.marginLeft = Math.ceil((128 - image.width)/2) + "px";
			}
			
			if(image.height < 128) {
				var newMargin = Math.ceil((128 - image.height)/2) + "px";
				DOMUtil.setStyle(image, "marginTop", newMargin);
				DOMUtil.setStyle(image, "marginBottom", newMargin);
			}
		};
			
		this._uploadedFiles.push(passedData);
		
		this._updateNumFilesDisplay();
		
		Effect.Appear(image, {duration: 0.25});
	},
	
	/**
	 * @private
	 */
	_removeUploadedFile: function(element) {
		Effect.Fade(element, {duration: 0.25});
		
		// remove uploaded file data
		var keyToRemove = element.id.split("_")[1];
		
		for(var i = 0; i < this._uploadedFiles.length; i++) {
			if(this._uploadedFiles[i].filetransferid == keyToRemove) {
				this._uploadedFiles.splice(i, 1);
				break;
			}
		}
		
		this._updateNumFilesDisplay();
		
		if(this._uploadedFiles.length == 0) {
			this._addFile();
			this._minimiseThumbnailArea();
		}
		
		return false;
	},
	
	/**
	 * @private
	 */
	_cancelUpload: function() {
		if(this.willDelegateMethod("cancelUpload")) {
			return this.delegateMethod("cancelUpload");
		}
		
		currentPage.clearModalLayer();
		
		Event.stopObserving(document, "keypress", this._escapeKeyObserver);
	},
	
	/**
	 * @private
	 */
	_saveUpload: function() {
		if(this.willDelegateMethod("saveUpload")) {
			return this.delegateMethod("saveUpload");
		}
		
		currentPage.clearModalLayer();
		this.notifyListeners("onFilesUploaded");
	},
	
	/**
	 * @return {Array} uploaded files
	 */
	getFiles: function() {
		return this._uploadedFiles;
	}
});

/**
 * @class deadline.gui.uploads.ProgressBar
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.uploads.ProgressBar = new Class.create(behaviour.gui.GUIWidget, {
	_bar: null,
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("ProgressBar");
		
		if(Object.isUndefined(this.options.size)) {
			this.options.size = 100;
		}
		
		this._bar = DOMUtil.createTextElement("div", {style: {width: 0}, className: "ProgressBar_bar"});
		
		this.appendChild(this._bar);
	},
	
	render: function() {
		this.empty();
		this.appendChild(this._bar);
	},
	
	setProgress: function(percent) {
		var size = (this.options.size/100) * percent;
		
		DOMUtil.setStyle(this._bar, "width", size+"px");
	}
});

deadline.gui.uploads.FileUpload = new Class.create(behaviour.gui.GUIWidget, {
	_uploader: null,
	_progressBar: null,
	_thumbnailDisplay: null,
	_fileNameDisplay: null,
	_fileSizeDisplay: null,
	_fileSizeWarning: null,
	_cancelUploadButton: null,
	_status: "waiting",
	
	/**
	 * Supports the following options:
	 * 
	 * options: {
	 * 		fileUploader: Object		// The file uploader
	 * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("FileUpload");
		
		this._uploader = new deadline.web.FileUploader({
			transparent: true, 
			description: this.options.description, 
			extensions: this.options.extensions
		});	
		
		this._uploader.registerListener("onLoad", this._uploaderLoaded.bind(this));
		this._uploader.registerListener("onInvalidFile", this._invalidFile.bind(this));
		this._uploader.registerListener("onFileSelected", this._fileSelected.bind(this));
		this._uploader.registerListener("onUploadCancelled", this._uploadCancelled.bind(this));
		this._uploader.registerListener("onUploadComplete", this._uploadComplete.bind(this));
		this._uploader.registerListener("onUploadError", this._uploadError.bind(this));
		this._uploader.registerListener("onUploadProgress", this._uploadProgress.bind(this));
		
		this._progressBar = new deadline.gui.uploads.ProgressBar();
		this._progressBar.setStyle("display", "none");
		
		this._thumbnailDisplay = DOMUtil.createElement("div");
		this._fileNameDisplay = DOMUtil.createElement("div", {className: "FileUpload_fileNameDisplay"});
		this._fileSizeDisplay = DOMUtil.createElement("div", {className: "FileUpload_fileSizeDisplay"});
		this._fileSizeWarning = DOMUtil.createTextElement("div", 
			DOMUtil.createTextElement("p", Language.getFormatted("deadline.gui.uploads.FileUpload.maxiumsize", {size: BehaviourUtil.formatFileSize(ServerConfig.uploadlimit)})), 
			{className: "FileUpload_fileSizeWarningDisplay"});
		this._cancelUploadButton = new behaviour.gui.button.DeleteButton({onclick: this._cancelUpload.bind(this)});
		this._cancelUploadButton.setStyle("display", "none");
	},
	
	render: function() {
		this.empty();
		
		if(this._status == "waiting") {
			this.appendChild(this._progressBar);
			this.appendChild(this._uploader);
			this.appendChild(this._fileSizeWarning);
			this.appendChild(this._fileNameDisplay);
			this.appendChild(this._fileSizeDisplay);
			
		} else if(this._status == "uploaded") {
			var image = DOMUtil.createElement("img", {
				src: "/backend/uploads/getTemporaryThumbnail?id=" + this._uploadData.filetransferid,
				style: {
					display: "none"
				}
			});
			image.onload = function() {
				if(image.width < 128) {
					image.style.marginLeft = Math.ceil((128 - image.width)/2) + "px";
				}
				
				if(image.height < 128) {
					var newMargin = Math.ceil((128 - image.height)/2) + "px";
					DOMUtil.setStyle(image, "marginTop", newMargin);
					DOMUtil.setStyle(image, "marginBottom", newMargin);
				}
			};
			
			this._thumbnailDisplay.appendChild(image);
			
			this.appendChild(this._thumbnailDisplay);
			this.appendChild(this._fileNameDisplay);
			this.appendChild(this._fileSizeDisplay);
			
			Effect.Appear(image, {duration: 0.25});
		}
	},
	
	_uploaderLoaded: function() {
		this._uploader.setButtonText(Language.get("deadline.gui.uploads.FileUpload.browse"));
	},
	
	_invalidFile: function() {
		alert(Language.get("deadline.gui.uploads.FileUpload.filetolarge"));
	},
	
	_fileSelected: function() {
		DOMUtil.emptyNode(this._fileNameDisplay);
		this._fileNameDisplay.appendChild(DOMUtil.createTextElement("p", 
			BehaviourUtil.shorten(this._uploader.getFileName(), 14)
		));
		
		this._cancelUploadButton.appendTo(this._fileSizeDisplay);
		this._fileSizeDisplay.appendChild(DOMUtil.createTextElement("p", 
			BehaviourUtil.formatFileSize(this._uploader.getBytesTotal())
		));
		
		this._uploader.hideButton();
		this._status = "uploading";
		this._progressBar.setStyle("display", "block");
		this._cancelUploadButton.setStyle("display", "block");
		
		DOMUtil.setStyle(this._fileSizeWarning, "display", "none");
		
		this._uploader.startUpload();
		
		this.addClass("FileUpload_uploading");
	},
	
	// called by button
	_cancelUpload: function() {
		this._uploader.cancelUpload();
		this.removeClass("FileUpload_uploading");
		Effect.Fade(this.getRootNode(), {duration: 0.2});
		this.notifyListeners("onUploadCancelled");
	},
	
	// called by flash
	_uploadCancelled: function() {
		Effect.Fade(this.getRootNode(), {duration: 0.2});
		this.removeClass("FileUpload_uploading");
		this.notifyListeners("onUploadCancelled");
	},
	
	_uploadComplete: function() {
		this._status = "uploaded";
		this._uploadData = this._uploader.getData();
		this.render();
		this.removeClass("FileUpload_uploading");
		this.notifyListeners("onUploadComplete");
	},
	
	_uploadError: function() {
		this.removeClass("FileUpload_uploading");
		this.addClass("FileUpload_error");
		this._progressBar.setStyle("display", "none");
	},
	
	_uploadProgress: function() {
		var completed = Math.round((this._uploader.getBytesSent()/this._uploader.getBytesTotal()) * 100);
		
		this._progressBar.setStyle("display", "block");
		this._progressBar.setProgress(completed);
		
		this.notifyListeners("onUploadProgress");
	},
	
	getUploadData: function() {
		return this._uploadData;
	}
});

/**
 * @class deadline.gui.uploads.FileUploader
 * @extends behaviour.gui.ModalWindow
 */
deadline.gui.uploads.FileUploader = new Class.create(behaviour.gui.ModalWindow, {
	_uploaders: null,
	_uploaderDisplay: null,
	_footer: null,
	
	/**
	 * Supports the following options:
	 * 
	 * options: {
	 * 		multiple: boolean			// Whether to allow multiple uploads
	 * }
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.width = 500;
		options.height = 440;
		options.showChrome = true;
		
		$super(options);
		
		this.addClass("FileUploaders");
		
		this._footer = new deadline.gui.panel.HeaderPanel();
		
		var doneButtonHolder = new behaviour.gui.button.ButtonHolder();
		doneButtonHolder.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.shared.done"), onclick: this._done.bind(this)}));
		this._footer.setHeaderRight(doneButtonHolder);
		
		if(this.options.multiple) {
			var addAnother = DOMUtil.createTextElement("p", [
				new behaviour.gui.button.AddButton({onclick: this._addUpload.bind(this)}),
				Language.get("deadline.gui.uploads.FileUploader.addupload")
			]);
			
			this._footer.setHeaderLeft(addAnother);
		}
		
		this._uploaders = [];
		this._uploaderDisplay = new behaviour.gui.panel.ScrollableHolder();
		this._addUpload();
		
		this.setContent(DOMUtil.createTextElement("div", [
			this._uploaderDisplay,
			this._footer
		]));
	},
	
	_addUpload: function() {
		var uploader = new deadline.gui.uploads.FileUpload({
			extensions: this.options.extensions,
			description: this.options.description
		});
		uploader.registerListener("onUploadCancelled", this._uploadCancelled.bind(this, uploader));
		uploader.registerListener("onUploadComplete", this._uploadComplete.bind(this, uploader));
		uploader.appendTo(this._uploaderDisplay);
		
		this._uploaders.push(uploader);
	},
	
	_uploadCancelled: function(uploader) {
		for(var i = 0; i < this._uploaders.length; i++) {
			if(this._uploaders[i] == uploader) {
				this._uploaders.splice(i, 1);
			}
		}
		
		if(this._uploaders.length == 0) {
			this._addUpload();
		}
		
		if(this.willDelegateMethod("cancelUpload")) {
			return this.delegateMethod("cancelUpload");
		}
	},
	
	_uploadComplete: function(uploader) {
		
	},
	
	_done: function() {
		// make sure files have actually been uploaded
		var notified = false;
		
		this._uploaders.each(function(uploader) {
			if(!notified && uploader.getUploadData() != null) {
				this.notifyListeners("onFilesUploaded");
				notified = true;
			}
		}.bind(this));
		
		if(notified && this.willDelegateMethod("saveUpload")) {
			return this.delegateMethod("saveUpload");
		}
		
		currentPage.clearModalLayer();
	},
	
	getFiles: function() {
		var output = [];
		
		this._uploaders.each(function(uploader) {
			if(uploader.getUploadData() != null) {
				output.push(uploader.getUploadData());
			}
		});
		
		return output;
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableImageField
 * @extends behaviour.gui.updateables.UpdateableField
 */
behaviour.gui.updateables.UpdateableImageField = new Class.create(behaviour.gui.updateables.UpdateableField, {
	
	_oldImage: null,
	_currentImage: null,
	_chooseButtonHolder: null,
	_currentImageNode: null,
	_fileUploaded: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		getImage: function						// should return the path to the image
	 * 		uploadTo										// Where to POST the image
	 * 		language: Object							// passed to a behaviour.gui.FileUploader object
	 * 		deleteButtonText							// Text displayed on the delete button - defaults to "Remove"
	 * }
	 * 
	 * Supports the following callbacks
	 * 
	 * onFileDeleted
	 * onFileChosen
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.setRootNode("div");
		this.addClass("UpdateableImageField");
		
		if(this._getImage()) {
			this._oldImage = this._getImage();
			this._currentImage = this._getImage();
			
			this.addClass("UpdateableImageField_WithImage");
		}
		
		this._setCurrentValue(null);
		
		this._chooseImageButtonText = Language.get("bbq.gui.updateables.UpdateableImageField.uploadfile");
		this._deleteImageButtonText = this.options.deleteButtonText ? this.options.deleteButtonText : Language.get("bbq.gui.updateables.UpdateableImageField.remove");
	},
	
	_updateInitialValues: function() {
		this._currentImage = this._getImage();
		this.render();
	},
	
	_getImage: function() {
		if(this.options.getImage && this.options.getImage instanceof Function) {
			var entity = this.options.propertyDisplay ? this.options.propertyDisplay.entity : null;
			
			return this.options.getImage(entity);
		}
		
		return false;
	},
	
	setPropertyDisplay: function(key, entity) {
		if(this._currentImageNode) {
			this._currentImageNode.onload = null;
			this._currentImageNode = null;
		}
		
		behaviour.gui.updateables.UpdateableField.prototype.setPropertyDisplay.apply(this, arguments);
	},
	
	_createImage: function() {
		this.addClass("UpdateableImageField_WithImage");
		this.setStyle("paddingTop", "0px");
		this.setStyle("paddingBottom", "0px");
		
		if(!this._currentImageNode) {
			if(!this._fileUploaded && this.options.propertyDisplay) {
				Log.info("have property display");
				this._currentImageNode = this.options.propertyDisplay.entity.getPropertyDisplay({
					property: this.options.propertyDisplay.key, 
					createNode: function() {
						return DOMUtil.createElement("img");
					},
					updateNode: function(node, property) {
						node.src = this._currentImage;
					}.bind(this)
				});
			} else {
				Log.info("creating from passed value");
				this._currentImageNode = DOMUtil.createElement("img", {src: this._currentImage, alt: ""});
			}
			
			this._currentImageNode.onload = function() {
				var height = this._currentImageNode.height;
				var width = this._currentImageNode.width;
				
				if(height == 0 && width == 0) {
					return;
				}
				
				if(width < 128) {
					DOMUtil.setStyle(this._currentImageNode, "marginLeft", Math.round((128 - width)/2) + "px");
				}
				
				if(height < 128) {
					var padding = Math.round((128 - height)/2) + "px";
					
					DOMUtil.setStyle(this._currentImageNode, "marginTop", padding);
					DOMUtil.setStyle(this._currentImageNode, "marginBottom", padding);
				}
			}.bind(this);
		}
		
		this.appendChild(this._currentImageNode);
	},
	
	createEditField: function() {
		this.empty();
		
		if(this._currentImage) {
			this._createImage();
		} else {
			this.removeClass("UpdateableImageField_WithImage");
			this.setStyle("paddingTop", "128px");
		}
		
		this._chooseButtonHolder = new behaviour.gui.button.ButtonHolder({ignoreKeyPresses: true});
		
		if(this._currentImage) {
			this._chooseButtonHolder.addButton(new behaviour.gui.button.NativeButton({buttonText: this._deleteImageButtonText, onclick: this._deleteFile.bind(this)}));
		}
		
		this._chooseButtonHolder.addButton(new behaviour.gui.button.NativeButton({buttonText: this._chooseImageButtonText, onclick: this.options.uploadFunction ? this.options.uploadFunction.bind(this, this) : this._showFilePickerWindow.bind(this)}));
		
		this.appendChild(this._chooseButtonHolder);
	},
	
	createViewField: function() {
		this.empty();
		
		if(this._currentImage) {
			this._createImage();
		} else {
			this.removeClass("UpdateableImageField_WithImage");
			this.setStyle("paddingTop", "128px");
		}
	},
	
	_deleteFile: function() {
		this._setCurrentValue(-1);
		
		this._fileUploaded = false;
		this._currentImage = false;
		this.render();
		this.notifyListeners("onFileRemoved");
		this.notifyListeners("onValueChanged");
	},
	
	_showFilePickerWindow: function() {
		var filePicker = new deadline.gui.uploads.FileUploader({
			title: "Upload image",
			description: "Images",
			extensions: ["jpg", "gif", "png"],
			multiple: this.options.multiple
		});
		filePicker.registerListener("onFilesUploaded", this._filesUploaded.bind(this));
		currentPage.addModalLayer(filePicker);
	},
	
	_filesUploaded: function(imagePicker) {
		var files = imagePicker.getFiles();
		
		if(files.length > 0) {
			this._fileUploaded = true;
			this._currentImageNode = false;
			
			this._oldImage = this._currentImage;
			
			if(files.length == 1) {
				this._currentImage = "/backend/uploads/getTemporaryThumbnail?id=" + files[0].filetransferid;
			} else {
				//this._currentImage = "/img/icons/128x128/content-types/multiple.png";
				this._currentImage = "/backend/uploads/getTemporaryThumbnail?id=" + files[0].filetransferid;
			}
			
			if(this.options.multiple) {
				this._setCurrentValue(files.pluck("filetransferid"));
			} else {
				this._setCurrentValue(files[0].filetransferid);
			}
			
			this.render();
		}
		
		this.notifyListeners("onFileUploaded", files);
		this.notifyListeners("onValueChanged");
	},
	
	cancelEdit: function() {
		this._setCurrentValue(null);
		this._currentImage = this._oldImage;
		this._fileUploaded = false;
		this.createViewField();
	},
	
	saveEdit: function() {
		if(this._getCurrentValue() == -1) {
			this.notifyListeners("onFileDeleted");
		} else {
			if(this.options.propertyDisplay) {
				// set current value to null - old value was previously uploaded file so set to null so we don't try to overwrite it with one that now will not exist
				this.currentValue = null;
			}
		}
		
		this._oldImage = this._getImage();
		this._currentImage = this._getImage();
	},
	
	getValue: function(supressError) {
		return this._getCurrentValue(supressError);
	},
	
	setDisabled: function($super, disabled) {
		$super(disabled);
		
		if(this._chooseButtonHolder) {
			this._chooseButtonHolder.setDisabled(disabled);
		}
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableFileField
 * @extends  behaviour.gui.updateables.UpdateableImageField
 */
behaviour.gui.updateables.UpdateableFileField = new Class.create(behaviour.gui.updateables.UpdateableImageField, {
	/**
	 * @param {Object} options
	 */
	initialize: function($super, options) {
		$super(options);
		
		this._chooseImageButtonText = (this.options.multiple ? Language.get("bbq.gui.updateables.UpdateableFileField.uploadfiles") : Language.get("bbq.gui.updateables.UpdateableFileField.uploadfile"));
		this.addClass("UpdateableFileField");
	},
	
	/**
	 * @param {Event} event
	 */
	_showFilePickerWindow: function(event) {
		var filePicker = new deadline.gui.uploads.FileUploader({
			title: this._chooseImageButtonText,
			multiple: this.options.multiple
		});
		filePicker.registerListener("onFilesUploaded", this._filesUploaded.bind(this));
		currentPage.addModalLayer(filePicker);
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableDropDown
 * @extends behaviour.gui.updateables.UpdateableField  
 */
behaviour.gui.updateables.UpdateableDropDown = new Class.create(behaviour.gui.updateables.UpdateableField, {
	dropDown: null,
	fields: null,
	
	/**
	 * 
	 * Supports the folloing options:
	 * 
	 * options: {
	 * 		keys: Array
	 * }
	 * 
	 * Supports the following callbacks
	 * 
	 * onValueChanged
	 * 
	 * @param {Object} options
	 * 
	 * }
	 */
	initialize: function($super, options) {
		$super(options);	
		
		this.addClass("UpdateableDropDown");
	},
	
	_setInitialValues: function() {
		this.fields = this.options.keys;
		this.options.initialValue = this.options.initialValue ? this.options.initialValue : 0;
		behaviour.gui.updateables.UpdateableField.prototype._setInitialValues.call(this);
		this._setDisplayValue(this.fields[this._getCurrentValue()]);
	},
	
	_updateInitialValues: function() {
		behaviour.gui.updateables.UpdateableField.prototype._updateInitialValues.call(this);
		this._setDisplayValue(this.fields[this._getCurrentValue()]);
	},
	
	_createViewFieldFromPropertyDisplay: function() {
		return this.options.propertyDisplay.entity.getPropertyDisplay({property: this.options.propertyDisplay.key, formatter: function(key) {
			return this.fields[key]
		}.bind(this)});
	},
	
	/**
	 * Cancels drop down change to the previous state
	 */
	cancelEdit: function() {
		this._setCurrentValue(this._getOriginalValue());
		this._setDisplayValue(this.fields[this._getCurrentValue()]);
	},
	
	/**
	 * Creates drop down fields
	 */
	createEditField: function() {
		this.dropDown = DOMUtil.createElement("select", {
			onfocus: this._clearFocusWatcher.bind(this),
			onchange: this.updateLocalValue.bindAsEventListener(this)
		});
		
		if(this.fields instanceof Array) {
			for(var i = 0, iCount=this.fields.length; i < iCount; i++) {
				var node = document.createElement("option");
				node.appendChild(document.createTextNode(this.fields[i]));
				node.value = i;
				
				if(i == this._getCurrentValue()) {
					node.selected = "selected";
				}
				
				this.dropDown.appendChild(node);
			}
		} else {
			for(var key in this.fields) {
				var node = document.createElement("option");
				node.appendChild(document.createTextNode(this.fields[key]));
				node.value = key;
				
				if(key == this._getCurrentValue()) {
					node.selected = "selected";
				}
				
				this.dropDown.appendChild(node);
			}
		}
		
		this.dropDown.disabled = this.disabled;
		return this.dropDown;
	},
	
	/**
	 * Saves drop down change
	 */
	saveEdit: function() {
		this._setOriginalValue(this._getCurrentValue());
		this._setDisplayValue(this.fields[this._getCurrentValue()]);
	},
	
	/**
	 * Updaates local value and triggers Event "onchange"
	 * @return {void}
	 */
	updateLocalValue: function() {
		if(this.dropDown && this.dropDown.selectedIndex != null) {
			this._setCurrentValue(this.dropDown.selectedIndex);
			this._setDisplayValue(this.fields[this._getCurrentValue()]);
		}
		
		this.notifyListeners("onValueChanged");
	},
	
	getValue: function(supressErrorWarning) {
		if(!this.getEditMode() && this.fields[this._getCurrentValue()] && this.fields[this._getCurrentValue()].strip() == "") {
			// if the visual representation of this field is an empty string, return null so we will be skipped in tables with hideEmptyFields set to true
			return null;
		}
		
		if(this.options.values && this.options.values[this._getCurrentValue()]) {
			return this.options.values[this._getCurrentValue()];
		}
	
		return this._getCurrentValue();
	}
});

/**
 * @class behaviour.gui.PickableCalendar
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.PickableCalendar = new Class.create(behaviour.gui.GUIWidget, {
	
	monthDays: new Array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31),
	_today: null,
	_date: null,
	_initialDate: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		startDate:	Date		// the initially selected date (optional)
	 * 		owner:		Object		// should have a method datePicked(Date:date)
	 * 		title:				String		// the calendar title
	 * 		createCell:	function(day, cell, callbackFunction rowNumber, columnNumber)
	 * 		prevCallback: function(date)
	 * 		nextCallback: function(date)
	 * }
	 */
	initialize: function($super, options) {
		$super(options);
		
		if(this.options.startDate instanceof Date) {
			this._date = this.options.startDate;
		} else {
			this._date = new Date(this.options.startDate);
		}
		
		this.setRootNode("div");
		this.addClass("pickableCalendar");
		
		this._today = new Date();
		this._initialDate = new Date(this._date.getTime());
		this.render();
	},
	
	render: function() {
		// check for leap years
		if(this._date.getMonth() == 1 && (this._date.getFullYear() % 4 == 0 || (this._date.getFullYear() % 100 == 0 && this._date.getFullYear() % 400 == 0))) {
			this.monthDays[1] = 29;
		} else {
			this.monthDays[1] = 28;
		}
		
		DOMUtil.emptyNode(this.rootNode);
		
		var dateTable = document.createElement("table");
		var dateTableBody = document.createElement("tbody");
		dateTable.appendChild(dateTableBody);
		
		// title
		if(typeof(this.options.title) != "undefined") {
			var titleRow = DOMUtil.createTableHeaderRow(1);
			titleRow.childNodes[0].appendChild(document.createTextNode(this.options.title));
			titleRow.childNodes[0].colSpan = 7;
			DOMUtil.addClass(titleRow.childNodes[0], "titlecell");
			dateTableBody.appendChild(titleRow);
		}
		
		var topRow = DOMUtil.createTableHeaderRow(3);
		
		// back
		var backMonthLink = DOMUtil.createTextElement("a", "<", {href: ".", onclick: this.previousMonth.bindAsEventListener(this), title: Language.get("bbq.gui.PickableCalendar.previousmonth")});
		DOMUtil.addClass(topRow.childNodes[0], "prevnext");
		topRow.childNodes[0].appendChild(backMonthLink);
		
		// month
		topRow.childNodes[1].appendChild(document.createTextNode(Language.get("bbq.gui.PickableCalendar.months" + this._date.getMonth()) + " " + this._date.getFullYear()));
		topRow.childNodes[1].colSpan = 5;
		
		// forwards
		var forwardMonthLink = DOMUtil.createTextElement("a", ">", {href: ".", onclick: this.nextMonth.bindAsEventListener(this), title: Language.get("bbq.gui.PickableCalendar.nextmonth")});
		DOMUtil.addClass(topRow.childNodes[2], "prevnext");
		topRow.childNodes[2].appendChild(forwardMonthLink);
		
		dateTableBody.appendChild(topRow);
		
		// day headers
		var dayRow = DOMUtil.createTableHeaderRow(7);
		
		for(var i = 0; i < 7; i++) {
			dayRow.childNodes[i].appendChild(document.createTextNode(Language.get("bbq.gui.PickableCalendar.days" + i).substr(0, 1)));
		}
		
		dateTableBody.appendChild(dayRow);
		
		// pad out the first row
		var tempDate = new Date(this._date.getTime());
		tempDate.setDate(1);
		
		var padding = tempDate.getDay();
		var row = document.createElement("tr");
		
		var n = 0;
		
		for(; n < padding; n++) {
			var cell = document.createElement("td");
			cell.appendChild(document.createTextNode(" "));
			row.appendChild(cell);
		}
		
		// loop through the days of the month
		var j = 1;
		var datePickedCallback = this._datePicked.bindAsEventListener(this);
		
		for(var k = 1, kCount=this.monthDays[this._date.getMonth()]; k <= kCount; k++) {
			if(n == 7) {
				dateTableBody.appendChild(row);
				row = document.createElement("tr");
				
				if(j % 2 == 0) {
					DOMUtil.addClass(row, "even");
				}
				
				n = 1;
				j++;
			} else {
				n++;
			}
			
			var cell = document.createElement("td");
			
			if(this.options.createCell) {
				cell.appendChild(this.options.createCell(k, cell, DOMUtil.createElement("a",  {href: ".", onclick: datePickedCallback}), j, n));
			} else {
				cell.appendChild(DOMUtil.createTextElement("a", k, {href: ".", onclick: datePickedCallback}));
			}
			
			tempDate.setDate(k);
			
			DOMUtil.addClass(cell, "day");
			
			if(this.options.showStartDate && this.equals(tempDate, this._initialDate)) {
				DOMUtil.addClass(cell, "originalDate");
			} else if(this.options.showToday && this.equals(tempDate, this._today)) {
				DOMUtil.addClass(cell, "today");
			}
			
			row.appendChild(cell);
		}
		
		// pad out the last row if necessary
		if(n != 0) {
			for(; n < 7; n++) {
				var cell = document.createElement("td");
				cell.appendChild(document.createTextNode(" "));
				row.appendChild(cell);
			}
			
			dateTableBody.appendChild(row);
		}
		
		this.rootNode.appendChild(dateTable);
	},
	
	equals: function(date1, date2) {
		return (date1.getFullYear() == date2.getFullYear() && date1.getMonth() == date2.getMonth() && date1.getDate() == date2.getDate());
	},
	
	previousMonth: function(event) {
		BehaviourUtil.clearFocus(event);
		
		try {
			this._date.setMonth(this._date.getMonth() - 1);
			
			if(this.options.prevCallback) {
				this.options.prevCallback(new Date(this._date));
			}
			
			this.render();	
			
			this.notifyListeners("onMonthChanged");
		} catch(e) {
			Log.dumpException(e);
		}
		return false;
	},
	
	nextMonth: function(event) {
		BehaviourUtil.clearFocus(event);
		
		try {
			this._date.setMonth(this._date.getMonth() + 1);
			
			if(this.options.nextCallback) {
				this.options.nextCallback(new Date(this._date));
			}
			
			this.render();
			
			this.notifyListeners("onMonthChanged");
		} catch(e) {
			Log.dumpException(e);
		}
		
		return false;
	},
	
	_datePicked: function(event) {
		this.notifyListeners("onDatePicked");
		Log.info('_datePicked in PickableCalendar');
		//Log.dumpObject(event);
		var element = BehaviourUtil.clearFocus(event);
		
		this._date.setDate(element.innerHTML);
		
		if(this.options.owner && this.options.owner.datePicked) {
			this.options.owner.datePicked(this._date);
		}
		
		return false;
	}
});

/**
 * @class behaviour.gui.DatePicker
 * @extends behaviour.gui.GUIWidget
 */
behaviour.gui.DatePicker = new Class.create(behaviour.gui.FloatingWindow, {
	
	_floatingWindow: null,
	_calendar: null,
	_dateController: null,
	
	/**
	 * @param {mixed} options
	 * @example
	 * Supports the following options
	 * 
	 * options: {
	 * 		owner: Object				// should have the method datePicked(Date:date)
	 * 		title:		String					// window title
	 * 		startDate:	Date			// initially selected date
	 * 		pointerEvent: Event		// the mouse click that opened the window
	 * }
	 */
	initialize: function($super, options) {
		options.nearPointer = true;
		
		$super(options);
		
		if(!(this.options.startDate instanceof Date)) {
			this.options.startDate = new Date(this.options.startDate);
		}
		
		this._calendar = new behaviour.gui.PickableCalendar({owner: this, startDate: this.options.startDate, showStartDate: this.options.showStartDate});
		
		this.setWindowTitle(this.options.title);
		this.setContent(this._calendar);
		
		this.registerListener("onWindowClosed", function() {
			this.options.owner.datePicked();
		}.bind(this));
		
		this._calendar.registerListener("onMonthChanged", function() {
			var dims = Element.getDimensions(this._calendar.getRootNode().getElementsByTagName("table")[0]);
			this.setWindowSize(this.options.width, dims.height + 30, 0.2);
		}.bind(this));
	},
	
	appear: function($super) {
		$super();
		
		var dims = Element.getDimensions(this.getRootNode());
		this.options.width = dims.width;
		this.options.height = dims.height;
	},
	
	datePicked: function(date) {
		this.disappear();
		this.options.owner.datePicked(date);
	}
});

/**
 * @class behaviour.gui.button.IconButton 
 * @extends behaviour.gui.button.GUIButton 
 */
behaviour.gui.button.DatePickerButton = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("DatePickerButton");
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableDateField
 * @extends behaviour.gui.updateables.UpdateableField  
 */
behaviour.gui.updateables.UpdateableDateField = new Class.create(behaviour.gui.updateables.UpdateableField, {
	_datePicker: null,
	_dayDropDown: null,
	_hourDropDown: null,
	_minuteDropDown: null,
	_monthDropDown: null,
	_yearDropDown: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Supports the following options
	 * 
	 * options: {
	 * 		pickerTitle:		String
	 * 		initialValue:	Date, int or undefined
	 * 		mustBeGreaterThan:	behaviour.gui.updateables.UpdateableDateField
	 * 		mustBeLessThan:	behaviour.gui.updateables.UpdateableDateField
	 * 		shortDate: boolean		if true, hours and minutes will not be shown
	 * }
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("UpdateableDateField");
	},
	
	_setInitialValues: function() {
		if(typeof(this.options.propertyDisplay) != "undefined") {
			this._setCurrentValue(new Date(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key)));
			this._setOriginalValue(new Date(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key)));
		} else {
			if(typeof(this.options.initialValue) == "undefined" || this.options.initialValue == null) {
				this.options.initialValue = new Date();
				
				// set to midday
				this.options.initialValue.setHours(12, 0, 0, 0);
			} else if(this.options.initialValue instanceof Date) {
				// create copy of passed date object
				this.options.initialValue = new Date(this.options.initialValue);
			} else {
				// timestamp passed, hopefully
				this.options.initialValue = new Date(parseInt(this.options.initialValue));
			}
			
			this._setCurrentValue(new Date(this.options.initialValue));
			this._setOriginalValue(new Date(this.options.initialValue));
		}
		
		this._setDisplayValue(DateFormatter.getFormattedDate({date: this._getCurrentValue(), withStrings: true, shortDate: this.options.shortDate}));
	},
	
	_updateInitialValues: function() {
		this._setCurrentValue(new Date(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key)));
		this._setOriginalValue(new Date(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key)));
		this._setDisplayValue(DateFormatter.getFormattedDate({date: this._getCurrentValue(), withStrings: true, shortDate: this.options.shortDate}));
	},
	
	_createViewFieldFromPropertyDisplay: function() {
		return this.options.propertyDisplay.entity.getPropertyDisplay({property: this.options.propertyDisplay.key, formatter: function(date) {
			return DateFormatter.getFormattedDate({date: date, withStrings: true, shortDate: this.options.shortDate});
		}.bind(this)});
	},
	
	cancelEdit: function() {
		this._setCurrentValue(new Date(this._getOriginalValue()));
		this._setDisplayValue(DateFormatter.getFormattedDate({date: this._getCurrentValue(), withStrings: true, shortDate: this.options.shortDate}));
	},
	
	createEditField: function() {
		var datePicker = new behaviour.gui.button.DatePickerButton({
			onclick: this.openDatePicker.bind(this),
			toolTip: Language.get("bbq.gui.updateables.UpdateableDateField.opendatepicker")
		});
		
		var node = DOMUtil.createElement("nobr");
		datePicker.appendTo(node);
		
		var dateOrder = DateFormatter.getOrder({shortDate: this.options.shortDate});
		var dateFragment;
		
		for(var i = 0, iCount=dateOrder.length; i < iCount; i++) {
			if(this["generate" + dateOrder[i]]) {
				dateFragment = this["generate" + dateOrder[i]].call(this)
				if(dateFragment.hide !== true || dateFragment.hide == "undefined") { 
					node.appendChild(dateFragment);
				}
			} else {
				Log.info("Invalid date atom - " + dateOrder[i]);
			}
		}
		
		return node;
	},
	
	openDatePicker: function(event) {
		try {
			if(!this._datePicker) {
				this._datePicker = new behaviour.gui.DatePicker({width: 142, height: 176, owner: this, title: this.options.pickerTitle, startDate: this._getCurrentValue(), pointerEvent: event, showStartDate: true});
				this._datePicker.appear();
			}
		} catch(e) {
			Log.dumpException(e);
		}
		return false;
	},
	
	datePicked: function(pickedDate, autoCorrect) {
		if(pickedDate instanceof Date) {
			this._getCurrentValue().setTime(pickedDate.getTime());
			this.render();
			
			if(typeof(autoCorrect) == "undefined" ) { // prevent recursion
				this.notifyListeners("onValueChanged");
			}
		}
		
		this._datePicker = null;
	},
	
	generateDay: function() {
		this._dayDropDown = DOMUtil.createElement("select", {
			onfocus: this._clearFocusWatcher.bind(this),
			onchange: this.updateLocalValue.bindAsEventListener(this),
			name: "days"
		});
		
		var daysInMonth = this.getDaysInMonth(this._getCurrentValue());
		
		for(var i = 1; i <= daysInMonth; i++) {
			var option = document.createElement("option");
			option.value = i;
			option.appendChild(document.createTextNode(i));
			
			if(i == this._getCurrentValue().getDate()) {
				option.selected = "selected";
			}
			
			this._dayDropDown.appendChild(option);
		}
		
		this._dayDropDown.disabled = this.disabled;
		
		return this._dayDropDown;
	},
	
	generateDateSeparator: function() {
		return document.createTextNode(DateFormatter.getDateSeparator());
	},
	
	generateEmptySpace: function() {
		//if(Browser.Mozilla) {
		//	return document.createTextNode(" ");
		//}
		
		//return DOMUtil.createElement("wbr");
		return document.createTextNode(" ");
	},
	
	generateBreakableSpace: function() {
		return DOMUtil.createElement("wbr");
	},
	
	generateHour: function() {
		this._hourDropDown = document.createElement("select");
		this._hourDropDown.onchange = this.updateLocalValue.bindAsEventListener(this);
		this._hourDropDown.name = "hours";
		
		for(var i = 1; i < 24; i++) {
			var option = document.createElement("option");
			option.value = i;
			option.appendChild(document.createTextNode((i < 10 ? "0" + i : i)));
			
			if(i == this._getCurrentValue().getHours()) {
				option.selected = true;
			}
			
			this._hourDropDown.appendChild(option);
		}
		
		this._hourDropDown.disabled = this.disabled;
		this._hourDropDown.hide = this.options.hideHours;
		
		return this._hourDropDown;
	},
	
	generateMinute: function() {
		this._minuteDropDown = DOMUtil.createElement("select", {onchange: this.updateLocalValue.bindAsEventListener(this), name: "minutes"});
		
		for(var i = 0; i < 60; i += 15) {
			var option = document.createElement("option");
			option.value = i;
			option.appendChild(document.createTextNode((i < 10 ? "0" + i : i)));
			
			if(i == this._getCurrentValue().getMinutes()) {
				option.selected = true;
			}
			
			this._minuteDropDown.appendChild(option);
		}
		
		this._minuteDropDown.disabled = this.disabled;
		this._minuteDropDown.hide = this.options.hideMinutes;
		return this._minuteDropDown;
	},
	
	generateMonth: function() {
		this._monthDropDown = DOMUtil.createElement("select", {onchange: this.updateLocalValue.bindAsEventListener(this), name: "months"});
		
		for(var i = 0; i < 12; i++) {
			var option = document.createElement("option");
			option.value = i;
			option.appendChild(document.createTextNode(Language.get("bbq.gui.updateables.UpdateableDateField.months" + i).substr(0, 3)));
			
			if(i == this._getCurrentValue().getMonth() || "0" + i == this._getCurrentValue().getMonth()) {
				option.selected = true;
			}
			
			this._monthDropDown.appendChild(option);
		}
		
		this._monthDropDown.disabled = this.disabled;
		
		return this._monthDropDown;
	},
	
	generateTimeSeparator: function() {
		if(this.options.hideMinutes) {
			return this.generateEmptySpace();
		} else {
			return document.createTextNode(DateFormatter.getTimeSeparator());
		}
	},
	
	generateYear: function() {
		this._yearDropDown = DOMUtil.createElement("select", {onchange: this.updateLocalValue.bindAsEventListener(this), name: "years"});
		var currentDate = new Date();
		
		for(var i = currentDate.getFullYear() - 5; i < (currentDate.getFullYear() + 10); i++) {
			var option = document.createElement("option");
			option.value = i;
			option.appendChild(document.createTextNode(i));
			
			if(i == this._getCurrentValue().getFullYear()) {
				option.selected = true;
			}
			
			this._yearDropDown.appendChild(option);
		}
		
		this._yearDropDown.disabled = this.disabled;
		
		return this._yearDropDown;
	},
	
	getDaysInMonth: function(date) {
		return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
	},
	
	getValue: function() {
		return this._getCurrentValue().getTime();
	},
	
	saveEdit: function() {
		this._setOriginalValue(new Date(this._getCurrentValue()));
		this._setDisplayValue(DateFormatter.getFormattedDate({date: this._getCurrentValue(), withStrings: true, shortDate: this.options.shortDate}));
	},
	
	updateLocalValue: function(event) {
		// make sure we don't go off the end of the month - ie. select july 31 then select february
		var daysInCurrentMonth = this.getDaysInMonth(this._getCurrentValue());
		var daysInNewMonth = this.getDaysInMonth(new Date(Form.Element.getValue(this._yearDropDown), Form.Element.getValue(this._monthDropDown)));
		var day = $F(this._dayDropDown);
		
		if(day > daysInNewMonth) {
			day = daysInNewMonth;
		}
		
		if(this._hourDropDown && this._minuteDropDown) {
			this._setCurrentValue(new Date($F(this._yearDropDown), $F(this._monthDropDown), day, $F(this._hourDropDown), $F(this._minuteDropDown), 0));
		} else {
			this._setCurrentValue(new Date($F(this._yearDropDown), $F(this._monthDropDown), day, 0, 0, 0));
		}
		
		this.render();
		this.notifyListeners("onValueChanged");
	},
	
	mustBeGreaterThan: function(dateField) {
		this.registerListener("onValueChanged", function() {
			if(dateField.getValue() > this.getValue()) {
				dateField.datePicked(new Date(this.getValue()), true);
			}
		}.bind(this));
	},
	
	mustBeLessThan: function(dateField) {
		this.registerListener("onValueChanged", function() {
			if(dateField.getValue() < this.getValue()) {
				dateField.datePicked(new Date(this.getValue()), true);
			}
		}.bind(this));
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableTokenField
 * @extends behaviour.gui.updateables.UpdateableTextField 
 */
behaviour.gui.updateables.UpdateableTokenField = new Class.create(behaviour.gui.updateables.UpdateableTextField, {
	_noItemsText: null,
	
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example here
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("UpdateableTokenField");
	},
	
	_setInitialValues: function() {
		if(!Object.isUndefined(this.options.propertyDisplay)) {
			this._setCurrentValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
		} else {
			var value = [];
			
			if(this.options.initialValue instanceof Array) {
				this.options.initialValue.each(function(keyword) {
					value.push(keyword);
				}.bind(this));
			}
			
			this._setCurrentValue(value);
		}
		
		this._setOriginalValue(BehaviourUtil.cloneObject(this._getCurrentValue()));
	},
	
	/**
	 * Called after the object the property display belongs to has loaded it's values
	 */
	_updateInitialValues: function() {
		this._setCurrentValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
		this._setOriginalValue(this.options.propertyDisplay.entity.getProperty(this.options.propertyDisplay.key));
	},
	
	_createViewFieldFromPropertyDisplay: function() {
		return this.options.propertyDisplay.entity.getPropertyDisplay({property: this.options.propertyDisplay.key, formatter: function(words) {
			return this.createViewField();
		}.bind(this)});
	},
	
	createEditField: function() {
		this.inputField = behaviour.gui.updateables.UpdateableTextField.prototype.createEditField.apply(this);
		this.inputField.value = this._getCurrentValue().join(", ").strip();
		
		return this.inputField;
	},
	
	createViewField: function() {
		if(!this._getCurrentValue() || this._getCurrentValue().length == 0) {
			return this._noItemsText;
		}
		
		var documentFragment = document.createDocumentFragment();
		
		this._getCurrentValue().each(function(word) {
			var textToken = new behaviour.gui.token.TextToken({text: word});
			textToken.appendTo(documentFragment);
		});
		
		return documentFragment;
	},
	
	_validateInput: function(input, currentValues) {
		Log.error("UpdateableTokenField#_validateInput not overridden");
	},
	
	updateLocalValue: function() {
		if(this.options.inlineInstruction && this.inputField.value == this.options.inlineInstruction) {
			// no value has been entered
			this._setCurrentValue([]);
		} else {
			// create array from entered words
			var words = []; 
			
			this.inputField.value.split(",").each(function(word) {
				word = word.strip();
				
				// make sure we don't return duplicate words
				if(this._validateInput(word, words)) {
					words.push(word);
				}
			}.bind(this));
			
			this._setCurrentValue(words);
		}
		
		this.notifyListeners("onValueChanged");
		this.checkForRequired();
	},
	
	checkForRequired: function() {
		if(this.getEditMode()) {
			if(this.options.required && (!this._getCurrentValue() || this._getCurrentValue().length == 0)) {
				this.addClass("error");
				return false;
			} else {
				this.setError(false);
			}
		}
		return true;
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableKeywords
 * @extends behaviour.gui.updateables.UpdateableTokenField 
 */
behaviour.gui.updateables.UpdateableKeywords = new Class.create(behaviour.gui.updateables.UpdateableTokenField, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example here
	 * 
	 */
	initialize: function($super, options) {
		$super(options);
		
		this._noItemsText = Language.get("bbq.gui.updateables.UpdateableKeywords.nokeywords");
		this.addClass("UpdateableKeywords");
	},
	
	_validateInput: function(input, currentValues) {
		return input != "" && currentValues.indexOf(input) == -1;
	}
});

/**
 * @class behaviour.gui.updateables.UpdateableCheckBox A single line HTML text input field.
 * @extends behaviour.gui.updateables.UpdateableField 
 */
behaviour.gui.updateables.UpdateableCheckBox = new Class.create(behaviour.gui.updateables.UpdateableField, {
	inputField: null,
	
	/**
	 * @param {Object} options 
	 * @example
	 * Supports the following options:
	 * 
	 * options: {
	 * 		searchBox: boolean				// if true will render a mac like search box on Safari
	 * }
	 */
	initialize: function($super, options) {
		if(typeof(options) == "undefined") {
			options = {};
		}
		
		options.initialValue = options.initialValue ? true : false; 
		
		$super(options);
		
		this.addClass("UpdateableCheckBox");
	},
	
	/**
	 * Creates an editable representation of this field
	 */
	createEditField: function() {
		this.inputField = DOMUtil.createElement("input", {type: "checkbox", checked: this.getValue(true)});
		
		Event.observe(this.inputField, "blur", this._processEventCallback.bindAsEventListener(this, "onblur"));
		Event.observe(this.inputField, "focus", this._processEventCallback.bindAsEventListener(this, "onfocus"));
		Event.observe(this.inputField, "change", this._processEventCallback.bindAsEventListener(this, "onchange"));
		Event.observe(this.inputField, "click", this._processEventCallback.bindAsEventListener(this, "onclick"));
		
		return this.inputField;
	},
	
	createViewField: function() {
		if(this.getValue(true) && this.options.checkedText) {
			return document.createTextNode(this.options.checkedText);
		} else if(!this.getValue(true) && this.options.unCheckedText) {
			return document.createTextNode(this.options.unCheckedText);
		}
		
		return behaviour.gui.updateables.UpdateableField.prototype.createViewField.apply(this);
	},
	
	_processEventCallback: function(event, type) {
		setTimeout(function() {
			this.updateLocalValue();
			
			if(this.options[type] && this.options[type] instanceof Function) {
				this.options[type]();
			}
			
			this.notifyListeners(type);
		}.bind(this), 100);
	},
	
	updateLocalValue: function() {
		var newValue = this.inputField.checked ? true : false;
		var shouldNotify = false;
		
		if(this.currentValue != newValue) {
			shouldNotify = true;
		}
		
		this.currentValue = newValue;
		
		if(shouldNotify) {
			this.notifyListeners("onValueChanged");
		}
	},
	
	/**
	 * Ensure we return a boolean value
	 */
	getValue: function(supressErrorWarning) {
		if(behaviour.gui.updateables.UpdateableField.prototype.getValue.call(this, supressErrorWarning)) {
			return true;
		}
		
		return false;
	}
});

/**
 * @class deadline.gui.panel.help.EntityHelpPanel
 * @extends behaviour.gui.panel.Panel
 */
deadline.gui.panel.help.EntityHelpPanel = new Class.create(behaviour.gui.panel.Panel, {
	
	_mainTextBox: null,
	_arrowTextBoxes: null,
	
	initialize: function($super, options) {
		if(Object.isUndefined(options)) {
			options = {};
		}
		
		options.direction = "vertical";
		
		$super(options);
		
		this.addClass("EntityHelpPanel");
		
		this._mainTextBox = this.appendChild(DOMUtil.createElement("div", {className: "EntityHelpPanel_MainTextBox"}));
		
		this._arrowTextBoxes = {};
		this._arrowTextBoxes["topLeft"] = this.appendChild(DOMUtil.createElement("div", {className: "EntityHelpPanel_ArrowBox EntityHelpPanel_ArrowBoxTopLeft", style: {display: "none"}}));
		this._arrowTextBoxes["topRight"] = this.appendChild(DOMUtil.createElement("div", {className: "EntityHelpPanel_ArrowBox EntityHelpPanel_ArrowBoxTopRight", style: {display: "none"}}));
		this._arrowTextBoxes["bottomLeft"] = this.appendChild(DOMUtil.createElement("div", {className: "EntityHelpPanel_ArrowBox EntityHelpPanel_ArrowBoxBottomLeft", style: {display: "none"}}));
		this._arrowTextBoxes["bottomRight"] = this.appendChild(DOMUtil.createElement("div", {className: "EntityHelpPanel_ArrowBox EntityHelpPanel_ArrowBoxBottomRight", style: {display: "none"}}));
	},
	
	_setMainTextBox: function(text) {
		DOMUtil.emptyNode(this._mainTextBox);
		DOMUtil.append(text, this._mainTextBox);
	},
	
	_setArrowText: function(boxOrientation, arrowOrientation, text) {
		var arrowBox = this._arrowTextBoxes[boxOrientation];
		
		DOMUtil.emptyNode(arrowBox);
		DOMUtil.append(text, arrowBox);
		DOMUtil.setStyle(arrowBox, "display", "block");
		DOMUtil.addClass(arrowBox, "EntityHelpPanel_ArrowBoxArrow" + BehaviourUtil.capitalize(arrowOrientation));
	}
});

/**
 * @class deadline.gui.panel.help.DetailHelpPanel
 * @extends deadline.gui.panel.help.EntityHelpPanel
 */
deadline.gui.panel.help.DetailHelpPanel = new Class.create(deadline.gui.panel.help.EntityHelpPanel, {
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("DetailHelpPanel");
	}
});

/**
 * @class deadline.gui.panel.help.AssetDetailHelp
 * @extends deadline.gui.panel.help.DetailHelpPanel
 */
deadline.gui.panel.help.AssetDetailHelp = new Class.create(deadline.gui.panel.help.DetailHelpPanel, {
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("AssetDetailHelp");
		
		this._setMainTextBox(Language.get("deadline.gui.panel.help.AssetDetailHelp.help"));
	}
});

/**
 * @class deadline.gui.panel.help.FileDetailHelp
 * @extends deadline.gui.panel.help.AssetDetailHelp
 */
deadline.gui.panel.help.FileDetailHelp = new Class.create(deadline.gui.panel.help.AssetDetailHelp, {
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("FileDetailHelp");
		
		this._setMainTextBox(Language.get("deadline.gui.panel.help.FileDetailHelp.help"));
	}
});

/**
 * @class deadline.gui.DetailArea
 * @extends behaviour.gui.panel.Panel
 */
deadline.gui.DetailArea = new Class.create(behaviour.gui.panel.Panel, {
	
	_parentEntity: null,
	_entityTable: null,
	_entityNames: null,
	_entityName: null,
	_currentDetailEntity: null,
	_entities: null,
	_saveCancel: null,
	_detailLoadingText: null,
	_listLoadingText: null,
	_emptyListText: null,
	_entitySelector: null,
	_creatingNewEntity: null,
	
	/**
	 * Constructor
	 * Supports the following options
	 * options: {
	 * 
	 * }
	 * @param {Object} example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("DetailArea");
		
		var detailPanel = new behaviour.gui.panel.DualPanel({direction: "horizontal"});
		detailPanel.setPanel1(new behaviour.gui.panel.ScrollableHolder({
			attributes: {
				className: "DetailArea_DetailsLeft"
			}
		}));
		detailPanel.setPanel2(new behaviour.gui.panel.DualPanel({
				direction: "vertical", 
				panel1: new deadline.gui.panel.HeaderPanel(),
				panel2: new behaviour.gui.panel.ScrollableHolder(),
				attributes: {
					className: "DetailArea_DetailsRight"
				}
		}));
		
		this.addPanel({panel: detailPanel, withName: "detailPanel"});
		
		if(!this.options.nofooter) {
			// footer panel
			this.addPanel({panel: new deadline.gui.panel.HeaderPanel({attributes: {className: "DetailAreaFooter"}}), withName: "footer"});
			
			this._searchBox = new deadline.gui.SearchBox();
			
			this.getFooterPanel().empty();
			this.getFooterPanel().setHeaderLeft(this._searchBox);
			this.getFooterPanel().setHeaderRight(this._createNewEntityButton());
		}
		
		this._entities = [];
	},
	
	/**
	 * Returns list type panel
	 * @return {behaviour.gui.panel.Panel}
	 */
	getListPanel: function() {
		return this.getPanel("detailPanel").getPanel1();
	},
	
	/**
	 * Returns detail type panel
	 * @return {behaviour.gui.panel.Panel}
	 */
	getDetailPanel: function() {
		return this.getPanel("detailPanel").getPanel2();
	},
	
	/**
	 * Returns detail type panel
	 * @return {behaviour.gui.panel.Panel}
	 */
	setDetailPanel: function(detailPanel) {
		//this.getPanel("detailPanel").setPanel2(panel);
		
		
		detailPanel.addClass("DetailArea_DetailsRight");
		
		var panel = this.getPanel("detailPanel");
		panel.setPanel2(detailPanel);
		panel.getPanel2().render();
		panel.resize();
	},
	
	
	getFooterPanel: function() {
		//return this.getPanel2();
		return this.getPanel("footer");
	},
	
	/**
	 * @private
	 */
	_chooseInitialDisplay: function() {
		// decide what to put in the right hand panel
		if(BehaviourUtil.isGUID(this.options.overrideID)) {
			//Log.info("_chooseInitialDisplay showing override entity");
			this.showEntity(this.options.overrideID);
			
			// make sure we don't show it again
			this.options.overrideID = null;
		} else if(!this._currentDetailEntity && !this._entitySelector) {
			//Log.info("_chooseInitialDisplay showing first entity");
			
			if(this._entityTable && this._entityTable.getFirstEntity()) {
				this._displayDetail(this._entityTable.getFirstEntity());
			} else {
				this.showHelp();
			}
		} else {
			// already showing something so do nothing
			
			//Log.info("_chooseInitialDisplay not doing anything");
		}
	},
	
	/**
	 * @private
	 */
	_getEntities: function() {
		return this._entities;
	},
	
	/**
	 * Dislplay list of entities
	 */
	showEntities: function(action) {
		this.getListPanel().empty();
		this.getListPanel().appendChild(new behaviour.gui.LoadingNotification());
		this._searchBox.setOutputField();
		
		this._displayList();
	},
	
	/**
	 * Display details of an entity
	 */
	showEntity: function(id) {
		this._displayDetail(currentPage[this._entityNames].getElement(id));
	},
	
	/**
	 * Not implemented
	 */
	newEntity: function() {
		if(EditWatcher.changesOutstanding()) {
			return false;
		}
		
		this._displayDetail(null);
	},
	
	/**
	 * Not implemented
	 */
	addEntity: function() {
	
	},
	
	/**
	 * Shows greeting
	 */
	showHelp: function() {
		if(this._entityTable) {
			this._entityTable.clearDown();
		}
		
		this._currentDetailEntity = null;
		
		this.setDetailPanel(this._getHelpPanel());
	},
	
	_getHelpPanel: function() {
		
	},
	
	/**
	 * Show first entity from the list
	 */
	showFirstEntity: function() {
		this._chooseInitialDisplay();
	},
	
	/**
	 * Supports the following options
	 * 
	 * options: {
	 * 		headerText
	 * 		entities
	 * 		headerRows
	 * 		columnData
	 * 		tableClass
	 * }
	 * @private
	 * @param {Object} options
	 */
	_displayList: function(options) {
		try {
			options.rowHeight = 21;
			options.createEntity = options.createEntity ? options.createEntity : false;
			options.startSorted = options.startSorted ? options.startSorted : {
				column: 0,
				direction: "DESC"
			},
			options.noEntitiesText = this._emptyListText;
			
			// create table
			this._entityTable = new behaviour.gui.table.ScrollLoadTable(options);
			
			// fired after list loaded
			this._entityTable.registerOneTimeListener("onEntitiesLoaded", this._chooseInitialDisplay.bind(this));
			
			// fired when list is empty
			this._entityTable.registerListener("onEmptyList",  this._chooseInitialDisplay.bind(this));
			
			if(this._searchBox) {
				this._searchBox.setOutputField(this._entityTable);
			}
			
			this.getListPanel().empty();
			this.getListPanel().appendChild(this._entityTable);
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_createNewEntityButton: function() {
		return document.createElement("div");
	},
	
	_instantiateEntity: function(fromData) {
		return currentPage.getEntity(null, this._entityNames, this._entityName);
	},
	
	/**
	 * @private
	 */
	_displayDetail: function(entity) {
		if(EditWatcher.changesOutstanding()) {
			return false;
		}
	
		try {
			if(entity && entity.getId) {
				this._currentDetailEntity = entity;
			} else {
				this._currentDetailEntity = this._instantiateEntity();
			}
			
			var detailPanel = this._getDetailPanel(this._currentDetailEntity);
			
			// maximise footer when user starts to edit entity
			detailPanel.registerListener("onStartedEdit", function() {
				this.options.panel.maximiseFooter();
			}.bind(this));
			
			// if entity has not been saved, show the first item from the list
			detailPanel.registerListener("onCancelledEdit", function() {
				if(this._currentDetailEntity.isNew()) {
					this.showFirstEntity();
				}
			}.bind(this));
			
			this._currentDetailEntity.registerListener("onUpdate", this._entityUpdated.bind(this));
			
			if(this._currentDetailEntity.isNew()) {
				this._entityTable.clearDown();
				this.options.panel.maximiseFooter();
				
				this._currentDetailEntity.registerOneTimeListener("onCreate", this._entityCreated.bind(this));
			} else {
				this._entityTable.setDown(this._currentDetailEntity);
			}
			
			this.setDetailPanel(detailPanel);
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_showDetailPanel: function(detailPanel) {
		detailPanel.addClass("DetailArea_DetailsRight");
		
		var panel = this.getPanel("detailPanel");
		panel.setPanel2(detailPanel);
		panel.getPanel2().render();
		panel.resize();
	},
	
	/**
	 * Should return a {deadline.gui.selectors.EntitySelector}
	 */
	_getChooser: function() {
		
	},
	
	/**
	 * Shows the chooser
	 */
	addEntity: function() {
		if(EditWatcher.changesOutstanding()) {
			return false;
		}
		
		this._entityTable.clearDown();
		this._entityTable.render();
		
		this._entitySelector = this._getChooser();
		this._entitySelector.addClass("DetailArea_DetailsRight");
		this._entitySelector.registerListener("onSelectedEntity", this._addedEntity.bind(this));
		
		var panel = this.getPanel("detailPanel");
		panel.setPanel2(this._entitySelector);
		panel.getPanel2().render();
		panel.resize();
		
		this.options.panel.maximiseFooter();
	},
	
	/**
	 * @private
	 */
	_deleteEntity: function(string, url, args) {
		if(confirm(string)) {
			new behaviour.ajax.JSONRequest({
				url: url, 
				args: args,
				onSuccess: this._deletedEntity.bind(this), 
				method: "post"
			});
		}
	},
	
	/**
	 * @private
	 */
	_deletedEntity: function(serverResponse, json) {
		try {
			this._entityTable.reloadEntities();
			
			if(this._entityTable && this._entityTable.getNumEntities() == 0) {
				this._currentDetailEntity = false;
				this._entityTable = false;
			}
			
			if(this._currentDetailEntity) {
				if(this._currentDetailEntity.getId() == json.id) {
					this.showFirstEntity();
				} else {
					this._entityTable.setDown(this._currentDetailEntity);
				}
			} else if(this._entityTable){
				this._entityTable.loadEntities();
			} else {
				this.showEntities();
			}
			
			// if we currently have an entity selector reload it so the item appears in the list
			if(this._entitySelector) {
				this._entitySelector.loadEntities();
			}
			
			if(this.options.panel.removedEntity) {
				this.options.panel.removedEntity();
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * @private
	 */
	_doneAddedEntity: function(serverResponse, json) {
		try {
			this._entityTable.reloadEntities();
			
			if(this._entitySelector) {
				this._entitySelector.loadEntities();
			} else if (this._currentDetailEntity) {
				this._entityTable.setDown(this._currentDetailEntity);
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_entityUpdated: function(entity) {
		
	},
	
	_entityCreated: function(entity) {
		this._entityTable.reloadEntities();
	}
});

/**
 * @class deadline.gui.panel.detail.FileDetailPanel
 * @extends deadline.gui.panel.detail.EntityDetailPanel
 */
deadline.gui.panel.detail.FileDetailPanel  = new Class.create(deadline.gui.panel.detail.EntityDetailPanel, {
	
	/**
	 * Constructor
	 * @param {mixed} options
	 */
	initialize: function($super, options) {
		if(!options) {
			options = {};
		}
		
		options.headerText = Language.get("deadline.gui.panel.detail.FileDetailPanel.filedetails");
		options.changeWarning = Language.get("deadline.gui.panel.detail.FileDetailPanel.unfinishedfile");
		
		// call parent method
		$super(options);
	
		this.registerListener("onSavedEdit", function() {
			// make remote instances update themselves
			Broadcaster.callFlashFunction("callRemoteMethod", {objectType: "files", objectID: this.options.entity.getID(), methodName: "loadData"});
		}.bind(this));
		this._init();
		this.addClass("FileDetailPanel");
	},
	
	/**
	 * @private
	 */
	_init: function() {
		var detailHolder = new behaviour.gui.panel.Panel({attributes: {className: "OverviewPanelDetailAreaScrollableHolder"}});
		this._createDelete(detailHolder);
		this.getPanel2().insertAtTop(detailHolder);
	},
	
	/**
	 * @return {behaviour.gui.updateables.UpdateableTableView} table
	 */
	getEditTable: function() {
		var table = new behaviour.gui.updateables.UpdateableTableView({withStyledFirstRow: true, hideEmptyFields: true});
		
		var imageField = table.addField(new behaviour.gui.updateables.UpdateableFileField({
			propertyDisplay: {
				key: "uploaded",
				entity: this.options.entity
			},
			getImage: function() {
				if(this.options.entity.getProperty("uploaded")) {
					return "/backend/files/getMidiThumbnail?id=" + this.options.entity.getId() + "&nocache" + BehaviourUtil.generateGUID();
				}
				
				return false;
			}.bind(this),
			uploadTo: "/backend/uploads/uploadFile",
			multiple: this.options.entity.isNew(),
			uploadFunction: this.options.uploadAsset
		}), {name: "assetFile", icon: true});
		
		imageField.registerListener("onFileDeleted", function() {
			this.options.entity.setUploaded(false);
			this.options.entity.setFilename(null);
			this.options.entity.setFilesize(null);
		}.bind(this));
		imageField.registerListener("onFileChosen", function() {
			this.options.entity.setUploaded(true);
		}.bind(this));
		
		table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "filename", entity: this.options.entity}}), {name: "filename", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.filename")});
		table.addField(new behaviour.gui.updateables.UpdateableTextField({propertyDisplay: {key: "credit", entity: this.options.entity}}), {name: "credit", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.credit")});
		
		if(this.options.entity.getFilename()) {
			table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "mimetype", entity: this.options.entity, formatter: function(mimetype) {return Language.get("deadline.shared.filetypes" + mimetype)}}}), {name: "filetype", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.type")});
			table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "filesize", entity: this.options.entity}}), {name: "filesize", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.filesize")});
		} else {
			table.addField(null, {});
			table.addField(null, {});
			table.addField(null, {});
		}
		
		table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "lastmodifieddate", entity: this.options.entity, formatter: function(date){return DateFormatter.getFormattedDate({date: date})}}}), {name: "lastmodifieddate", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.lastmodified"), hideIf: this.options.entity.isNew.bind(this.options.entity)});
		table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "lastmodifiedby.fullname", entity: this.options.entity}}), {name: "lastmodifiedby", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.modifiedby"), hideIf: this.options.entity.isNew.bind(this.options.entity)});
		table.addField(new behaviour.gui.updateables.UpdateableCheckBox({propertyDisplay: {key: "archived", entity: this.options.entity}, checkedText: Language.get("deadline.shared.yes"), unCheckedText: Language.get("deadline.shared.no")}), {name: "archived", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.archived")});
		table.addField(new behaviour.gui.updateables.UpdateableCheckBox({propertyDisplay: {key: "archived", entity: this.options.entity}, checkedText: Language.get("deadline.shared.yes"), unCheckedText: Language.get("deadline.shared.no")}), {name: "archived", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.archived")});
		table.addField(new behaviour.gui.updateables.UpdateableCheckBox({propertyDisplay: {key: "archived", entity: this.options.entity}, checkedText: Language.get("deadline.shared.yes"), unCheckedText: Language.get("deadline.shared.no")}), {name: "archived", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.archived")});
		table.addField(new behaviour.gui.updateables.NonUpdateableField({propertyDisplay: {key: "creationDate", entity: this.options.entity, formatter: function(date){return DateFormatter.getFormattedDate({date: date})}}}), {name: "creationDate", label: Language.get("deadline.gui.panel.detail.FileDetailPanel.creationdate"), hideIf: this.options.entity.isNew.bind(this.options.entity)});
		table.addField(new behaviour.gui.updateables.UpdateableKeywords({propertyDisplay: {key: "keywords", entity: this.options.entity}}), {name: "keywords", label: Language.get("deadline.gui.panel.detail.ContactDetailPanel.keywords")});
		
		return table;
	},
	
	/**
	 * @private
	 */
	_createDelete: function(detailHolder) {
		var deleteButtonHolder = new behaviour.gui.button.ButtonHolder({
				ignoreKeyPresses: true
		});
		deleteButtonHolder.addButton(new behaviour.gui.button.NativeButton({buttonText: Language.get("deadline.gui.panel.detail.FileDetailPanel.delete"), onclick: function() {
			this.notifyListeners("onDeleteFromFileDetailPanel");
		}.bind(this)}));
		
		var deletePanel = new behaviour.gui.panel.Panel({fixedHeight: true, attributes: {className: "OverviewPanelDeletePanel", style: {"display": "none"}}});
		deletePanel.appendChild(DOMUtil.createTextElement("p", Language.get("deadline.gui.panel.detail.FileDetailPanel.deleteasset")));
		deletePanel.appendChild(deleteButtonHolder);
		
		this.registerListener("onStartedEdit", function() {
			if(!this.options.entity.isNew()) {
				deletePanel.setStyle("display", "block");
			}
		}.bind(this));
		
		this.registerListener("onStoppedEdit", function() {
			if(!this.options.entity.isNew()) {
				deletePanel.setStyle("display", "none");
			}
		}.bind(this));
		//this.getPanel2().appendChild(detailHolder);
		detailHolder.addPanel({panel: deletePanel, withName: "deletePanel"});
	},
	
	_getHelpPanel: function() {
		return new deadline.gui.panel.help.FileDetailHelp({asset: this.options.entity});
	}
});

/**
 * @class deadline.gui.button.OldItemIcon 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.OldItemIcon = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("OldItemIcon");
	}
});

/**
 * @class deadline.gui.button.NewItemIcon 
 * @extends behaviour.gui.button.IconButton 
 */
deadline.gui.button.NewItemIcon = Class.create(behaviour.gui.button.IconButton, {
	/**
	 * @param {Object} options
	 * @example
	 * Todo an example
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.addClass("NewItemIcon");
	}
});

/**
 * @class deadline.gui.panel.HeaderPanel
 * @extends behaviour.gui.panel.DualPanel
 */
behaviour.gui.panel.HeaderPanel = new Class.create(behaviour.gui.panel.Panel, {
	
	/**
	 * Constructor
	 */
	initialize: function($super, options) {
		$super(options);
		
		this.options.fixedHeight = true;
		
		this.addClass("HeaderPanel");
	}
});

/**
 * @class deadline.gui.AssetViewer
 * @extends behaviour.gui.GUIWidget
 */
deadline.gui.AssetViewer = new Class.create(behaviour.gui.ModalWindow, {
	
	_detailPanel: null,
	_currentDetailPanel: null,
	_movePanelTimeout: null,
	_detailPanelName: null,
	_detailButtons: null,
	_assignmentSelector: null,
	_assignmentTable: null,
	_packageSelector: null,
	_packageTable: null,
	_detailHelpPanel: null,
	
	/**
	 * Supports the folloiinw options: 
	 * 
	 * options: {
	 * 		asset: deadline.entities.Asset		// The asset to show
	 * }
	 * 
	 * @param {Object} options
	 * @example
	 */
	initialize: function($super, options) {
		
		options.width = 514;
		options.height = 570;
		options.showChrome = true;
		
		$super(options);
		
		this.addClass("AssetViewer");
		
		this._detailPanelName = false;
		
		this.setWindowTitle(this.options.asset.getPropertyDisplay({property: "filename"}));
		
		var imageHolder = DOMUtil.createElement("div", {className: "AssetViewerImageHolder"});
		var assetDetails = DOMUtil.createTextElement("div", [
			DOMUtil.createTextElement("p", this.options.asset.getPropertyDisplay({property: "filename", formatter: function(fileName) {
				return fileName ? fileName + " (" + this.options.asset.getProperty("filesize") + ")"  : Language.get("deadline.shared.awaitingupload");
			}.bind(this)}), {className: "fileName"}),
			DOMUtil.createTextElement("p", this.options.asset.getPropertyDisplay({property: "credit"})),
			DOMUtil.createTextElement("p", this.options.asset.getPropertyDisplay({property: "keywords", formatter: function(keywords) {
				return keywords.join(", ");
			}.bind(this)}))
		], {className: "AssetViewerAssetDetails"});
		
		imageHolder.appendChild(assetDetails);
		
		Effect.Fade(assetDetails, {from: 1, to: 0.8, duration: 0.1});
		
		var image = this.options.asset.getPropertyDisplay({
			property: "uploaded", 
			createNode: function() {
				return DOMUtil.createElement("img", {alt: Language.get("deadline.shared.filetypes" + this.options.asset.getProperty("mimetype"))});
			}.bind(this),
			updateNode: function(node, property) {
				if(this.options.asset.getProperty("uploaded")) {
					DOMUtil.removeClass(imageHolder, "noPreview");
					node.src = "/backend/files/getMaxiThumbnail?id=" + this.options.asset.getId() + "&nocache=" +  BehaviourUtil.generateGUID();
					node.style.display = "block";
				} else {
					DOMUtil.addClass(imageHolder, "noPreview");
					node.style.display = "none";
				}
			}.bind(this)
		});
		
		image.onload = function() {
			if(image.width < 512) {
				image.style.marginLeft = Math.round((512 - image.width)/2) + "px";
			}
			
			if(image.height < 512) {
				image.style.marginTop = Math.round((512 - image.height)/2) + "px";
			}
		};
		
		imageHolder.appendChild(image);
		
		//var buttonArea = DOMUtil.createElement("div", {className: "AssetViewerButtonHolder"});
		var buttonArea = new behaviour.gui.panel.HeaderPanel();
		
		this._detailButtons = new behaviour.gui.button.ButtonHolder({attributes: {className: "AssetViewerButtons"}});
		this._detailButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.shared.details"), rememberDownState: true, onclick: this._showAssetDetails.bind(this), attributes: {className: "AssetViewerDetailsButton"}}));
		this._detailButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.shared.assignments"), rememberDownState: true, onclick: this._showAssetAssignments.bind(this), attributes: {className: "AssetViewerAssignmentsButton"}}));
		this._detailButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.shared.packages"), rememberDownState: true, onclick: this._showAssetPackages.bind(this), attributes: {className: "AssetViewerPackagesButton"}}));
		
		if(this.options.asset.getUploaded && this.options.asset.getUploaded()) {
			this._detailButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.shared.download"), rememberDownState: false, onclick: this.options.asset.download.bind(this.options.asset), attributes: {className: "AssetViewerDownloadButton"}}));
		}
		
		this._detailButtons.addButton(new behaviour.gui.button.GUIButton({buttonText: Language.get("deadline.shared.delete"), rememberDownState: false, onclick: function() {
			this.options.asset.registerOneTimeListener("onDelete", function() {
				this.disappear();
			}.bind(this));
			
			if(confirm(Language.get("deadline.gui.AssetViewer.confirmdeleteasset"))) {
				this.options.asset.deleteEntity();
			}
		}.bind(this), attributes: {className: "AssetViewerDeleteButton"}}));
		
		this._detailButtons.appendTo(buttonArea);
		
		this.setContent(DOMUtil.createTextElement("div", [
			imageHolder,
			buttonArea
		], {className: "AssetViewerAssetDisplay"}));
	},
	
	/**
	 * @private
	 */
	_showAssetDetails: function() {
		try {
			if(this._detailPanelName != "details") {
				this._showDetailPanel("details");
				DOMUtil.emptyNode(this._detailPanel);
				
				this._currentDetailPanel = new deadline.gui.panel.detail.FileDetailPanel({entity: this.options.asset, uploadAsset: this._uploadAsset.bind(this), detailArea: this});
				this._currentDetailPanel.registerListener("onDeleteFromFileDetailPanel", function() {
					this._deleteEntity();
				}.bind(this));
							
				this._currentDetailPanel.appendTo(this._detailPanel);
			} else {
				this._hideDetailPanel();
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	_uploadAsset: function(fileField) {
		//var filePicker = new behaviour.gui.FileUploaderFlash({multiple: false, uploadTo: "/backend/uploads/uploadFile", delegate: {
		var filePicker = new deadline.gui.uploads.FileUploader({
			multiple: false,  
			delegate: {
				cancelUpload: function(filePicker) {
					DOMUtil.emptyNode(this._detailPanel);
					this._currentDetailPanel.appendTo(this._detailPanel);
				}.bind(this),
				saveUpload: function(filePicker) {
					filePicker.notifyListeners("onFilesUploaded");
				}.bind(this)
			}
		});
		
		filePicker.registerListener("onFilesUploaded", function(uploader) {
			DOMUtil.emptyNode(this._detailPanel);
			this._currentDetailPanel.appendTo(this._detailPanel);
			
			fileField._filesUploaded(uploader);
		}.bind(this));
		
		DOMUtil.emptyNode(this._detailPanel);
		filePicker.appendTo(this._detailPanel);
	},
	
	/**
	 * @private 
	 */
	_showAssetAssignments: function() {
		if(this._detailPanelName != "assignments") {
			this._showDetailPanel("assignments");
			
			DOMUtil.emptyNode(this._detailPanel);
		
			var header = new deadline.gui.panel.HeaderPanel();
			header.setHeaderLeft(Language.get("deadline.shared.assignments"));
			//header.setHeaderRight(buttonHolder);
			header.appendTo(this._detailPanel);
			
			var detailHolder = new behaviour.gui.panel.ScrollableHolder({attributes: {className: "AssetViewDetailHolder"}});
			this._assignmentTable = this._getAssignmentTable(detailHolder);
			detailHolder.appendChild(this._assignmentTable);
			detailHolder.appendTo(this._detailPanel);
		} else {
			this._hideDetailPanel();
		}
	},
	
	/**
	 * @private
	 */
	_getAssignmentTable: function(scrollable) {
		var table = new behaviour.gui.table.ScrollLoadTable({
				noEntitiesText: "Currently this file is not used in any assignments",
				rowHeight: 21,
				createEntity: function(data, index) {
					if(typeof(data) != "undefined") {
						return currentPage.getEntity(data, "assignments", "Assignment");
					}
					
					return false;
				}.bind(this),
				url: "/backend/files/getAssignments",
				args: {
					file: this.options.asset.getId()
				},
				startSorted: {
					column: 3,
					direction: "DESC"
				},
				headerText: Language.get("deadline.gui.AssetViewer.assignments"),
				headerRows: [
					Language.get("deadline.shared.story"),
					Language.get("deadline.shared.title"), 
					Language.get("deadline.shared.status"), 
					Language.get("deadline.shared.deadline"),
					Language.get("deadline.shared.view")
				],
				columnData: [{
					text: function(assignment) {
						return assignment.getPropertyDisplay({property: "story.title"});
					}.bind(this),
					sortField: true
				}, {
					text: function(assignment) {
						return assignment.getPropertyDisplay({property: "title"});
					}.bind(this),
					sortField: true
				}, {
					text: function(assignment) {
						return new deadline.gui.button.AssignmentStatusIcon({status: assignment.getProperty("status")});
					}.bind(this),
					sortField: true,
					iconColumn: true
				}, {
					text: function(assignment) {
						return assignment.getPropertyDisplay({property: "deadline", formatter: function(deadline) {return DateFormatter.getFormattedDate({date: deadline, withStrings: true});}}); 
					}.bind(this), 
					sortField: true
				}, {
					text: function(assignment) {
						return new behaviour.gui.button.ViewButton({onclick: function(){document.location = "/stories/#showAssignment/" + assignment.getId()}});
					}.bind(this),
					iconColumn: true
				}]
			});
					
			return table;
	},
	
	/**
	 * @private
	 */
	_showAssetPackages: function() {
		if(this._detailPanelName != "packages") {
			this._showDetailPanel("packages");
			
			DOMUtil.emptyNode(this._detailPanel);
		
			var header = new deadline.gui.panel.HeaderPanel();
			header.setHeaderLeft(Language.get("deadline.shared.packages"));
			header.appendTo(this._detailPanel);
			
			var detailHolder = new behaviour.gui.panel.ScrollableHolder({attributes: {className: "AssetViewDetailHolder"}});
			this._packageTable = this._getPackageTable(detailHolder);
			detailHolder.appendChild(this._packageTable);
			detailHolder.appendTo(this._detailPanel);
		} else {
			this._hideDetailPanel();
		}
	},
	
	/**
	 * @private
	 */
	_getPackageTable: function(scrollable) {
		var table = new behaviour.gui.table.ScrollLoadTable({
				noEntitiesText: "Currently this file is not in any packages",
				rowHeight: 21,
				createEntity: function(data, index) {
					if(typeof(data) != "undefined") {
						return currentPage.getEntity(data, "packages", "Package");
					}
					
					return false;
				}.bind(this),
				url: "/backend/files/getPackages",
				args: {
					file: this.options.asset.getId()
				},
				startSorted: {
					column: 0,
					direction: "DESC"
				},
				headerText: Language.get("deadline.shared.packages"),
				headerRows: [
					Language.get("deadline.shared.title"), 
					Language.get("deadline.shared.status"), 
					Language.get("deadline.shared.view")
				],
				columnData: [{
					text: function(thePackage) {
						return thePackage.getPropertyDisplay({property: "title"});
					}.bind(this),
					sortField: true
				}, {
					text: function(thePackage) {
						return thePackage.getPropertyDisplay({property: "status", formatter: function(status) {return Language.get("deadline.shared.packagestatus" + status);}});
					}.bind(this),
					sortField: true,
					iconColumn: true
				}, {
					text: function(thePackage) {
						return new behaviour.gui.button.ViewButton({onclick: function(){document.location = "/packages/#showPackage/" + thePackage.getId()}});
					}.bind(this),
					iconColumn: true
				}]
			});
			
			return table;
	},
	
	/**
	 * @private
	 */
	_showDetailPanel: function(detailName) {
		this._detailPanelName = detailName;
		
		if(!this._detailPanel) {
			this._detailPanel = DOMUtil.createElement("div", {className: "AssetViewerDetailPanel"});
			this._detailPanel.appendChild(DOMUtil.createElement("div", {className: "AssetViewerHeader"}));
			
			this.setWindowSize(843, 570, 0.25);
		}
		
		this._contentDiv.appendChild(this._detailPanel);
	},
	
	/**
	 * @private
	 */
	_hideDetailPanel: function() {
		this._detailPanelName = false;
		this._detailButtons.clearDown();
		this._contentDiv.removeChild(this._detailPanel);
		this._detailPanel = null;
		
		this.setWindowSize(514, 570, 0.25);
	},
	
	/**
	 * Deletes {deadline.entities.Asset} entity
	 */
	_deleteEntity: function() {
		if(confirm(Language.get("deadline.gui.AssetViewer.confirmdeleteasset"))) {
			new behaviour.ajax.JSONRequest({
				url: "/backend/files/delete", 
				args: {
					id: this.options.asset.getId()
				}, 
				onSuccess: this._deletedEntity.bind(this), 
				method: "post"
			});
		}
	},
	
	/**
	 * @private
	 */
	_deletedEntity: function(serverResponse, json) {
		try {
			if(this.options.asset.getId() == json.id) {
				this.disappear();
				currentPage.reloadEntities();
				this._currentDetailPanel = false;
				this._detailPanel = false;
				this._detailButtons = false;
			}
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Shows help help panel
	 */
	showHelp: function() {
		if(this._detailPanelName == "details") {
			this._detailHelpPanel = new deadline.gui.panel.help.AssetDetailHelp();
			DOMUtil.emptyNode(this._detailPanel);
			
			this._detailHelpPanel.appendTo(this._detailPanel);
		}
	}
});

/**
 * @class deadline.gui.assets.AssetSearchPanel
 * @extends deadline.gui.panel.HeaderPanel
 */
deadline.gui.assets.AssetSearchPanel = new Class.create(deadline.gui.panel.HeaderPanel, {
	
	_imageBrowser: null,
	_searchBox: null,
	_fileTypeFilters: null,
	_showFilters: null,
	_searchBox: null,
	_assetSearchBox: null,
	_filterForm: null,
	_checkBoxes: null,
	_radioButtons: null,
	_radioButton_assetTypes_submitted: null,
	_radioButton_assetTypes_awaiting: null,
	_radioButton_assetTypes_both: null,
	_dropDown_sortBy: null,
	_dropDown_direction: null,
	
	/**
	 * Constructor
	 * @param {mixed} options
	 */
	initialize: function($super, options) {
		$super(options);
	
		this.addClass("AssetSearchPanel");
		
		this._fileTypeFilters = {};
		this._showFilters = {};
		
		this._checkBoxes = {};
		this._radioButtons = {};
		
		["all", "archive", "audio", "image", "text", "video", "interviews", "other"].each(function(fileType) {
			this._checkBoxes[fileType] = DOMUtil.createElement("input", {type: "checkbox", value: fileType, checked: false, onchange: this._fileTypeChanged.bindAsEventListener(this)});
			this._fileTypeFilters[fileType] = true;
		}.bind(this));
		
		this._checkBoxes["all"].checked = true;
		
		["submitted", "awaiting", "both"].each(function(buttonType) {
			this._radioButtons[buttonType] = DOMUtil.createElement("input", {type: "radio", "name": "assetTypes", value: buttonType, checked: false, onchange: this._submittedChanged.bindAsEventListener(this)});
			this._showFilters[buttonType] = false;
		}.bind(this));
		
		this._radioButtons["submitted"].checked = true;
		this._showFilters["submitted"] = true;
			
		this._dropDown_sortBy = DOMUtil.createTextElement("select", [
			DOMUtil.createTextElement("option", Language.get("deadline.gui.assets.AssetSearchPanel.filename"), {value: 0}),
			DOMUtil.createTextElement("option", Language.get("deadline.gui.assets.AssetSearchPanel.filetype"), {value: 1}),
			DOMUtil.createTextElement("option", Language.get("deadline.gui.assets.AssetSearchPanel.filesize"), {value: 2})
		], {onchange: this._sortFieldChanged.bindAsEventListener(this)});
			
		this._dropDown_direction = DOMUtil.createTextElement("select", [
			DOMUtil.createTextElement("option", Language.get("deadline.gui.assets.AssetSearchPanel.ascending"), {value: deadline.constants.DEADLINE_PAGINATOROPTIONS_SORTASC}),
			DOMUtil.createTextElement("option", Language.get("deadline.gui.assets.AssetSearchPanel.descending"), {value: deadline.constants.DEADLINE_PAGINATOROPTIONS_SORTDESC})
		], {onchange: this._sortDirectionChanged.bindAsEventListener(this)});
		
		var uploadedFieldSet = "";
		
		this.addClass("AssetSearchPanel_noUnuploadedFiles");
		
		this._filterForm = DOMUtil.createTextElement("form", [
			DOMUtil.createTextElement("fieldset", [
				DOMUtil.createTextElement("label", Language.get("deadline.gui.assets.AssetSearchPanel.filetype")),
				DOMUtil.createTextElement("span", [
					Language.get("deadline.gui.assets.AssetSearchPanel.types.all"),
					this._checkBoxes["all"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.archive"),
					this._checkBoxes["archive"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.audio"),
					this._checkBoxes["audio"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.image"),
					this._checkBoxes["image"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.text"),
					this._checkBoxes["text"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.video"),
					this._checkBoxes["video"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.interviews"),
					this._checkBoxes["interviews"],
					Language.get("deadline.gui.assets.AssetSearchPanel.types.other"),
					this._checkBoxes["other"]
				])
			]),
			uploadedFieldSet,
			DOMUtil.createTextElement("fieldset", [
				DOMUtil.createTextElement("label", Language.get("deadline.gui.assets.AssetSearchPanel.sortby")),
				DOMUtil.createTextElement("span", [
					this._dropDown_sortBy,
					this._dropDown_direction
				])
			])
	
		], {
			className: "FilterForm",
			action: "",
			method: "post"
		});
		
		this.setPanel1(this._filterForm, "filterForm");
		
		this._searchBox = new deadline.gui.SearchBox({});
		this.setPanel2(this._searchBox, "search");
		
		for(var key in this._checkBoxes){
			this._checkBoxes[key].checked = true;
		}
		this._radioButtons["submitted"].checked = true;
	},
	
	/**
	 * Sets ImageBrowser on the panel
	 * @param {deadline.gui.ImageBrowser} imageBrowser
	 */
	setImageBrowser: function(imageBrowser) {
		this._imageBrowser = imageBrowser;
		this._searchBox.setOutputField(this._imageBrowser);
	},
	
	/**
	 * @return {Array} this._fileTypeFilters
	 */
	getFileTypeFilters: function() {
		return this._fileTypeFilters;
	},
	
	/**
	 * @return {Array} this._showFilters
	 */
	getShowFilters: function() {
		return this._showFilters;
	},
	
	/**
	 * @return {Array} this._showFilters
	 */
	getSortBy: function() {
		Log.info("returning " + {"column": this._dropDown_sortBy.value, "sortDirection": this._dropDown_direction.value});
		
		return {"column": this._dropDown_sortBy.value, "direction": this._dropDown_direction.value};
	},
	
	/**
	 * @private
	 */
	_fileTypeChanged: function(event) {
		var element = BehaviourUtil.clearFocus(event);
		
		if(element.value == "all") {
			if(element.checked) {
				for(var key in this._checkBoxes) {
					this._checkBoxes[key].checked = true;
					this._imageBrowser.options.args.fileTypeFilter[this._checkBoxes[key].value] = true;
				}
				
				this._imageBrowser.reloadEntities();
			} else {
				this._imageBrowser.options.args.fileTypeFilter["all"] = false;
			}
		} else {
			// if file type has been deselected, ensure "all" checkbox is not checked
			if(!element.checked) {
				this._checkBoxes["all"].checked = false; 
				this._imageBrowser.options.args.fileTypeFilter["all"] = false;	
			}
			
			this._imageBrowser.options.args.fileTypeFilter[element.value] = element.checked;
			
			if(this._imageBrowser.options.args.fileTypeFilter["all"] != true) {
				this._imageBrowser.reloadEntities();
			}
		}
	},
	
	/**
	 * @private
	 */
	_submittedChanged: function(event) {
		var element = BehaviourUtil.clearFocus(event);
		
		if(element.value == "awaiting" || element.value == "both") {
			for(var key in this._checkBoxes) {
				this._checkBoxes[key].disabled = true;
			}
		} else {
			for(var key in this._checkBoxes) {
				this._checkBoxes[key].disabled = false;
			}
		}
		
		this._imageBrowser.options.args.showFilter = {};
		
		this._imageBrowser.options.args.showFilter[element.value] = element.checked;
		this._imageBrowser.reloadEntities();
	},
	
	/**
	 * @private
	 */
	_sortFieldChanged: function(event) {
		var element = Event.element(event);
		
		this._imageBrowser.options.args.sortBy = element.value;
		this._imageBrowser.reloadEntities();
	},
	
	/**
	 * @private
	 */
	_sortDirectionChanged: function(event) {
		var element = Event.element(event);
		
		this._imageBrowser.options.args.sortDirection = (element.value == deadline.constants.DEADLINE_PAGINATOROPTIONS_SORTDESC ? deadline.constants.DEADLINE_PAGINATOROPTIONS_SORTDESC : deadline.constants.DEADLINE_PAGINATOROPTIONS_SORTASC);
		this._imageBrowser.reloadEntities();
	}
		
});

/**
 * @class deadline.page.Assets
 * @extends deadline.page.Page
 */
app.page.Assets = new Class.create(deadline.page.Page, {
	
	_assets: null,
	_assetSearchPanel: null,
	
	/**
	 * Constructor
	 */
	initialize: function($super, args) {
		try {
			this.languageSection = "Assets";
			
			this._feedReader = new deadline.gui.FeedReader({url: "/backend/feeds/getItems"});
			
			this._panels = new behaviour.gui.panel.Panel({direction: "vertical", attributes: {className: "mainContent"}});
			this._panels.addPanel({panel: new deadline.gui.panel.HeaderPanel({attributes: {id: "EntityOverviewHeader"}}), withName: "headerPanel"});
			this._panels.addPanel({panel: new behaviour.gui.panel.ScrollableHolder({attributes: {className: "AssetListDisplay"}}), withName: "entitiesPanel"});
			
			this._assets = [];
			
			$super(args);
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Creates the layout manager which controls the position of the various page elements
	 */
	createLayoutManager: function() {
		LayoutManager = new deadline.gui.layout.PageLayoutManager({
			panel: this._panels, 
			feedReader: this._feedReader
		});
	},
	
	/**
	 * Builds the page structure and triggers the loading of messages
	 */
	init: function() {
		try {
			this._assetSearchPanel = new deadline.gui.assets.AssetSearchPanel();
			this._panels.addPanel({panel: this._assetSearchPanel, withName: "searchPanel"});
			
			this._panels.getPanel("headerPanel").setHeaderLeft(DOMUtil.createTextElement("h2", Language.get("deadline", "shared", "assets")));
					
			this._imageBrowser = new deadline.gui.ImageBrowser({
				createEntity: function(data, index) {
					if(typeof(data) != "undefined") {
						return currentPage.getEntity(data, "files", "File");
					}
					return false;
				}.bind(this),
				createImageView: function(asset, index) {
					if(typeof(asset) != "undefined") {
						var output = DOMUtil.createElement("div", {className: "ImageBox"});
						var span = DOMUtil.createElement("span", {className: "AssetImageHolder"});
						
						// create file thumbmail
						var img = asset.getPropertyDisplay({
							property: "uploaded", 
							createNode: function() {
								return DOMUtil.createElement("img", {alt: asset.getProperty("filename")});
							},
							updateNode: function(node, property) {
								if(asset.getProperty("uploaded")) {
									DOMUtil.removeClass(output, "AwaitingUpload");
									node.src = "/backend/files/getMidiThumbnail?id=" + asset.getId() + "&nocache=" + BehaviourUtil.generateGUID();
									delete node.style.display;
								} else {
									DOMUtil.addClass(output, "AwaitingUpload");
									node.src = "/img/pixel.gif";
									node.width = 128;
									node.height = 128;
									
									node.style.marginLeft = "32px";
								}
								
							}.bind(this)
						});
						
						img.onload = function() {
							if(img.width < 192) {
								img.style.marginLeft = Math.round((192 - img.width)/2) + "px";
							}
							
							if(img.height < 128) {
								img.style.marginTop = Math.round((128 - img.height)/2) + "px";
								
								span.style.height = 122 - Math.round(parseInt(img.style.marginTop)/2) + "px";
								
							}
						};
	
						span.appendChild(DOMUtil.createTextElement("a", img, {onclick: this._showAssetDetails.bindAsEventListener(this, asset), href: "."}));
						
						output.appendChild(span);
						
						var filenameParagraph = DOMUtil.createElement("p");
						filenameParagraph.appendChild(DOMUtil.createTextElement("a", asset.getPropertyDisplay({property: "filename", formatter: function(filename) {
							if(asset.getProperty("uploaded")) {
								DOMUtil.removeClass(filenameParagraph, "awaiting");
								return filename;
							}
							
							DOMUtil.addClass(filenameParagraph, "awaiting");
							return Language.get("deadline.shared.awaitingupload");
						}}), {onclick: this._showAssetDetails.bindAsEventListener(this, asset), href: "."}));
						
						DOMUtil.addClass(filenameParagraph, "fileName");
						output.appendChild(filenameParagraph);
						
						var filetypeParagraph = DOMUtil.createElement("p"); 
						filetypeParagraph.appendChild(DOMUtil.createTextElement("a", asset.getPropertyDisplay({property: "mimetype", formatter: function(mimetype) {
							if(asset.getProperty("uploaded")) {
								DOMUtil.removeClass(filetypeParagraph, "awaiting");
								return Language.get("deadline.shared.filetypes" + mimetype);
							}
							
							DOMUtil.addClass(filetypeParagraph, "awaiting");
							return "--";
						}}), {onclick: this._showAssetDetails.bindAsEventListener(this, asset), href: "."}));
						
						output.appendChild(filetypeParagraph);
						
						var filesizeParagraph = DOMUtil.createElement("p"); 
						filesizeParagraph.appendChild(DOMUtil.createTextElement("a", asset.getPropertyDisplay({property: "filesize", formatter: function(filesize) {
							if(asset.getProperty("uploaded")) {
								DOMUtil.removeClass(filesizeParagraph, "awaiting");
								return filesize;
							}
							
							DOMUtil.addClass(filesizeParagraph, "awaiting");
							return "--";
						}}), {onclick: this._showAssetDetails.bindAsEventListener(this, asset), href: "."}));
						
						output.appendChild(filesizeParagraph);
	
						return output;
					}				
					return false;
				}.bind(this),
				url: "/backend/files/load",
				args: {
					fileTypeFilter: this._assetSearchPanel.getFileTypeFilters(),
					showFilter: this._assetSearchPanel.getShowFilters(),
					sortBy: this._assetSearchPanel.getSortBy()
				},
				startSorted: this._assetSearchPanel.getSortBy(),
				boxWidth: 192,
				boxHeight: 192
			});
			
			this._imageBrowser.registerListener("onEntitiesLoaded", function() {
				this.setAssetCount(this._imageBrowser.getNumEntities());
			}.bind(this));
			
			this._imageBrowser.registerListener("onEmptyList", function() {
				this.setAssetCount(0);
			}.bind(this));
			
			this._assetSearchPanel.setImageBrowser(this._imageBrowser);
			
			this._panels.getPanel("entitiesPanel").appendChild(this._imageBrowser);
			this._feedReader.appendTo($("content"));
			this._panels.appendTo($("content"));
			this.setAssetCount(0);
			LayoutManager.resizePanels();
		} catch(e) {
			Log.dumpException(e);
		}
	},
	
	/**
	 * Sets asset count
	 * @param {integer} assetCount 
	 */
	setAssetCount: function(assetCount) {
		this._panels.getPanel("headerPanel").setHeaderRight(DOMUtil.createTextElement("h3", Language.getFormatted("app.page.Assets.assetcount", {num: assetCount})));
		this._panels.getPanel("headerPanel").render();
	},
	
	/**
	 * @private
	 */
	_showAssetDetails: function(event, asset) {
		try {
			var element = BehaviourUtil.clearFocus(event);
			
			asset.registerOneTimeListener("onDelete", function() {
				this.reloadEntities();
			}.bind(this));
			
			var viewer = new deadline.gui.AssetViewer({asset: asset});
			viewer.appear();
		} catch(e) {
			Log.dumpException(e);
		}
		
		return false;
	},
	
	/**
	 * Reload assets
	 */
	reloadEntities: function() {
		this._imageBrowser.reloadEntities();
	}
});
